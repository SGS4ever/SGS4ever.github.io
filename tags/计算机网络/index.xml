<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络 on XR_G&#39;s Blog</title>
    <link>https://xrg.fj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 计算机网络 on XR_G&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://xrg.fj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DoS——拒绝服务攻击</title>
      <link>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</guid>
      <description>网络安全理论复习开始了！
今天从最简单的开始，目标是在寒假期间整理完成《网络安全》这门课所涉及的知识。希望本系列文章能以清晰的思路将安全理论表述出来。
DoS Denial of Service，拒绝服务，是现代网络安全领域很常见的一种攻击。所谓拒绝服务，就是通过一系列手段使得原本正常运行的服务器无法再为用户的请求提供服务与应答，从而使目标业务停滞。
我们经常能看到拒绝服务的例子：使用”呼死你“软件不断地拨打某人的电话，则其他人正常呼叫的时候他永远是占线的状态；网络”水军“控评，正常的评论和留言就无法被看到；黄牛使用恶意的抢票软件抢占所有电影票，使得正常渠道无法获得``````
在计算机网络的世界中，拒绝服务攻击可以是非常粗暴的物理攻击：砸毁服务器、切断网线等；更为常见且稍微有点技术含量的是利用计算机本身的漏洞，构造恶意的网络请求来使目标系统崩溃、主机宕机、重启等。
下面介绍一些常见的DoS攻击手法。
Ping of Death Ping of Death（死亡之Ping）的原理是构造一个超大的IP包来使目标主机瘫痪。在详细解释这个手法之前，需要从ICMP协议入手，介绍Ping的基本知识。
ICMP 网际控制报文协议（ICMP）用于让主机或路由器报告差错和异常情况。ICMP报文包含在IP数据报中，作为IP数据报的数据部分，加上IP首部发送出去，因此，ICMP是一个网络层协议。
ICMP报文的种类有两种，ICMP差错报告报文和ICMP询问报文。
ICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，共有5种类型：
 终点不可达。 源点抑制。由于拥塞而丢弃数据报时，要求源主机减小发送速率。 时间超过。 参数问题。路由器或目的主机收到的数据报首部中有的字段不正确。 改变路由（重定向）。路由器把重定向信息发给主机，下一次使用更好的路由。  ICMP询问报文有4种类型：
 回送请求和应答。主机向目标发送ICMP请求，如果途中没有异常，则目标收到消息后恢复ICMP响应、 时间戳请求和应答。测试来回一次的传输时间。主机填充原始时间戳，接收方受到后填充时间戳返回。 掩码地址请求和回答。 路由器询问和通告。  PING PING工作在应用层。它直接使用网络层的ICMP询问报文，而未使用传输层的TCP或UDP。如果一台主机能PING通另一台主机，证明至少存在着一条可用的物理通路。
Ping of Death 死亡之Ping攻击利用了计算机实现IP协议时存在的缺陷。早期操作系统处理IP分组时，只开辟了64KB的缓冲区用来存放收到的数据包。如果攻击者故意在ICMP Echo（即PING数据报）之后附加非常多的冗余信息，使最终的IP包的大小超过65535字节的上限，接收方在处理这么大的IP包时就会产生内存分配错误，引起系统崩溃、挂起或重启。
可以看到这种攻击的实现主要是由于IP协议栈的漏洞，那为什么叫做死亡之Ping呢？因为使用PING工具太容易完成这种攻击，以至于它也成为了这种攻击的首选武器。当然，除了PING之外的任何能够构造超大IP包的程序都能实现这个攻击。
Ping of Death攻击不好预防，因为IP存在分组机制，每个IP包看起来都非常正常。最好的办法是在系统实现层面进行完善，使内核不再对超过规定长度的包进行重组。
TearDrop 又是IP协议实现的问题。故事从IP分片讲起。
分片 我们知道，数据链路层的每个数据报能够承载的数据量是有上限的，这个上限称为最大传送单元（MTU）。因为IP数据报被封装在数据链路层的数据报中，因此链路层的MTU严格地限制着IP数据报的长度。IP包传送的路径上，有许许多多的链路，可能使用不同的链路层协议，而同时也可能有大小不一的MTU。当IP数据报的总长度大于链路MTU时，需要能够将IP数据报中的数据分装在两个或多个较小的IP数据报中，然后再作为链路层数据进行传送。这些较小的数据报称为片。
片在目的地网络层被重新组装。对于一大堆杂乱无章的片，我们如何正确地重装成一个个独立的IP数据报呢？
IP协议使用首部的标识、标志和片偏移字段来完成对片的重组。我们看看IP数据报的首部：
IP Header
第二行的标识字段占16位。它是一个计数器，每产生一个数据报就加一。分片时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。
标志位有3比特。实际上只有后面2个比特有意义。它们分别是：
 MF位（More Fragment）。当MF = 1时，表示这个数据报后面还有后续的片；当MF = 0时表示这是最后一个片。 DF位（Don&amp;rsquo;t Fragment）。只有DF = 0时才允许将一个数据报分片。若DF = 1且数据报大小大于链路层的MTU，只能丢弃并发送ICMP错误信息。  片偏移占13位。既然一个数据报能被分成好几个小片，那么每个小片需要记录自己在原始数据报中的位置，否则怎么重组呢？片偏移的单位是8B，也就意味着除了最后一个片外，每个片中的有效载荷都是8的倍数（字节）。</description>
    </item>
    
    <item>
      <title>传输层协议——TCP</title>
      <link>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</guid>
      <description>传输层 传输层的功能
从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
实际上，传输层起到一个承上启下的作用。它之下的网络层、数据链路层、物理层被称为通信子网，其实现细节对用户是不可见的。
传输层的功能如下：
 提供进程之间的逻辑通信（即端到端的通信）。进程间的逻辑通信是指本主机上运行的某个进程和对方主机上运行的某个进程进行通信。而与此相对的，网络层提供的是点到点的通信，指的是本主机与对方主机的通信。 复用和分用。多个进程可以使用同一个传输层协议封装自己的数据，而对方主机可以使用同样的协议正确解析这些数据，交付给正确的应用进程。 差错检测。传输层检测首部和数据部分的差错，而网络层只检查IP数据报的首部，不检查数据部分是否出错。 提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。网络层无法同时实现两种协议（即要么使用面向连接的服务，如虚电路；要么只提供无连接的服务，如数据报）。  需要注意，在计算机网络层次结构中，网络层被认为是不可靠的服务，即网络层传输的数据可能出现丢失、混乱或重复，这些不可靠的问题需要由传输层来考虑解决。
端口的概念
网络层的数据交付是点到点的，也就是主机到主机的交付。当一个IP数据报到达了主机，如何判断这份数据报应该交给哪个进程呢？传输层引入了端口，每个进程与一个端口号绑定。主机把IP数据报解封，就能看到里面的传输层数据包，其包头中写明了目的端口，只需要把数据交付给对应于这个端口的进程即可。
结合IP和端口，就能唯一地标识一台主机上的一个进程，这就是Socket（套接字）：
套接字 = （主机IP地址， 端口号）
TCP  TCP协议的特点
 TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要针对之前提及的网络层数据传输的丢失、混乱或重复问题，实现传输层上的可靠、有序、无丢失和不重复。
TCP的主要特点如下：
 面向连接。 每条连接只能有两个端点，即一对一的。 可靠的交付服务，保证数据无差错、不丢失、不重复且有序。 全双工通信，即任何时刻双方都能进行数据的发送。为此，双方都应该设置发送缓存和接收缓存，用来临时存放双向通信的数据。 面向字节流。计算机网络中常见的一个问题是：面向字节和面向报文有什么区别？ 面向字节流是指TCP将应用程序交付下来的数据仅视为一连串的无结构的字节流，发送的时候按照TCP的规则进行发送，不会考虑保留原始数据的边界；而面向报文是指每次发送的数据作为一个报文，一个报文是一块有结构的数据。   TCP报文段
 想要理解TCP的连接建立等等细节，认识其报头是必要的。TCP有固定的20B报头，变长字段配合填充字段使TCP报头长度始终是4B的整数倍。由于首部长度字段只有4位，故报头最长为15 * 4 = 60B
TCP报头格式如下：
TCP Header
每个字段的含义可以参见这篇文章。
 TCP连接管理
 TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传输和连接释放。TCP的连接管理就是使运输连接的建立和释放都能正常进行。
TCP连接的端口称为套接字（socket）或插口。连接采用C/S方式，主动发起连接的进程称为客户机（Client），被动等待连接的进程称为服务器（Server）。
连接的建立分为3个步骤，即三次握手：
TCP three-way-handshake
 第一步：客户机向服务器发送一个报文段，该报文段不含应用层数据，首部中的SYN标志被置为1，且该报文段占用了一个随机序号seq=x。 第二步：服务器收到连接请求，如同意连接，就向客户机发回确认，并为该连接分配TCP缓存和变量。确认报文中SYN和ACK都置为1，seq是服务器选用的初始随机序号，ack表示期望收到的下一个客户机报文序号。 第三步：客户机接收到确认报文，也要为该连接分配缓存和变量，并回复确认。  完成三次握手之后，双方的应用进程在任何时刻都可以发送数据（全双工）。
注意这里的第二步握手，服务器在此步分配资源，那么如果客户端不回应第三步的确认报文，则服务器在原地忙等，过一段时间后才删除这些资源；如果快速发送大量的SYN包给特定服务器，将耗尽它的资源，使得正常的连接无法被建立，这就是典型的SYN Flood攻击。
 三次握手的必要性：
进行三次握手是必要的。
从直觉进行理解：第一步握手是客户端向服务器发送数据，此时双方对信道的性质还不了解；第二步握手成功之后，客户端知道了服务器能够收到自己的数据，但服务器还不知道客户端能不能收到自己的数据；第三步握手成功之后，服务器知道客户端能收到自己的数据，可以开始通信。
进一步地，考虑以下这种两次握手的情况：</description>
    </item>
    
  </channel>
</rss>
