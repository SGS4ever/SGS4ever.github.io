<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络 on XR_G&#39;s Blog</title>
    <link>https://xrg.fj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 计算机网络 on XR_G&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Feb 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xrg.fj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PcapPlusPlus使用记录（二、通过解析数据包实现会话分割）</title>
      <link>https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/</guid>
      <description>&lt;h3 id=&#34;前情提要&#34;&gt;前情提要&lt;/h3&gt;&#xA;&lt;p&gt;在 &lt;a class=&#34;link&#34; href=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;上一篇PCPP使用记录&lt;/a&gt; 中，我记录了PcapPlusPlus这个库的环境安装和简单使用，紧接着，就准备基于这个库来实现一些具体的、有用的功能了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据包解析&#34;&gt;数据包解析&lt;/h3&gt;&#xA;&lt;p&gt;PCPP这个库将一个原始数据包解析为若干层，每一层的协议信息由一个变量来保存，我们可以自由读写这些解析后的数据。&lt;/p&gt;&#xA;&lt;p&gt;一个 &lt;code&gt;RawPacket&lt;/code&gt; 表示原始的字节流，也就是我们最开始从 &lt;code&gt;pcap&lt;/code&gt; 文件中读进来的一个数据包，经过解析，可以将这个数据包拆分成我们熟悉的若干层数据！PCPP的一个特性是它不保存多个副本，而只是在同一个数据包上标记各层协议的起点，这些起点可以由上一层解析结果访问到。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 189; &#xA;&#x9;&#x9;&#x9;flex-basis: 455px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/1.png&#34; data-size=&#34;1008x531&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/1.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;1008&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;531&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/1_hu4536406193136881233.png 480w, https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%BA%8C%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E5%88%86%E5%89%B2/1_hu17816000552433158030.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;示例&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;示例&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;例如这个图中的解析结果，首先是数据链路层的 &lt;code&gt;Ethernet Layer&lt;/code&gt; ，它可以看到所有原始数据；由 &lt;code&gt;Ethernet Layer&lt;/code&gt; 层扣除它的头部数据，就是整个 &lt;code&gt;IPv4&lt;/code&gt; 层的数据；而由 &lt;code&gt;IPv4&lt;/code&gt; 层再继续解析，就是 &lt;code&gt;UDP&lt;/code&gt; 层啦！这样层层递推，实际上跟学习计算机网络的时候对数据包的解析顺序差不多。&lt;/p&gt;&#xA;&lt;p&gt;PCPP提供的数据包解析方法有两种，我们分别来看。&lt;/p&gt;&#xA;&lt;p&gt;首先还是需要先创建一个 &lt;code&gt;reader&lt;/code&gt; ，如果你还记得第一章的内容，那就很简单了：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;IPv4Layer.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;Packet.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;PcapFileDevice.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Part 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;c1&#34;&gt;// open a pcap file for reading&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;n&#34;&gt;pcpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFileReaderDevice&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pcpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFileReaderDevice&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getReader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test_file_1.pcap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cerr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Cannot determine reader for file type&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cerr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Cannot open input.pcap for reading&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// read the first packet from the file&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;pcpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RawPacket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rawPacket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getNextPacket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rawPacket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cerr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Couldn&amp;#39;t read the first packet in the file&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ===== Code to write =====&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面是程序的基本框架，已经写好了创建Reader、读取第一个数据包 &lt;code&gt;rawPacket&lt;/code&gt; 的部分。接下来的所有代码都追加在 &lt;em&gt;Code to write&lt;/em&gt; 那块地方~&lt;/p&gt;</description>
    </item>
    <item>
      <title>PcapPlusPlus使用记录（一、环境搭建&amp;简单使用）</title>
      <link>https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;&#xA;&lt;p&gt;由于项目的需要，近期产生了一个需求：将一个 &lt;code&gt;pacp&lt;/code&gt; 文件解析出来，然后尝试提取每个连接的各种统计数据，例如提取一个完整的TCP会话中的源IP、目的IP、源端口、目的端口、会话开始时间、会话结束时间、发送的数据包数量、发送的数据包总大小等等。&lt;/p&gt;&#xA;&lt;p&gt;能够实现这一需求的库有很多，如python中的 &lt;code&gt;scapy&lt;/code&gt; 、 &lt;code&gt;dpkt&lt;/code&gt; ，C++中的 &lt;code&gt;PcapPlusPlus&lt;/code&gt; 等，考虑到将来可能需要处理较大的 &lt;code&gt;pcap&lt;/code&gt; 文件，以及C++相比于python在执行速度上的优势，我决定使用C++作为流量处理的语言；简单翻阅了一下 &lt;a class=&#34;link&#34; href=&#34;https://pcapplusplus.github.io/docs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;PcapPlusPlus的文档&lt;/a&gt; ，我认为这个库的易用性能够满足我较低的水平，因此决定先实践一下再说。&lt;/p&gt;&#xA;&lt;h3 id=&#34;预装依赖&#34;&gt;预装依赖&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;从这里开始，我想将 &lt;em&gt;PcapPlusPlus&lt;/em&gt; 简称为 &lt;em&gt;PCPP&lt;/em&gt; ，方便文章的撰写之用&lt;/strong&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文使用的环境是：Win10 + VisualStudio2019&lt;/strong&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;要使用这个库，我们需要先安装一些依赖。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;个人建议将这些依赖下载到同一个地方，方便管理！&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装 &lt;a class=&#34;link&#34; href=&#34;https://www.winpcap.org/devel.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;WinPcap开发者工具&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://nmap.org/npcap/#download&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Npcap SDK&lt;/a&gt; 。下载解压而已，很简单！我这边使用的是WinPcap 。&lt;/li&gt;&#xA;&lt;li&gt;安装 &lt;a class=&#34;link&#34; href=&#34;https://sourceware.org/pub/pthreads-win32/pthreads-w32-2-9-1-release.zip&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;pthread-win32工具&lt;/a&gt; ，注意这里的链接跟PCPP文档里面的链接是不一样的！文档里面的URL协议是 &lt;code&gt;ftp&lt;/code&gt; ，我下载的时候好像打不开的样子，就改为使用 &lt;code&gt;https&lt;/code&gt; 了！&lt;/li&gt;&#xA;&lt;li&gt;可能还需要一个 &lt;a class=&#34;link&#34; href=&#34;https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;Microsoft Visual C++ Redistributable&lt;/a&gt; 工具，从这里下下来的是个 &lt;code&gt;exe&lt;/code&gt; 文件，我在后面的过程中 &lt;strong&gt;暂时没有用到&lt;/strong&gt; ！也就是说我还没运行过这个EXE，先下载下来而已！&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;下载pcapplusplus&#34;&gt;下载PcapPlusPlus&lt;/h3&gt;&#xA;&lt;p&gt;直接从 &lt;a class=&#34;link&#34; href=&#34;https://github.com/seladb/PcapPlusPlus/releases/tag/v21.11&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;PcapPlusPlus v21.11&lt;/a&gt; 页面上把示例代码下载下来！我这边选用的是 &lt;code&gt;windows-vs2019&lt;/code&gt; 这个压缩包！&lt;/p&gt;&#xA;&lt;p&gt;到这一步，算上我们之前下载 &lt;strong&gt;并解压&lt;/strong&gt; 的依赖，文件夹里面应该有这么多东西：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 396; &#xA;&#x9;&#x9;&#x9;flex-basis: 950px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1.png&#34; data-size=&#34;1097x277&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;1097&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;277&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1_hu7092810374815015958.png 480w, https://xrg.fj.cn/p/pcapplusplus%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/1_hu7438629118220533595.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;现有的文件&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;现有的文件&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP加速技术简述</title>
      <link>https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/</guid>
      <description>&lt;p&gt;传输控制协议（TCP）是我们的老朋友了，它力求在不可靠的IP网络上实现可靠的数据传输，也就是使得数据包有序、无丢失和不重复，因此，引入了如校验、序号、确认、重传等机制。同时，这位老朋友也是比较负责任的，在网络拥挤时，为了不使情况雪上加霜，它引入了慢启动、拥塞避免等机制。&lt;/p&gt;&#xA;&lt;p&gt;现在的网络世界中，我们日常进行的网页浏览、游戏、视频等活动都离不开TCP。随着网络的发展，网络上面承载的数据包越来越多，在为多数人所共享的广域网上，在人们上网的高峰期，网络会存在一定的拥塞，反映到我们的上网体验上，就是延迟和丢包。加载个网页要花掉十几秒、玩个王者荣耀时不时延迟200+、看视频卡顿等，除了设备的问题，恐怕网络拥塞难辞其咎。在这样的背景之下，TCP加速技术也就产生和发展了。&lt;/p&gt;&#xA;&lt;p&gt;实际上，TCP加速也不是一个新的概念了，十几年前就有相关的研究，但是这一理念在现今的背景下显得较有意义，我们对其进行一些学习和实践，大概不算是浪费时间的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;两种方案&#34;&gt;两种方案&lt;/h3&gt;&#xA;&lt;p&gt;TCP加速可以从几个角度来进行分类，较为常见且易懂的是从加速方案的部署位置来分。如果只在客户/服务器的某一边来部署TCP加速，就叫做 &lt;em&gt;单边加速&lt;/em&gt; ，如果双方都要部署，就叫做 &lt;em&gt;双边加速&lt;/em&gt; 。两种方案一般有不同的使用场景，单边加速常部署在服务端上，这样就能透明地提升用户的访问体验；双边加速常常是双方协商好的一套加速方案，因此不能做到透明，可以用在客户端和服务端都可控的场景中，比如在个人云服务器上运行着某项服务，此时可以在自己的客户端PC和服务端都部署TCP加速，来改善访问体验。&lt;/p&gt;&#xA;&lt;h3 id=&#34;单边加速概述&#34;&gt;单边加速概述&lt;/h3&gt;&#xA;&lt;p&gt;单边加速方案只需要由客户或服务端的一方来部署，比较简单，且对对方是透明的。我们首先要知道TCP是怎么工作的：在 &lt;strong&gt;协议规定&lt;/strong&gt; 的运行模式下，发送方的系统 &lt;strong&gt;产生和处理数据&lt;/strong&gt; 、 &lt;strong&gt;把数据交给网卡&lt;/strong&gt; 、网卡发送数据，接收方接收数据、把数据交给系统、处理数据。从这一套流程中，我们应该发现几个可以下手的地方，每个地方都尝试一下，我们对TCP加速的认识也就差不多了。&lt;/p&gt;&#xA;&lt;h4 id=&#34;数据包处理优化&#34;&gt;数据包处理优化&lt;/h4&gt;&#xA;&lt;p&gt;说是数据包处理优化，其实就是所谓的“网络性能优化”。这个概念跟TCP协议本身没有太多关系，主要是针对收发数据双方的硬件、操作系统等进行优化。&lt;/p&gt;&#xA;&lt;h5 id=&#34;减少复制&#34;&gt;减少复制&lt;/h5&gt;&#xA;&lt;p&gt;按照上面说过的流程，发送方的系统要产生和处理数据，然后把数据交给网卡。这一步是一个复制的过程，也就是将数据从系统或者应用程序所在的内存空间复制了一份到网卡的内存空间。这一步是可以优化的，有下面这几种办法。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;直接访问网卡存储空间&lt;/em&gt; 。这种方案取消了复制，而采用地址映射或直接访问的办法，相当于将网卡看作了操作系统的一部分。为了实现这种方案，网卡要具备一定的智能性，否则无法支持多应用的访问，也无法在合适的时机传递数据。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;与网卡共享存储区域&lt;/em&gt; 。让网卡用DMA或其他什么方式来访问内核内存空间，比上面的方案简单一些，对网卡的要求少一些。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;其他各种内存映射方案&lt;/em&gt; 。内存映射可以实现应用、网卡和内核三者的内存共享，无论是什么内存映射方案，核心都是减少复制。&lt;/p&gt;&#xA;&lt;h5 id=&#34;减少中断&#34;&gt;减少中断&lt;/h5&gt;&#xA;&lt;p&gt;系统要把数据交给网卡，或者网卡收到数据要交给系统的时候，一般都会触发中断。操作系统处理中断是需要花费时间的，因此这一步也是可以优化的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;将异步触发变为轮询&lt;/em&gt; 。有些研究者将TCP/IP的处理放置到一台单独的设备上，这样，就可以将协议数据的收发处理由中断的方式改变为比较简单的系统轮询。轮询的频率是要仔细调整的，太慢则数据处理产生延迟，太快则系统负载过大。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;中断合并&lt;/em&gt; 。中断合并就是将多个中断合并到一起处理，也就是不在每次收到数据时产生中断，而是在数据积累到一定的量时再产生一次中断。这种方案使得延迟跟报文长度有关系了，且在处理数据的时候可能一次处理了多个报文，应用程序的调度也受到一些影响。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;增加单个报文的长度&lt;/em&gt; 。思想和中断合并是类似的，就是将报文数据积累到一定长度再发送。但这一步是交给上层协议来完成的，跟中断合并时有区别的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;报文过滤&lt;/em&gt; 。总会有一些报文是没意义的，比如一些广播数据、一些没用的UDP报文，这些数据直接交给网卡来过滤，就能够减少中断。&lt;/p&gt;&#xA;&lt;h5 id=&#34;用户级传输协议&#34;&gt;用户级传输协议&lt;/h5&gt;&#xA;&lt;p&gt;传统的协议处理是在用户空间内完成的，因此要减少复制，只能引入各种内存映射或共享的方案。人们可以在用户空间实现传输层的协议，节省了数据复制的时间。&lt;/p&gt;&#xA;&lt;h5 id=&#34;tcp卸载引擎&#34;&gt;TCP卸载引擎&lt;/h5&gt;&#xA;&lt;p&gt;将软件执行转移到硬件执行，一直是性能优化的不二法门。如果在网卡硬件上运行一些特殊的系统，使得数据处理等步骤直接由网卡完成，那末系统的负载就小了，执行起来就快了。&lt;/p&gt;&#xA;&lt;p&gt;TCP卸载引擎的缺点是存在的，那就是网卡硬件性能的提升要与系统其他硬件保持同步，否则还是可能成为传输速度的瓶颈；当然，要在网卡上实现数据处理的系统，本身的硬件和软件的设计难度也是很大的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;协议细节优化&#34;&gt;协议细节优化&lt;/h4&gt;&#xA;&lt;p&gt;数据包处理优化实际上就是针对机器本身的“网络性能优化”，而协议细节的优化才真正关乎TCP协议本身。&lt;/p&gt;&#xA;&lt;h5 id=&#34;拥塞控制优化&#34;&gt;拥塞控制优化&lt;/h5&gt;&#xA;&lt;p&gt;TCP的拥塞控制机制我们是熟悉的，那就是：慢启动、拥塞避免（加法增加、乘法减少）。其实在这两个机制的基础上，延伸出的快重传和快恢复也属于拥塞控制的优化，当然我们还要有更多的尝试。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;针对拥塞状态的判断&lt;/em&gt; 。我们如何判断网络是否拥塞呢？TCP协议一般以超时和重复ACK为标准。超时意味着不仅自己的数据没有到达，对方的重复ACK也没有到达，网络的拥塞情况已经比较严重了，因此传统的处理方法是将发送窗口减到 &lt;code&gt;1&lt;/code&gt; ，阈值减半，重新开始慢启动。重复ACK意味着自己的数据没有到达，对方的ACK可以到达，网络的拥塞情况还不那么严重，因此传统的处理方法是将阈值减半，发送窗口减到阈值大小，重新加法增加。慢启动和加法增加都是保守的，对带宽不一定有充分的利用，尤其当网络出现了小波动的时候，如果误判为拥塞，就会导致传输速度骤降，而带宽空闲。&lt;/p&gt;&#xA;&lt;p&gt;有若干种针对拥塞状态的判断方案，例如zetaTCP使用了动态学习的方法判断拥塞，过滤非拥塞情况引起的丢包现象，预判拥塞丢包的概率并基于这一概率直接重传。Fast TCP结合延迟信息反馈来判断拥塞，Westwood结合带宽测量的技术来判断拥塞。&lt;/p&gt;&#xA;&lt;h5 id=&#34;参数调节&#34;&gt;参数调节&lt;/h5&gt;&#xA;&lt;p&gt;TCP协议的参数是指预先写好的、控制协议工作的一些参数，如用于进行拥塞避免的拥塞窗口阈值，用于传输数据的MTU，用于判断超时的超时时间等。针对这些参数进行仔细的调节，可以一定程度达到TCP加速的目的。&lt;/p&gt;&#xA;&lt;h5 id=&#34;并行tcp&#34;&gt;并行TCP&lt;/h5&gt;&#xA;&lt;p&gt;并行TCP的理念是将原本的一条TCP连接修改为多条TCP连接，将原本使用一条连接来传输的数据放在多条连接上传输。这种思路归根到底是对拥塞避免算法的改造，原本一条连接上的拥塞避免算法，其强度在改为多条连接之后得到了削弱。例如原本的拥塞窗口是 &lt;code&gt;N&lt;/code&gt; ，改成 &lt;code&gt;k&lt;/code&gt; 条连接之后就成了 &lt;code&gt;kN&lt;/code&gt; ，每次在拥塞避免时还是只把阈值减少 &lt;code&gt;N/2&lt;/code&gt; ，对总的窗口的影响就没那么大了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;双边加速以udp-speeder为例&#34;&gt;双边加速——以UDP Speeder为例&lt;/h3&gt;&#xA;&lt;p&gt;双边加速要求在客户端和服务端都部署相同的加速方案，常规思路是把复杂的TCP协议转化为私有的协议。使用私有协议，可以对数据包处理、重传/拥塞避免等机制进行调整，从而达到加速的目的。&lt;/p&gt;&#xA;&lt;p&gt;以开源的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/wangyu-/UDPspeeder/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;UDP Speeder&lt;/a&gt; 为例，该系统在客户-服务器之间架设了一条隧道，在隧道中传输的数据使用了前向纠错编码，使得数据即便在传输过程中产生了一些错误和丢失，也能通过冗余的编码数据来把原始数据恢复过来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP加速之环境搭建（WANem）</title>
      <link>https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/</guid>
      <description>&lt;p&gt;我们可能遇到这样的情景：有一些实验需要在广域网环境下（存在一定的延迟、丢包等）完成，但我们不希望花费成本去租借一台云服务器，只希望在虚拟机网络中模拟出广域网的环境，应该如何实现呢？&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文是TCP加速系列总结的一部分&lt;/strong&gt; ，我们希望完成TCP加速的实验，这时要求我们的实验环境不仅是一个广域网，还需要是一个存在 &lt;strong&gt;一定拥塞&lt;/strong&gt; 、会发生 &lt;strong&gt;一定丢包&lt;/strong&gt; 的广域网，这种情况下，如果我们不使用模拟环境，而使用真实服务器的话，实验效果就可能受到服务器地理位置、实验时间段等等因素的影响了。&lt;/p&gt;&#xA;&lt;p&gt;好在，我们可以使用WANem这一稳定、易用的广域网模拟器来解决我们的问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;&#xA;&lt;p&gt;WANem基于iptables和tc（Traffic Control）实现，可以实现对网络延迟、丢包率、抖动、噪音等的模拟，使用者可以简单地设定并复现出某个特定的网络环境，因而逐渐替代软件仿真成为新一代的网络测试床。与之具备类似概念的工具有微软的Network Emulator for Windows Toolkit（NEWT）、Linux 2.6自带的Netem等。事实上，此前说的tc（Traffic Control）就是用来控制Netem工作的，因此可以理解为WANem是基于Netem所构建。&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装与访问&#34;&gt;安装与访问&lt;/h3&gt;&#xA;&lt;p&gt;WANem类似于一台虚拟机，可以直接 &lt;a class=&#34;link&#34; href=&#34;https://sourceforge.net/projects/wanem/files/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;下载&lt;/a&gt; iso文件，并在VMWare中安装。Linux类型选择 &lt;em&gt;其他Linux 64位&lt;/em&gt; 即可。&lt;/p&gt;&#xA;&lt;p&gt;启动之后，可以使用DHCP获取IP，或者手动配置IP；虚拟机会要求你设置口令，你可以使用用户名 &lt;code&gt;perc&lt;/code&gt; 和你设置的口令来远程登录到系统上。&lt;/p&gt;&#xA;&lt;p&gt;成功启动之后，会出现 &lt;code&gt;WANemControl@PERC&amp;gt;&lt;/code&gt; 的命令行提示符，使用 &lt;code&gt;help&lt;/code&gt; 命令可以查看该命令行支持的命令。&lt;/p&gt;&#xA;&lt;p&gt;一般来说，你现在就可以在另一台机器的浏览器上使用 &lt;code&gt;http://&amp;lt;WANem IP&amp;gt;/WANem&lt;/code&gt; 来访问控制界面了（注意URL大小写）。假如你不知道WANem的IP地址，则使用 &lt;code&gt;exit2shell&lt;/code&gt; 命令来返回到Linux命令行中，使用我们熟悉的 &lt;code&gt;ip addr&lt;/code&gt; 命令就可以看到WANem的IP。&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 250; &#xA;&#x9;&#x9;&#x9;flex-basis: 601px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/1.png&#34; data-size=&#34;1668x666&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/1.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;1668&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;666&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/1_hu7404484509399747497.png 480w, https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/1_hu3848007734253178292.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;成功访问WANem&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;成功访问WANem&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;配置规则&#34;&gt;配置规则&lt;/h3&gt;&#xA;&lt;p&gt;首次进入控制界面时，我们看到的是WANem的 &lt;code&gt;Basic Mode&lt;/code&gt; ，这个模式下，我们可以配置 &lt;em&gt;带宽&lt;/em&gt; 和 &lt;em&gt;延迟&lt;/em&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;点击导航栏中的 &lt;code&gt;Advanced Mode&lt;/code&gt; 进入高级配置，我们看到如下的界面：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 239; &#xA;&#x9;&#x9;&#x9;flex-basis: 575px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/2.png&#34; data-size=&#34;1670x697&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/2.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;1670&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;697&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/2_hu14173777976511409815.png 480w, https://xrg.fj.cn/p/tcp%E5%8A%A0%E9%80%9F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAwanem/2_hu8687160397923716579.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;Advanced Mode&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;Advanced Mode&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>DoS——拒绝服务攻击</title>
      <link>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;p&gt;网络安全理论复习开始了！&lt;/p&gt;&#xA;&lt;p&gt;今天从最简单的开始，目标是在寒假期间整理完成《网络安全》这门课所涉及的知识。希望本系列文章能以清晰的思路将安全理论表述出来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;dos&#34;&gt;DoS&lt;/h2&gt;&#xA;&lt;p&gt;Denial of Service，拒绝服务，是现代网络安全领域很常见的一种攻击。所谓拒绝服务，就是通过一系列手段使得原本正常运行的服务器无法再为用户的请求提供服务与应答，从而使目标业务停滞。&lt;/p&gt;&#xA;&lt;p&gt;我们经常能看到拒绝服务的例子：使用”呼死你“软件不断地拨打某人的电话，则其他人正常呼叫的时候他永远是占线的状态；网络”水军“控评，正常的评论和留言就无法被看到；黄牛使用恶意的抢票软件抢占所有电影票，使得正常渠道无法获得``````&lt;/p&gt;&#xA;&lt;p&gt;在计算机网络的世界中，拒绝服务攻击可以是非常粗暴的物理攻击：砸毁服务器、切断网线等；更为常见且稍微有点技术含量的是利用计算机本身的漏洞，构造恶意的网络请求来使目标系统崩溃、主机宕机、重启等。&lt;/p&gt;&#xA;&lt;p&gt;下面介绍一些常见的DoS攻击手法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ping-of-death&#34;&gt;Ping of Death&lt;/h3&gt;&#xA;&lt;p&gt;Ping of Death（死亡之Ping）的原理是构造一个超大的IP包来使目标主机瘫痪。在详细解释这个手法之前，需要从ICMP协议入手，介绍Ping的基本知识。&lt;/p&gt;&#xA;&lt;h4 id=&#34;icmp&#34;&gt;ICMP&lt;/h4&gt;&#xA;&lt;p&gt;网际控制报文协议（ICMP）用于让主机或路由器报告差错和异常情况。ICMP报文包含在IP数据报中，作为IP数据报的数据部分，加上IP首部发送出去，因此，ICMP是一个&lt;strong&gt;网络层协议&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;ICMP报文的种类有两种，&lt;strong&gt;ICMP差错报告报文&lt;/strong&gt;和&lt;strong&gt;ICMP询问报文&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;ICMP差错报告报文&lt;/strong&gt;用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，共有5种类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;终点不可达。&lt;/li&gt;&#xA;&lt;li&gt;源点抑制。由于拥塞而丢弃数据报时，要求源主机减小发送速率。&lt;/li&gt;&#xA;&lt;li&gt;时间超过。&lt;/li&gt;&#xA;&lt;li&gt;参数问题。路由器或目的主机收到的数据报首部中有的字段不正确。&lt;/li&gt;&#xA;&lt;li&gt;改变路由（重定向）。路由器把重定向信息发给主机，下一次使用更好的路由。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;ICMP询问报文&lt;/strong&gt;有4种类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;回送请求和应答。主机向目标发送ICMP请求，如果途中没有异常，则目标收到消息后恢复ICMP响应、&lt;/li&gt;&#xA;&lt;li&gt;时间戳请求和应答。测试来回一次的传输时间。主机填充原始时间戳，接收方受到后填充时间戳返回。&lt;/li&gt;&#xA;&lt;li&gt;掩码地址请求和回答。&lt;/li&gt;&#xA;&lt;li&gt;路由器询问和通告。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;ping&#34;&gt;PING&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;PING工作在应用层&lt;/strong&gt;。它直接使用网络层的&lt;strong&gt;ICMP询问报文&lt;/strong&gt;，而未使用传输层的TCP或UDP。如果一台主机能PING通另一台主机，证明至少存在着一条可用的物理通路。&lt;/p&gt;&#xA;&lt;h4 id=&#34;ping-of-death-1&#34;&gt;Ping of Death&lt;/h4&gt;&#xA;&lt;p&gt;死亡之Ping攻击利用了计算机实现IP协议时存在的缺陷。早期操作系统处理IP分组时，只开辟了&lt;strong&gt;64KB&lt;/strong&gt;的缓冲区用来存放收到的数据包。如果攻击者故意在ICMP Echo（即PING数据报）之后附加非常多的冗余信息，使最终的IP包的大小超过&lt;strong&gt;65535字节&lt;/strong&gt;的上限，接收方在处理这么大的IP包时就会产生内存分配错误，引起系统崩溃、挂起或重启。&lt;/p&gt;&#xA;&lt;p&gt;可以看到这种攻击的实现主要是由于&lt;strong&gt;IP协议栈&lt;/strong&gt;的漏洞，那为什么叫做死亡之Ping呢？因为使用PING工具太容易完成这种攻击，以至于它也成为了这种攻击的首选武器。当然，除了PING之外的任何能够构造超大IP包的程序都能实现这个攻击。&lt;/p&gt;&#xA;&lt;p&gt;Ping of Death攻击不好预防，因为IP存在分组机制，每个IP包看起来都非常正常。最好的办法是在系统实现层面进行完善，使内核不再对超过规定长度的包进行重组。&lt;/p&gt;&#xA;&lt;h3 id=&#34;teardrop&#34;&gt;TearDrop&lt;/h3&gt;&#xA;&lt;p&gt;又是IP协议实现的问题。故事从IP分片讲起。&lt;/p&gt;&#xA;&lt;h4 id=&#34;分片&#34;&gt;分片&lt;/h4&gt;&#xA;&lt;p&gt;我们知道，数据链路层的每个数据报能够承载的数据量是有上限的，这个上限称为&lt;em&gt;最大传送单元（MTU）&lt;/em&gt;。因为IP数据报被封装在数据链路层的数据报中，因此链路层的MTU严格地限制着IP数据报的长度。IP包传送的路径上，有许许多多的链路，可能使用不同的链路层协议，而同时也可能有大小不一的MTU。当IP数据报的总长度大于链路MTU时，需要能够将IP数据报中的数据分装在两个或多个较小的&lt;strong&gt;IP数据报中&lt;/strong&gt;，然后再作为链路层数据进行传送。这些较小的数据报称为&lt;strong&gt;片&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;片在目的地网络层被重新&lt;strong&gt;组装&lt;/strong&gt;。对于一大堆杂乱无章的片，我们如何正确地重装成一个个独立的IP数据报呢？&lt;/p&gt;&#xA;&lt;p&gt;IP协议使用首部的标识、标志和片偏移字段来完成对片的重组。我们看看IP数据报的首部：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 174; &#xA;&#x9;&#x9;&#x9;flex-basis: 419px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/1.png&#34; data-size=&#34;906x518&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/1.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;906&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;518&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/1_hu3360648763880945663.png 480w, https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/1_hu18096489878057281178.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;IP Header&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;IP Header&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;第二行的&lt;strong&gt;标识字段&lt;/strong&gt;占16位。它是一个计数器，每产生一个数据报就加一。分片时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;标志位&lt;/strong&gt;有3比特。实际上只有后面2个比特有意义。它们分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MF位（More Fragment）。当&lt;code&gt;MF = 1&lt;/code&gt;时，表示这个数据报后面还有后续的片；当&lt;code&gt;MF = 0&lt;/code&gt;时表示这是最后一个片。&lt;/li&gt;&#xA;&lt;li&gt;DF位（Don&amp;rsquo;t Fragment）。只有&lt;code&gt;DF = 0&lt;/code&gt;时才允许将一个数据报分片。若&lt;code&gt;DF = 1&lt;/code&gt;且数据报大小大于链路层的MTU，只能丢弃并发送ICMP错误信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;片偏移&lt;/strong&gt;占13位。既然一个数据报能被分成好几个小片，那么每个小片需要记录自己在原始数据报中的位置，否则怎么重组呢？片偏移的单位是&lt;strong&gt;8B&lt;/strong&gt;，也就意味着除了最后一个片外，每个片中的有效载荷&lt;strong&gt;都是8的倍数（字节）&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>传输层协议——TCP</title>
      <link>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</guid>
      <description>&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;传输层的功能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。&lt;/p&gt;&#xA;&lt;p&gt;实际上，传输层起到一个承上启下的作用。它之下的网络层、数据链路层、物理层被称为通信子网，其实现细节对用户是不可见的。&lt;/p&gt;&#xA;&lt;p&gt;传输层的功能如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供进程之间的逻辑通信（即端到端的通信）。进程间的逻辑通信是指本主机上运行的某个进程和对方主机上运行的某个进程进行通信。而与此相对的，网络层提供的是点到点的通信，指的是本主机与对方主机的通信。&lt;/li&gt;&#xA;&lt;li&gt;复用和分用。多个进程可以使用同一个传输层协议封装自己的数据，而对方主机可以使用同样的协议正确解析这些数据，交付给正确的应用进程。&lt;/li&gt;&#xA;&lt;li&gt;差错检测。传输层检测首部和数据部分的差错，而网络层只检查IP数据报的首部，不检查数据部分是否出错。&lt;/li&gt;&#xA;&lt;li&gt;提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。网络层无法同时实现两种协议（即要么使用面向连接的服务，如虚电路；要么只提供无连接的服务，如数据报）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;需要注意，在计算机网络层次结构中，网络层被认为是不可靠的服务，即网络层传输的数据可能出现&lt;strong&gt;丢失、混乱或重复&lt;/strong&gt;，这些不可靠的问题需要由传输层来考虑解决。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;端口的概念&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;网络层的数据交付是点到点的，也就是主机到主机的交付。当一个IP数据报到达了主机，如何判断这份数据报应该交给哪个进程呢？传输层引入了端口，每个进程与一个端口号绑定。主机把IP数据报解封，就能看到里面的传输层数据包，其包头中写明了目的端口，只需要把数据交付给对应于这个端口的进程即可。&lt;/p&gt;&#xA;&lt;p&gt;结合IP和端口，就能唯一地标识&lt;strong&gt;一台主机上的一个进程&lt;/strong&gt;，这就是Socket（套接字）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;套接字 = （主机IP地址， 端口号）&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP协议的特点&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要针对之前提及的网络层数据传输的&lt;em&gt;丢失、混乱或重复&lt;/em&gt;问题，实现传输层上的&lt;em&gt;可靠、有序、无丢失和不重复&lt;/em&gt;。&lt;/p&gt;&#xA;&lt;p&gt;TCP的主要特点如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向连接。&lt;/li&gt;&#xA;&lt;li&gt;每条连接只能有两个端点，即一对一的。&lt;/li&gt;&#xA;&lt;li&gt;可靠的交付服务，保证数据无差错、不丢失、不重复且有序。&lt;/li&gt;&#xA;&lt;li&gt;全双工通信，即任何时刻双方都能进行数据的发送。为此，双方都应该设置发送缓存和接收缓存，用来临时存放双向通信的数据。&lt;/li&gt;&#xA;&lt;li&gt;面向字节流。计算机网络中常见的一个问题是：&lt;em&gt;面向字节和面向报文有什么区别？&lt;/em&gt; 面向字节流是指TCP将应用程序交付下来的数据仅视为一连串的无结构的字节流，发送的时候按照TCP的规则进行发送，不会考虑保留原始数据的边界；而面向报文是指每次发送的数据作为一个报文，一个报文是一块有结构的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP报文段&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;想要理解TCP的连接建立等等细节，认识其报头是必要的。TCP有固定的20B报头，变长字段配合填充字段使TCP报头长度始终是4B的整数倍。由于首部长度字段只有4位，故报头最长为&lt;code&gt;15 * 4 = 60B&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;TCP报头格式如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 207; &#xA;&#x9;&#x9;&#x9;flex-basis: 498px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/1.png&#34; data-size=&#34;1042x502&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/1.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;1042&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;502&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/1_hu14795665122985186431.png 480w, https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/1_hu12703589822414549804.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;TCP Header&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;TCP Header&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个字段的含义可以参见&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/a19881029/article/details/29557837&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;这篇文章&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP连接管理&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传输和连接释放。TCP的连接管理就是使运输连接的建立和释放都能正常进行。&lt;/p&gt;&#xA;&lt;p&gt;TCP连接的端口称为套接字（socket）或插口。连接采用C/S方式，主动发起连接的进程称为客户机（Client），被动等待连接的进程称为服务器（Server）。&lt;/p&gt;&#xA;&lt;p&gt;连接的建立分为3个步骤，即三次握手：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure &#xA;&#x9;&#xA;&#x9;&#x9;class=&#34;gallery-image&#34; &#xA;&#x9;&#x9;style=&#34;&#xA;&#x9;&#x9;&#x9;flex-grow: 97; &#xA;&#x9;&#x9;&#x9;flex-basis: 232px&#34;&#xA;&#x9;&gt;&#xA;&#x9;&lt;a href=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/2.png&#34; data-size=&#34;656x676&#34;&gt;&#xA;&#x9;&#x9;&lt;img src=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/2.png&#34;&#xA;&#x9;&#x9;&#x9;width=&#34;656&#34;&#xA;&#x9;&#x9;&#x9;height=&#34;676&#34;&#xA;&#x9;&#x9;&#x9;srcset=&#34;https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/2_hu2984964921501660302.png 480w, https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/2_hu3965702527035902876.png 1024w&#34;&#xA;&#x9;&#x9;&#x9;loading=&#34;lazy&#34;&#xA;&#x9;&#x9;&#x9;alt=&#34;TCP three-way-handshake&#34;&gt;&#xA;&#x9;&lt;/a&gt;&#xA;&#x9;&#xA;&#x9;&lt;figcaption&gt;TCP three-way-handshake&lt;/figcaption&gt;&#xA;&#x9;&#xA;&lt;/figure&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一步：客户机向服务器发送一个报文段，该报文段不含应用层数据，首部中的SYN标志被置为1，且该报文段占用了一个随机序号&lt;code&gt;seq=x&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;第二步：服务器收到连接请求，如同意连接，就向客户机发回确认，&lt;strong&gt;并为该连接分配TCP缓存和变量&lt;/strong&gt;。确认报文中SYN和ACK都置为1，seq是服务器选用的初始随机序号，ack表示期望收到的下一个客户机报文序号。&lt;/li&gt;&#xA;&lt;li&gt;第三步：客户机接收到确认报文，也要为该连接分配缓存和变量，并回复确认。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;完成三次握手之后，双方的应用进程在任何时刻都可以发送数据（全双工）。&lt;/p&gt;&#xA;&lt;p&gt;注意这里的第二步握手，服务器在此步分配资源，那么如果客户端不回应第三步的确认报文，则服务器在原地忙等，过一段时间后才删除这些资源；如果&lt;strong&gt;快速发送大量&lt;/strong&gt;的SYN包给特定服务器，将耗尽它的资源，使得正常的连接无法被建立，这就是典型的&lt;em&gt;SYN Flood攻击&lt;/em&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
